Directory structure:
└── ib-bsb-br-ratpoison/
    ├── README
    ├── README.developers
    ├── AUTHORS
    ├── autogen.sh
    ├── ChangeLog
    ├── configure.ac
    ├── COPYING
    ├── FAQ
    ├── INSTALL
    ├── Makefile.am
    ├── NEWS
    ├── TODO
    ├── .dir-locals.el
    ├── contrib/
    │   ├── allwindows.sh
    │   ├── clickframe.pl
    │   ├── expose.pl
    │   ├── genrpbindings
    │   ├── Makefile.am
    │   ├── nogaps.el
    │   ├── ratdate.sh
    │   ├── ratpoison.el
    │   ├── rpbatch.pl
    │   ├── rpshowall.sh
    │   ├── rpws
    │   ├── sloppy.c
    │   ├── split.sh
    │   └── unrat.c
    ├── doc/
    │   ├── fdl.texi
    │   ├── ipaq.ratpoisonrc
    │   ├── Makefile.am
    │   ├── ratpoison.mdoc.1
    │   └── sample.ratpoisonrc
    ├── m4/
    │   ├── ax_check_compile_flag.m4
    │   └── codeset.m4
    └── src/
        ├── actions.h
        ├── bar.c
        ├── bar.h
        ├── communications.c
        ├── communications.h
        ├── completions.c
        ├── completions.h
        ├── conf.h
        ├── data.h
        ├── editor.c
        ├── editor.h
        ├── events.c
        ├── events.h
        ├── format.c
        ├── format.h
        ├── frame.c
        ├── frame.h
        ├── getopt.c
        ├── getopt.h
        ├── getopt1.c
        ├── globals.c
        ├── globals.h
        ├── group.c
        ├── group.h
        ├── history.c
        ├── history.h
        ├── hook.c
        ├── hook.h
        ├── input.c
        ├── input.h
        ├── linkedlist.c
        ├── linkedlist.h
        ├── main.c
        ├── Makefile.am
        ├── manage.c
        ├── manage.h
        ├── messages.h
        ├── number.c
        ├── number.h
        ├── ratpoison.h
        ├── sbuf.c
        ├── sbuf.h
        ├── screen.c
        ├── screen.h
        ├── split.c
        ├── split.h
        ├── test-sbuf-utf8-nconcat.c
        ├── utf8.c
        ├── utf8.h
        ├── util.c
        ├── util.h
        ├── window.c
        ├── window.h
        ├── xrandr.c
        └── xrandr.h

================================================
FILE: README
================================================
Ratpoison - Say good-bye to the rodent
--------------------------------------

Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts

Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.

About
-----

ratpoison is a simple Window Manager with no fat library dependencies,
no fancy graphics, no window decorations, and no flashy wank. It is
largely modelled after GNU Screen which has done wonders in virtual
terminal market.

All interaction with the window manager is done through
keystrokes. ratpoison has a prefix map to minimize the key clobbering
that cripples Emacs and other quality pieces of software.

Building
--------

ratpoison uses autoconf and automake. To build it:

$ ./configure && make

if you want to install it system-wide, simply type 'make install' as
a privileged user:

# make install

If you retrieved ratpoison from the source repository, you will have to
install somewhat recent versions of autoconf and automake before
running:

$ ./autogen.sh

Customization
-------------

Use the configure option '--enable-debug' to enable debugging symbols
and verbose logging.

Use the configure option '--with-xterm=PROG' to set the x terminal
emulator to use. The default is `xterm'.

Consult the INSTALL file for more information about the configure script.

Using
-----

See the info manual for more information.



================================================
FILE: README.developers
================================================
-*- outline -*-

This file is intented to give people who would like to modify
ratpoison an idea the utility functions I've built up in ratpoison and
the structure of the code.

* Utility Functions

** String Manipulation

String manipulation is something C is seriously lacking, and something
everyone does all the time. When writing ratpoison code, you SHOULD
NOT be malloc'ing temporary string buffers then using strcat, strcpy,
etc to patch strings together. The following structures and functions
should give you just about everything you need.

If there's something you want to do but can't with the following
utils, then you should consider adding that functionality (Don't just
hack it!) to them. Chances are, someone else will want to do it too.

*** struct sbuf
When you need to build a string by concating a bunch together or some
messy frankensteinish string manipulation sbuf is nice to use. It
handles all the memory allocation and you just say what you want to do
with the sbuf_* commands. See sbuf.h.

*** char *xstrdup(char *)
If you need to copy a string, use this.

*** char *xsprintf (char *fmt, ...)  If you need to printf something
into a string, don't go xmalloc'ing strlen(s)+20. Use xsprintf, it
returns a new string, which you need to free when you're
done. Guaranteed.

*** char *xvsprintf (char *fmt, va_list ap)
This is just like xsprintf except it takes a va_list argument.

*** str_comp (char *s1, char *s2, int len)
Just like strncmp, except that it's case-insensitive.

** Memory

*** xmalloc and xrealloc
These functions are exactly like malloc and realloc, but they will
NEVER return NULL.

** Lists
Ratpoison has taken a double-linked list implementation from the Linux
kernel. Look at linkedlist.h. For an example of how to use it...read
the source!

* Coding Style

Ratpoison follows the GNU coding style as described in the GNU Coding
Standards Document (http://www.gnu.org/prep/standards.html). If you
see something not compliant with the GNU Standard, please fix it and
send a patch.



================================================
FILE: AUTHORS
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xe4 in position 1516: invalid continuation byte


================================================
FILE: autogen.sh
================================================
#!/bin/sh
# Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
#
# This file is part of ratpoison.
#
# ratpoison is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# ratpoison is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
# This file is just a wrapper for autoreconf

autoreconf -i "$@"



================================================
FILE: ChangeLog
================================================
The ratpoison project uses git for versioning.  Please refer to the git
repository if you're looking for a detailed list of changes.

See https://savannah.nongnu.org/git/?group=ratpoison



================================================
FILE: configure.ac
================================================
dnl Process this file with autoconf to produce a configure script.
dnl Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
dnl
dnl This file is part of ratpoison.
dnl
dnl ratpoison is free software; you can redistribute it and/or modify
dnl it under the terms of the GNU General Public License as published by
dnl the Free Software Foundation; either version 2 of the License, or
dnl (at your option) any later version.
dnl
dnl ratpoison is distributed in the hope that it will be useful,
dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
dnl GNU General Public License for more details.
dnl
dnl You should have received a copy of the GNU General Public License
dnl along with this program; if not, write to the Free Software
dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

AC_INIT([ratpoison], [1.4.10-beta], [ratpoison-devel@nongnu.org])
AC_CONFIG_AUX_DIR([build-aux])
AC_CONFIG_MACRO_DIR([m4])
AC_CONFIG_SRCDIR([src/main.c])
AM_INIT_AUTOMAKE([-Wall -Werror gnu])

AM_MAINTAINER_MODE([enable])

AC_CONFIG_HEADER(src/config.h)

dnl by default turn off debugging
AC_MSG_CHECKING([whether to enable debugging])
AC_ARG_ENABLE([debug],
  [AS_HELP_STRING([--enable-debug],[build with extra debugging messages])],
  [], [enable_debug=no])
AS_CASE([$enable_debug],
  [yes], [AC_MSG_RESULT([yes])
   	  AC_DEFINE([DEBUG], 1, [Define this to enable debugging messages])],
  [no], [AC_MSG_RESULT([no])],
  [AC_MSG_ERROR([invalid --enable-debug="$enable_debug" parameter])])

AC_ARG_WITH([electric-fence],
  [AS_HELP_STRING([--with-electric-fence],
    [Use the Electric Fence library (memory allocation debugging).])])

AC_ARG_WITH([xterm],
  [AS_HELP_STRING([--with-xterm=PROG],
    [set the x terminal emulator used by ratpoison])],
  [term_prog=$withval],
  [term_prog=xterm])
AC_DEFINE_UNQUOTED([TERM_PROG], ["$term_prog"], [X terminal emulator to use])

XFT_CFLAGS=
XFT_LIBS=
AC_ARG_WITH(xft,AS_HELP_STRING([--without-xft],[Don't use the Xft library even if available]),
                xft=$withval, xft=default)
if test "x$xft" != "xno"; then
    dnl Configure Xft.
    PKG_CHECK_MODULES([XFT], [xft],,[noop=noop])
    AC_MSG_CHECKING(whether to use Xft)
    echo "pkg_failed is $pkg_failed" >&5
dnl pkg_failed can be yes, no or untried (if there is no pkg-config or that does not work).
    if test "$pkg_failed" = "no" ; then
       AC_DEFINE_UNQUOTED(USE_XFT_FONT, 1, [Define this to use Xft])
       AC_MSG_RESULT(yes)
    elif test "x$xft" != "xdefault" ; then
dnl if explicitly requested but not found, bail out:
    	AC_MSG_RESULT(no)
    	if test "$pkg_failed" = "untried" ; then
	    AC_MSG_ERROR([Not Xft library found (this needs a working pkg-config)!])
	else
	    AC_MSG_ERROR([No Xft library found!])
	fi
    else
    	AC_MSG_RESULT(no)
    fi
else
    AC_MSG_CHECKING(whether to use Xft)
    AC_MSG_RESULT(no)
fi
AC_SUBST(XFT_CFLAGS)
AC_SUBST(XFT_LIBS)

AC_ARG_WITH([xkb],
  [AS_HELP_STRING([--without-xkb], [Don't build XKB support for keyboard input.])],
  [xkb=$withval],
  [xkb=yes])
AS_IF([test "X$xkb" = "Xyes"],
  [AC_DEFINE([WANT_XKB], 1,
    [Define to 1 if you want to build XKB support for keyboard input.])])

AC_MSG_CHECKING([manpage format])
AC_ARG_ENABLE([mdoc],
  [AS_HELP_STRING([--disable-mdoc],
    [install man(7) manpages, useful if you don't have a mdoc(7) formatter\
     such as mandoc(1) or groff(1)])],
  [], [enable_mdoc=yes])
AS_CASE([$enable_mdoc],
  [yes], [manpage_format=mdoc],
  [no],  [manpage_format=man],
  [AC_MSG_ERROR([invalid --enable-mdoc="$enable_mdoc" parameter])])
AC_MSG_RESULT([$manpage_format])
AC_SUBST([manpage_format])

AC_MSG_CHECKING([Xrandr support])
AC_ARG_WITH([xrandr],
  [AS_HELP_STRING([--without-xrandr],
    [Build without Xrandr support, default is to require and use it.])],
  [with_xrandr=$withval],
  [with_xrandr=check])
AC_MSG_RESULT([$with_xrandr])

dnl Checks for programs.
AC_PROG_CC
AM_MISSING_PROG([MANDOC], [mandoc])
AC_ARG_VAR([MANDOC],
  [path to mandoc(1), only used when regenerating doc/ratpoison.man.1 \
   after editing doc/ratpoison.mdoc.1])

AX_CHECK_COMPILE_FLAG([-Wall], [CFLAGS="-Wall $CFLAGS"], [], [], [])

dnl check for an x terminal emulator
AC_MSG_CHECKING(terminal emulator)
AC_MSG_RESULT($term_prog)

dnl Check for the X libs
AC_PATH_X
AC_PATH_XTRA

if test "x$no_x" = "xyes"; then
	AC_MSG_ERROR([*** Can't find X11 headers and libs])
fi


dnl Those who do not learn the lessons of history
dnl are doomed to delete it...  yuk yuk.  --ttn
AC_ARG_ENABLE([history],
  AS_HELP_STRING([--enable-history],
    [Link with libhistory (default: disabled. Note: only used for ! expansion)]),
  [], [enable_history=no])

HISTORY_LIBS=
have_history=no
AS_CASE([$enable_history],
  [no], [],
  [yes],
    [AC_CHECK_HEADERS([readline/history.h],
      [AC_CHECK_LIB([history], [add_history], [have_history=yes], [])],
      [])],
   [AC_MSG_ERROR([invalid --disable-history="$enable_history" parameter])])

AC_MSG_CHECKING([whether to use libhistory])
AS_CASE([$enable_history:$have_history],
  [yes:no], [AC_MSG_ERROR([Can't find history headers/lib. \
Install readline dev libs for history expansion.])],
  [no:*], [AC_MSG_RESULT([no])],
  [yes:yes], [AC_MSG_RESULT([yes])
            AC_DEFINE_UNQUOTED(HAVE_HISTORY, 1, Define this to enable history)
  	    HISTORY_LIBS="-lhistory"])

AC_SUBST(HISTORY_LIBS)

AC_CHECK_LIB(X11, XOpenDisplay, [X_LIBS="-lX11 $X_LIBS"],
	AC_MSG_ERROR([*** Can't find libX11]),$X_LIBS $X_EXTRA_LIBS)

mysavedCPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS $X_CFLAGS"
AC_CHECK_HEADERS([X11/XKBlib.h], [], [], [
#include <X11/Xlib.h>
])
CPPFLAGS="$mysavedCPPFLAGS"

AC_CHECK_LIB(Xtst, XTestFakeButtonEvent, [X_LIBS="-lXtst $X_LIBS"; AC_DEFINE(HAVE_LIBXTST,1,[Xtst])],,$X_LIBS $X_EXTRA_LIBS)
AC_CHECK_LIB([X11], [XkbKeycodeToKeysym],
  [AC_DEFINE(HAVE_XKBKEYCODETOKEYSYM, 1,
    [Define to 1 if you have the `XkbKeycodeToKeysym' function.])],
  [], [$X_LIBS $X_EXTRA_LIBS])

mysavedCPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS $X_CFLAGS"
AC_CHECK_HEADERS([X11/extensions/Xrandr.h], [xrandr_h=yes], [xrandr_h=no], [
#include <X11/Xlib.h>
])
CPPFLAGS="$mysavedCPPFLAGS"

AC_CHECK_LIB(Xrandr, XRRGetScreenResources, [libxrandr=yes], [libxrandr=no], [$X_LIBS $X_EXTRA_LIBS])

AS_CASE(["$with_xrandr:$xrandr_h:$libxrandr"],
  [yes:no:*], [AC_MSG_ERROR([*** Can't enable Xrandr support, header Xrandr.h not found.])],
  [yes:*:no], [AC_MSG_ERROR([*** Can't enable Xrandr support, libXrandr not found.])],
  [check:no:*], [AC_MSG_ERROR([*** Header Xrandr.h not found, use ./configure --without-xrandr to build without multiple screens support.])],
  [check:*:no], [AC_MSG_ERROR([*** libXrandr not found, use ./configure --without-xrandr to build without multiple screens support.])],
  [yes:yes:yes|check:yes:yes], [X_LIBS="-lXrandr $X_LIBS"
  			        AC_DEFINE(HAVE_XRANDR, 1, [Define to 1 if you want Xrandr support.])])

AC_SUBST(X_LIBS)
AC_SUBST(X_EXTRA_LIBS)
AC_SUBST(X_CFLAGS)

AS_IF([test "$with_electric_fence" = yes],
  [AC_CHECK_LIB([efence], [malloc], [],
    [AC_MSG_ERROR([Couldn't find the Electric Fence library (-lefence)])])])

dnl Checks for header files.
AC_HEADER_STDC
AC_CHECK_HEADERS([pwd.h sys/ioctl.h sys/stat.h])

dnl Checks for typedefs, structures, and compiler characteristics.
AC_C_TYPEOF

AH_TEMPLATE([HAVE___BUILTIN_PREFETCH],
  [Define to 1 if your compiler supports the `__builtin_prefetch' function.])
AC_MSG_CHECKING([for __builtin_prefetch()])
AC_LINK_IFELSE([AC_LANG_PROGRAM([],
  [
    int a = 9;
    __builtin_prefetch(&a);
    return 0;
  ])],
  [AC_DEFINE([HAVE___BUILTIN_PREFETCH], 1)
   AC_MSG_RESULT(yes)],
  [AC_MSG_RESULT(no)])

dnl Checks for library functions.
AC_CHECK_FUNCS(getline getopt_long getpwuid setenv setpgid setpgrp setsid)
AC_CHECK_FUNCS(unsetenv vsnprintf)

AM_LANGINFO_CODESET

lispdir='${datarootdir}/emacs/site-lisp'
AC_SUBST([lispdir])

AC_CONFIG_FILES([Makefile doc/Makefile src/Makefile contrib/Makefile])
AC_OUTPUT



================================================
FILE: COPYING
================================================
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.



================================================
FILE: FAQ
================================================
The FAQ is hosted on the ratpoison wiki:

http://ratpoison.wxcvbn.org/cgi-bin/wiki.pl/FAQ



================================================
FILE: INSTALL
================================================
Basic Installation
==================

   These are generic installation instructions.

   The `configure' shell script attempts to guess correct values for
various system-dependent variables used during compilation.  It uses
those values to create a `Makefile' in each directory of the package.
It may also create one or more `.h' files containing system-dependent
definitions.  Finally, it creates a shell script `config.status' that
you can run in the future to recreate the current configuration, a file
`config.cache' that saves the results of its tests to speed up
reconfiguring, and a file `config.log' containing compiler output
(useful mainly for debugging `configure').

   If you need to do unusual things to compile the package, please try
to figure out how `configure' could check whether to do them, and mail
diffs or instructions to the address given in the `README' so they can
be considered for the next release.  If at some point `config.cache'
contains results you don't want to keep, you may remove or edit it.

   The file `configure.in' is used to create `configure' by a program
called `autoconf'.  You only need `configure.in' if you want to change
it or regenerate `configure' using a newer version of `autoconf'.

The simplest way to compile this package is:

  1. `cd' to the directory containing the package's source code and type
     `./configure' to configure the package for your system.  If you're
     using `csh' on an old version of System V, you might need to type
     `sh ./configure' instead to prevent `csh' from trying to execute
     `configure' itself.

     Running `configure' takes awhile.  While running, it prints some
     messages telling which features it is checking for.

  2. Type `make' to compile the package.

  3. Optionally, type `make check' to run any self-tests that come with
     the package.

  4. Type `make install' to install the programs and any data files and
     documentation.

  5. You can remove the program binaries and object files from the
     source code directory by typing `make clean'.  To also remove the
     files that `configure' created (so you can compile the package for
     a different kind of computer), type `make distclean'.  There is
     also a `make maintainer-clean' target, but that is intended mainly
     for the package's developers.  If you use it, you may have to get
     all sorts of other programs in order to regenerate files that came
     with the distribution.

Compilers and Options
=====================

   Some systems require unusual options for compilation or linking that
the `configure' script does not know about.  You can give `configure'
initial values for variables by setting them in the environment.  Using
a Bourne-compatible shell, you can do that on the command line like
this:
     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure

Or on systems that have the `env' program, you can do it like this:
     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure

Compiling For Multiple Architectures
====================================

   You can compile the package for more than one kind of computer at the
same time, by placing the object files for each architecture in their
own directory.  To do this, you must use a version of `make' that
supports the `VPATH' variable, such as GNU `make'.  `cd' to the
directory where you want the object files and executables to go and run
the `configure' script.  `configure' automatically checks for the
source code in the directory that `configure' is in and in `..'.

   If you have to use a `make' that does not supports the `VPATH'
variable, you have to compile the package for one architecture at a time
in the source code directory.  After you have installed the package for
one architecture, use `make distclean' before reconfiguring for another
architecture.

Installation Names
==================

   By default, `make install' will install the package's files in
`/usr/local/bin', `/usr/local/man', etc.  You can specify an
installation prefix other than `/usr/local' by giving `configure' the
option `--prefix=PATH'.

   You can specify separate installation prefixes for
architecture-specific files and architecture-independent files.  If you
give `configure' the option `--exec-prefix=PATH', the package will use
PATH as the prefix for installing programs and libraries.
Documentation and other data files will still use the regular prefix.

   In addition, if you use an unusual directory layout you can give
options like `--bindir=PATH' to specify different values for particular
kinds of files.  Run `configure --help' for a list of the directories
you can set and what kinds of files go in them.

   If the package supports it, you can cause programs to be installed
with an extra prefix or suffix on their names by giving `configure' the
option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.

Optional Features
=================

   Some packages pay attention to `--enable-FEATURE' options to
`configure', where FEATURE indicates an optional part of the package.
They may also pay attention to `--with-PACKAGE' options, where PACKAGE
is something like `gnu-as' or `x' (for the X Window System).  The
`README' should mention any `--enable-' and `--with-' options that the
package recognizes.

   For packages that use the X Window System, `configure' can usually
find the X include and library files automatically, but if it doesn't,
you can use the `configure' options `--x-includes=DIR' and
`--x-libraries=DIR' to specify their locations.

Specifying the System Type
==========================

   There may be some features `configure' can not figure out
automatically, but needs to determine by the type of host the package
will run on.  Usually `configure' can figure that out, but if it prints
a message saying it can not guess the host type, give it the
`--host=TYPE' option.  TYPE can either be a short name for the system
type, such as `sun4', or a canonical name with three fields:
     CPU-COMPANY-SYSTEM

See the file `config.sub' for the possible values of each field.  If
`config.sub' isn't included in this package, then this package doesn't
need to know the host type.

   If you are building compiler tools for cross-compiling, you can also
use the `--target=TYPE' option to select the type of system they will
produce code for and the `--build=TYPE' option to select the type of
system on which you are compiling the package.

Sharing Defaults
================

   If you want to set default values for `configure' scripts to share,
you can create a site shell script called `config.site' that gives
default values for variables like `CC', `cache_file', and `prefix'.
`configure' looks for `PREFIX/share/config.site' if it exists, then
`PREFIX/etc/config.site' if it exists.  Or, you can set the
`CONFIG_SITE' environment variable to the location of the site script.
A warning: not all `configure' scripts look for a site script.

Operation Controls
==================

   `configure' recognizes the following options to control how it
operates.

`--cache-file=FILE'
     Use and save the results of the tests in FILE instead of
     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
     debugging `configure'.

`--help'
     Print a summary of the options to `configure', and exit.

`--quiet'
`--silent'
`-q'
     Do not print messages saying which checks are being made.  To
     suppress all normal output, redirect it to `/dev/null' (any error
     messages will still be shown).

`--srcdir=DIR'
     Look for the package's source code in directory DIR.  Usually
     `configure' can determine that directory automatically.

`--version'
     Print the version of Autoconf used to generate the `configure'
     script, and exit.

`configure' also accepts some other, not widely useful, options.



================================================
FILE: Makefile.am
================================================
## Process this file with automake to produce Makefile.in
## Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
##
## This file is part of ratpoison.
##
## ratpoison is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## ratpoison is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

ACLOCAL_AMFLAGS = -I m4 --install

CLEANFILES		= *~ gmon.out
MAINTAINERCLEANFILES	= Makefile.in aclocal.m4 configure src/config.h.in \
			build-aux/depcomp build-aux/install-sh  \
			build-aux/missing build-aux/texinfo.tex

SUBDIRS			= src doc contrib

doc_DATA		= AUTHORS COPYING NEWS README

EXTRA_DIST		= $(doc_DATA)



================================================
FILE: NEWS
================================================
ratpoison NEWS --- history of user-visible changes.  -*- outline -*-

Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts
Copyright (C) 2013, 2014, 2017 Jérémie Courrèges-Anglas

Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.

* Changes since 1.4.9

** Feature/misc changes

*** manpage fixes

*** fix how find_frame_left, find_frame_right check for overlap

*** always show the frame indicator when switching to a different screen

*** fix bogus libhistory usage

*** fix for tmpwm and multiple screens

*** new 'onlyborder' variable
To print borders only when >=2 frames are on screen.

*** %42s-style format strings now account for UTF-8 characters

** Packaging changes

*** the debian/ subdirectory was removed (outdated)

*** a basic regress test has been added

* Changes since 1.4.8

** Incompatible changes

*** command `compat' and the various def* compat commands were removed

*** `msgwait', `rudeness', `startupmessage', `warp' are now variables
The msgwait, rudeness, startup_message and warp commands will stay
around for a few releases.  Upgrade your config file now!

** Feature/misc changes

*** XRandR support
ratpoison now uses XRandR to detect screens additions/removals at
runtime.  The Xinerama support has been removed.

*** the focus* commands can be used to navigate across screens

*** window completion match by substring, case-insensitive

*** new variable `framemsgwait'
Timeout (in seconds) for the `Current frame' message window.
If set to -1, no message is shown.

*** better `select' error handling

*** the command `set' with no argument dumps a list of all variables/values

*** unknown commands are now logged as warnings to stdout too
Should help debugging a config file.

*** various cleanups and minor bugfixes

** Packaging changes

*** ratpoison now depends on libXrandr instead of libXinerama

*** ratpoison doesn't link against libhistory by default any more
Use ./configure --enable-history to force the use of said library.

*** no ChangeLog file
Please use the git repository instead.  Savannah offers a web interface.

*** no more timestamps in compiled code
Should help reproducible builds.

* Changes since 1.4.7
This is mostly a bugfix release.

** fix cmd_sfdump with multiple screens
Broken since last release, from Joshua Leners.

** respect --enable-history=no
From Jeroen Roovers (jer@gentoo).

** fix for sloppy.c
The ugly sloppy.c had "a bug".  It may be fixed now.

** README improvements
From Jeff Abrahamson.

* Changes since 1.4.6
** More fixes and code cleanup.

** UTF-8 editing support in the input bar

** get rid of "XGetWMName failed" spam on stderr
Introduced in the previous release, sorry!

** groups can now be renumbered (`gnumber')

** contrib/rpdate.sh, fancy calendar shell script to use instead of `time'

** fix `meta', which was sending garbage and made firefox unusable

** handle errors about missing config files
- ratpoison -f missing-config-file -> error
- unreadable ~/.ratpoisonrc file -> warning

** respect --sysconfdir for the global ratpoisonrc file
Rather than a hardcoded /etc/ratpoisonrc location.

** rpws gains a new `current' command (prints the current workspace)

** new manpage, mdoc(7) formatted

** X socket closed before spawning processes
Let's save those precious file descriptors.

** DWIM windows/groups names matching
Window and group names are first looked up for exact match; in last
resort a fuzzy match is attempted.

** try to cope with unset/empty HOME env. variable

** ratpoison.el is now installed at the proper location
ie. in $prefix/share/emacs/site-lisp/

** ratpoison now restricts permissions on your history file

* Changes since 1.4.5
** *Lots* of reliability fixes in ratpoison itself
Please check out the ChangeLog for more details.

** Build process cleanup
e.g. detection of getline() was fixed, build is ok with old gcc's (2.95)

** ratpoison -c now reports errors ($? != 0)

** UTF-8 text is now printed correctly
Both with and without Xft support.

** contrib/ cleanup
Scripts should be more portable, ruby bindings work with newer ruby versions.

** New newwindow and titlechanged hooks

** Functionality was added to rpws
It can now move windows to other workspaces; workspaces can be dumped and
restored.

* Changes since 1.4.4
** bug fixes to history and xft

* Changes since 1.4.3
** add commands ratinfo, ratrelinfo, banishrel

** add history to input bar when libhistory is not used

** add settings historysize and historycompaction

** new window formatters %p, %M
prints the pid of the window and whether its a maxsize window.

** new commands grename, gother

** new bindings C-t N and C-t P
bound to nextscreen/prevscreen

** new settings, bwcolor and fwcolor
For setting the border color of focused and unfocused windows.

** netwm dialog type windows supported
These windows are treated as transients. Some Firefox popup windows
are tagged as dialog windows and should now work with ratpoison as
expected.

** new format character %M
This expands to Maxsize if the window is a maxsize window, nothing if not.

** ratpoison can use xft
If xft is found on your system ratpoison will use it unless explicitely
told not to using --without-xft.

* Changes since 1.4.2
** key event handling
top level key bindings are grabbed "asynchronously" instead of
"synchronously." This should eliminate the freezes some people have
experienced in previous versions.

* Changes since 1.4.1
Just bug fixes.

* Changes since 1.4.0
** set padding affects bar location
On OSX the bar and top of each window is hidden by the menu bar. set
padding corrects the window problem but not the bar problem. So this
change fixes that.

** new set variable framefmt
See docs for info.

** new commands swap, exchangeleft, exchangeright, exchangeup, exchangedown
See docs for info

** new commands execa and execf
See docs for info.

** default font change
It is now "-*-fixed-bold-r-normal-*-15-*-*-*-c-*-*-*" which hopefully
fixes some i18n issues.

** new command set topkmap
See info manual.

** build date in ratpoison -v

** new command sfrestore
restores frame configurations for multiple screens.

** support for i18n fonts

* Changes since 1.4.0-beta4
** new parameters in frame dumps
:screenh and :screenw specify the size of the screen the frame was
on. using these values (when present) ratpoison will scale the frames
to fit the new screen size (if different).

** New window format characters
See the info file for details.

** info takes optional argument and new infofmt setting
the info command takes an optional formatting argument. if no argument
is supplied a default fmt is used. To change the default use 'set
infofmt'. See the manual for details.

** shell commands do not insert trailing space
Until now all completions had a trailing space. Now shell command
completion doesn't to make it easier to tab complete directories. The
previous behavior one had to delete the space then type / and
continue.

** aspect ratio hint honoured
windows with aspect ratio hints are treated as transients and are
given the same default gravity as maxsize windows.

** new hook deletewindow
When a window is deleted this hook is called.

** _net_wm_pid property supported
ratpoison will put windows that have the _net_wm_pid property into the
frame & group that was current when the windows' client was
launched. for example:

 ratpoison -c split -c gnew -c "exec firefox" -c focus -c gnext

will Do The Right Thing.

** set warp change
the mouse position relative to the window is now used, instead of
relative to the root window.

** new compat command
the old def* aliases are depricated and have been moved to this
command. Execute it to restore these bindings.

** new command redo

** new editor bindings C-m and C-h

* Changes since 1.4.0-beta2
** meta takes a key argument
This can be used to stuff keys.

* Changes since 1.4.0-beta1
** RATPOISON environment variable
RATPOISON is set to the location of the ratpoison binary. This is
useful for scripts.

* Changes since 1.3.0
** command arguments can be wrapped in double quotes.
To include a space in a command argument, wrap the argument with ".

** New command undefinekey
not passing a 3rd argument to definekey and bind no longer unbind the
key. You must use undefinekey and unbind now.

** ratpoison -c prints errors to stderr
You can now capture errors and output seperately depending on whether
its printed to stderr or stdout.

** the mouse warp feature is now turned off by default
to turn it back on, run 'warp on'.

** version now displays the date and time

** new command, sselect
sselect lets you jump to an X11 screen by number.

** configure script warns about missing history lib
Rather than error out, now, ratpoison will just be built without history.

** new commands ratwarp, ratrelwarp, and ratclick

** more new commands
inext, iprev, iother, cnext, cprev, cother, prompt, dedicate,
describekey, focusprev, sdump, sfdump.

** yet two more new commands: putsel, getsel
putsel puts the specified text into the X11 selection so other clients
can yank it. getsel returns the current selection.

* Changes since 1.3.0-rc2-beta2
** new format option %f
This options displays the frame number the window is in or a space if
it is not in a window.

** Super modifier changed from S to s. S is now the shift modifier

** window list style is columnar by default

* Changes since 1.3.0-rc2-beta1
** New command 'set'
set replaces the def* commands. For example 'defwinliststyle column'
is now 'set winliststyle column'.

The old def* commands now alias to their 'set' version.

* Changes since 1.3.0-rc1
** Top level keymap
The keymap named 'top' is now a top level keymap. No prefix key need
be pressed to access its bindings. In fact, the prefix key is now a
binding in the 'top' keymap.

** hsplit and vsplit switched
To be compatible with emacs these command names have been
switched. The bindings are the same but custom scripts and aliases
will have to make the switch.

** new command defframesels
Allow you to customize the keys used to select frames with fselect.

** Xinerama support
Each xinerama screen is handled as X11 screens normally are. The only
different is that each xinerama screen can select from all the
managed windows.

** focuslast finds the last focused frame among all screens

** fselect selects from frames in all screens

** new command-line option --file
Used to specify an alternate configuration file.

* Changes since 1.3.0-beta3
** new configure option --disable-history

** new commands readkey, newkmap, delkmap, definekey
These commands operate on the new feature: keymaps. They allow you to
have nested keymaps.

* Changes since 1.3.0-beta2
** new command gdelete
Delete a group.

** contrib/allwindows.sh script
A script that lists all groups and the windows in each group.

* Changes since 1.2.2
** Workspace script
rpws is an installed script that adds workspaces to ratpoison. Look at
contrib/rpws for instructions on how to use it.

** new commands addhook and remhook
There are now hooks for various operations.

** Completions
You can now type Tab and get completions on window names, group names,
and colon commands.

** Line editing capabilities
You can now go forward a word, backward a char, delete a word, etc.

** New commands gnewbg, gselect, groups, gmove, and gmerge
These commands allow further manipulation of window groups.

** shell commands return status
If a command the user executed (with the exec command) returns with a
non-zero exit status, the command and exit status are reported in a
message.

** new commands gnew, gnext, gprev
Window are now part of groups. There can be more than one group.

* Changes since 1.2.0-beta4
** new commands unmanage and clrunmanaged
Instead of editing conf.h you can use these commands to dynamically
add (and clear) the unmanaged window list.

* Changes since 1.2.0-beta3
** new command line argumen --screen
Now you can specify the screen you want to manage. By default
ratpoison manages all screens on the display.

** new command line argument --display
Now you can specify the display to connect to.

* Changes since 1.2.0-beta2

* Changes since 1.1.1
** new comand 'defwinliststyle'
when turned on, the window list is displayed in a column, not a row.

** new command 'verbexec'
prints a message when executing a shell command

** new commands 'fdump' and 'frestore'
These commands are for saving and restoring frame sets.

** key presses
All actions now occur after the user has released the key.

** keybinding changes
fselect is bound to C-t C-f and C-t f, curframe is now bound to C-t F,
and resize is bound to C-t C-r and C-t r.

** new command fselect
select a frame by its number.

** new command 'tmpwm'
temporarily run a different window manager, then come back to
ratpoison once it has terminated.

** error and debug reporting
The format has been changed to the more standard format used by C
compilers.

** New commands 'resize', 'shrink'
resize resizes a frame and shrink shrinks a frame to the size of the
window in it.

** Shell command exit status
When a shell command fails to execute then a message is reported in
ratpoison: "Command not found."

** New command 'warp'
Toggles rat warping. By default ratpoison saves the position of the
rat when leaving a window and when the user returns to the window the
rat's position is restored. This can be counter-intuitive, so now you
can toggle it.

** split, vsplit, hsplit
These commands now take a single argument. The argument can be a ratio
which divides the frame into two frames sized based on this ratio, or
it can be a number representing the number of pixels the existing
frame will occupy.

* Changes since 1.1.0
** new commands "nextscreen" and "prevscreen"

* Changes since 1.0.0
** defbarloc changed to defbargravity

** defbarloc
This command take a gravity argument just like the wingravity
commands.

** new command defbarborder
This command allows you to customize the border width of ratpoison's
windows. These windows are the input window, the bar window, and the
current frame indication window.

** "number" command takes additional optional argument
The second argument is used to specify a window other than the
current.

** new command "alias"
An alias gives a name to a command sequence. For instance, you could
alias 'emacs' to 'exec emacs'. Then you could simply type 'C-t :emacs'
and ratpoison would boot emacs.

** new command "license"
Display ratpoison's license. This is also bound to C-t V and C-t C-V.

** input history
All input you type into ratpoison is stored as a history entry. Use
C-p and C-n to cycle through it.

** new command "defbarpadding"
This command specifies how much ratpoison pads the bar window. See the
documentation for usage.

** new command "link"
Call the command that a keybinding is bound to. for instance, 'link
C-t' would call the command 'other'.

** new command "focuslast"
Switch between the current frame and the last focused frame. It is
bound to C-t M-Tab.

** Raise requests don't change frame focus if rudeness doesn't allow it
If a window in another frame requests to be raised, a message pops up
just like everywhere else. The old behavior was to jump focus to the
windows frame regardless of the rudeness.

** New windows formatting option %l
Prints a last access number. The higher the number, the more recently
the window was accessed.

** Remove command line options --kill and --restart
Use -c quit and -c restart instead.

** New command restart
Restart ratpoison.

** New command lastmsg
Display the last message.

** New command info
display information about the current window.

** New command unsetenv
Remove an environment variable from...well...the environment.

** New command chdir
Change the current directory.

** Multiple commands passed to ratpoison via the command-line are now processed
A stream of commands like, `ratpoison -c next -c prev -c next' are
processed in order.

** clock command renamed to time
This was to improve screen compatibility.

** New command setenv
Use this to set environment variables for all programs run from
ratpoison thereafter.

** Command defbartimeout renamed to msgwait
This was done to better mirror screen commands.

** Command generate renamed to meta
This was done to better mirror screen commands.

** Comand maximize renamed to redisplay
This was done to better mirror screen commands. It is no longer bound
to C-t m it is now bound to C-t l.

** Cursor in the input window
There is now a cheap cursor to help you remember where you are.

** conf.h compile-time customizations moved
They are now accessible through the def* suite of commands.

** Window alignment
Windows can now be aligned so they stick to the top-left corner of the
screen, the center of the screen, the bottom-right, etc. Use the `pos'
command. There is a customizable default setting for each of the three
'kinds' of windows: `defwinpos' for normal windows, `deftranspos' for
transient windows, and `defmaxsizepos' for normal windows with
maximimum size hints.

** Window format string
The format of the list of windows dumped by the `windows' command is
now customizable with `defwinfmt'.

** Different Window naming schemes
Windows now have 3 resources that can be used as their default name:
the WMNAME hint which generally contains transient information such as
what file is currently open, the res_name from the WMCLASS hint, or
the res_class the WMCLASS hint. This affects commands like `select'
which search for a window by name.

* Changes since 0.1.1

** new conf.h customization MAXSIZE_WINDOWS_ARE_TRANSIENTS
determines whether windows with maxsize hints are treated like
transient windows.

** The frame indicator
The frame indicator never sticks and only appears when there is more
than one frame (i.e. when there are splits).

** Transient window handling has changed
Transient windows now map ontop of the current window.

** new command 'rudeness'
This command allows you to fine tune what windows rp will map
when. For instance you can ask rp not to map new windows. Instead it
will notify you with a message: "New window #1 (emacs)".

** user abort key sequence
When typing input, hit C-g (customizable in conf.h) to abort the
input.

** new key syntax
keys are now specified with C-, M-, A-, H-, S- which stand for the
control, meta, alt, hyper, and super modifiers. ^ does not denote
control. Before, control t looked like ^t now it looks like C-t.

** new command 'help'
help brings up a key binding listing. it is bound to C-t ?.

** new command 'quit'
This command quits ratpoison

** windows not residing in a frame are hidden
This gets rid of annoying flickers around the edges of active windows
as windows in the back update.

** rat cursor changes

When you hit the prefix key the rat cursor changes to a square to tell
you what it is waiting for another key. This feature can be removed in
conf.h.

** Split windows

Well, the day is finally here. You can now split windows in
ratpoison. Hit C-t s to split horizontally and C-t S to split
vertically. Have fun!

** new command-line option --command

You can now send ratpoison commands (colon-commands) to ratpoison via
the command line. for example to tell ratpoison to go to the next
window type this:

$ ratpoison --command next

** window borders are configurable
WINDOW_BORDER_WIDTH has been added to conf.h. This constant determines
the border width for all windows.

** Rodent handling
A new command, :banish, which will move the rat pointer out of harms
way, has been added.  It is bound to 'C-t b' by default.  No more
slapping your rat out of the way, as fun as that was.

* Changes since 0.1.0

** Window list changes
A '+' is now drawn between the window number and the window name for
the last accessed window.

** AltGr (XK_Mode_switch) support

ratpoison now handles AltGr on all its input.

* Changes Since 0.0.5
** C-t e removed

Since you can custo your own keystrokes, there's not much sense
cluttering things with a binding to launch emacs.

** XErrorEvents don't bring down ratpoison

A friendly message pops up displaying the error message. This does
mean that there is a problem with ratpoison and it should be
investigated and reported. But at least your entire session doesn't go
down.

** Sorted window list

The window list is now sorted by number.

** Resizing input window

The size of the input window can be customized in conf.h by setting
INPUT_WINDOW_SIZE. It also dynamically resizes to accommodate the user
input.

** Pointer location

The pointer location is saved on a per window basis. When ratpoison
switches to a window it restores the pointer location to its location
the last time that window had focus.

** Auto quit ratpoison

When the auto close feature is enabled, ratpoison will exit when the
last managed window is closed. This feature can be turned on by
uncommenting the line:

/* #define AUTO_CLOSE */

in conf.h

** Improved shell command
The 'exec' command now calls execl ("/bin/sh", "sh", "-c", cmd, 0)
where cmd is your shell command.  In short, you can now make shell
command calls with parameters.

The default keybinding has been changed from C-: to C-! for the 'exec'
command.

** Command line
An emulation of screen's colon command has been implemented.  This
allows you to make wm commands by name.  The current command set
includes: abort, next, prev, exec, select, colon, kill, delete, other,
windows, title, clock, maximize, newwm, and version.  To bring up a
command line prompt, type C-:.  See the info or man page for details
on the command set and its usage.

** Keysym reading updates
keystrokes are now handled far better. Shifted keystrokes work. More
uniform key event processing.

You can no longer "over modify" keys.  Previously, if C-tn was bound
to 'next', you could type C-tC-n and get the same result.  No longer.
You need to explicity map both C-tn and C-tC-n if you want both to
work.

** XSizeHints honoured
Windows may not maximize fully now since they use XSizeHints to figure
out how big the window can be.

** Bold color removed
ratpoison now uses only foreground and background colors.  They
default to black and white, respectively.  To represent the current
window in the bar, the current window's text is reversed.

** Colormap support
ratpoison now maintains colormaps

** New keystrokes
*** C-t space and C-t enter
Do the same as C-tn (next window)
*** C-tA
Shows a the time in the display bar
*** C-tv
Shows the version of ratpoison

** Messages in the window bar
ratpoison now outputs user error messages.

** Stability
All fixed length buffer sizes in window names that resulted in
curious segfaults have been fixed.

** Themes support
There is still no theme support, despite what you might have heard.


* Changes Singe 0.0.4
** added --kill and --restart
These command line options allow the restarting and killing of a
running ratpoison process.

** Mouse jumps to the bottom of the screen on keypresses
This is pretty annoying if you're using anything other than keyboard
apps. It is disabled by default.


* Changes Since 0.0.3
** Added --enable-debug
This turns on debugging messages

** Added --version and --help command line options


* Changes Since 0.0.2
** Installation
*** Added automake and autoconf
To build and install ratpoison, you must now do this:

aclocal
automake -a -c
autoconf
./configure
make
make install

** Features
*** Added jump to window by name Hit C-t C-' and a box will pop up
asking you for the name of the window to jump to.

*** Added rename-window
hit C-t C-a and a box will pop up asking you to rename the current
window. Once it has been renamed, it will stay renamed.

** Bugs and Bug fixes



================================================
FILE: TODO
================================================
-*- outline -*-

* Pasting into input buffer
Fix it.




================================================
FILE: .dir-locals.el
================================================
((c-mode . ((indent-tabs-mode . nil)
	    (c-file-style . "gnu"))))



================================================
FILE: contrib/allwindows.sh
================================================
#!/bin/sh
# Copyright (C) 2003 Rupert Levene
# Author: Rupert Levene <r.levene@lancaster.ac.uk>

# List all groups and the windows in each group.

# we want to cope with spaces in group names
IFS='
'

#initialize our list
list=''

# Allow external scripts to tell it where ratpoison is
if [ -z "$RATPOISON" ]; then
    RATPOISON=ratpoison
fi

GROUPLIST=$($RATPOISON -c groups)
SED_GET_NUM='s/^\([0-9]*\).*/\1/'

FIRSTGROUPNUM=$(echo "$GROUPLIST"|head -n 1|sed -e "$SED_GET_NUM")
LASTGROUP=$(echo "$GROUPLIST"|tail -n 1)
CURRENTGROUPNUM=$(echo "$GROUPLIST"|grep '^[0-9]*\*'|sed -e "$SED_GET_NUM")

$RATPOISON -c "gselect $FIRSTGROUPNUM"

for i in $GROUPLIST; do
    list=$(printf '%s%s\n%s' "$list" "$i" "$($RATPOISON -c windows|sed -e 's/^/ /')");
    if [ "$i" != "$LASTGROUP" ]; then
        list="${list}
"
    fi
    $RATPOISON -c gnext
done;

$RATPOISON -c "echo $list"
$RATPOISON -c "gselect $CURRENTGROUPNUM"



================================================
FILE: contrib/clickframe.pl
================================================
#!/usr/bin/env perl
#
# Copyright (C) 2003,2004 Shawn Betts
#
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
# notice and this notice are preserved.
#
# clickframe.pl is a utility to switch frames by clicking the
# mouse. You must apply the patch below to xbindkeys for this script
# to work. And add an entry like this to your .xbindkeysrc file:
#
# # bind C-mouse1 to ratpoison click focus hack
# "perl /home/sabetts/src/ratpoison/contrib/clickframe.pl &"
# control + b:1
#
# Requires xbindkeys-1.6.4 with the patch at the end of this file
# applied. This file can be fed directly to patch.

# Make sure the env vars are there
$ENV{XBINDKEYS_BUTTONLOC} || die '$XBINDKEYS_BUTTONLOC not bound';

# Parse the required environment variables
$ratpoison_bin = $ENV{RATPOISON} || 'ratpoison';
($x_loc,$y_loc) = split(/,/, $ENV{XBINDKEYS_BUTTONLOC});

# Rip the frameset from ratpoison
$frameset = `$ratpoison_bin -c fdump`;
@framelist = split(/,/,$frameset);

# Check each frame to see if the mouse was clicked in that frame.
# FIXME: it goes through all the frames even if it found one.
foreach $frame (@framelist) {
    ($num,$left,$top,$width,$height,$win,$access) = split(/ /,$frame);
    if ($x_loc > $left && $x_loc < $left + $width && $y_loc > $top && $y_loc < $top + $height) {
        # Tell ratpoison to switch to the frame
        print "User clicked in frame $num\n";
        system ("$ratpoison_bin -c \"fselect $num\"");
    }
}

__END__

--- xbindkeys.c~        2003-04-06 08:43:27.000000000 -0700
+++ xbindkeys.c 2003-09-24 11:46:20.000000000 -0700
@@ -143,7 +143,15 @@



+void
+add_button_env (int x, int y)
+{
+  char *env;

+  env = malloc (256 * sizeof (char));
+  snprintf (env, 255, "XBINDKEYS_BUTTONLOC=%d,%d", x, y);
+  putenv (env);
+}


 static void
@@ -240,6 +248,8 @@
                               | Button1Mask | Button2Mask | Button3Mask
                               | Button4Mask | Button5Mask);

+         add_button_env (e.xbutton.x, e.xbutton.y);
+
          for (i = 0; i < nb_keys; i++)
            {
              if (keys[i].type == BUTTON && keys[i].event_type == PRESS)
@@ -266,6 +276,8 @@
                               | Button1Mask | Button2Mask | Button3Mask
                               | Button4Mask | Button5Mask);

+         add_button_env (e.xbutton.x, e.xbutton.y);
+
          for (i = 0; i < nb_keys; i++)
            {
              if (keys[i].type == BUTTON && keys[i].event_type == RELEASE)



================================================
FILE: contrib/expose.pl
================================================
#!/usr/bin/env perl
# Maintainer: Trent Buck <[EMAIL PROTECTED]>
# License: Public Domain

# Changelog:
#  2003-11-16 cantsin	rpshowall.sh
#  2003-11-19 various	Misc. fixes to rpshowall
#  2003-11-20 twb	expose.pl
#  2003-11-20 cantsin	minor changes
#  2003-11-22 twb	new algorithm, broke script
#  2004-05-21 bkhl	posted on wiki
#  2004-06-22 twb	full rewrite, changelog started
#  2004-06-24 twb	release candidate
#  2004-07-07 twb	toggle logic for fselect (line 43)
#  2005-07-05 ivan	updated for the new fdump format (works with 1.4.0-beta4)

# Description:
#  Duplicates OS-X 10.3's Expose' functionality for ratpoison.
#  You should apply the TWBPatch or reverse the logic at line 43.

#-- tweaking -------------------------------------------------------------------

require "assert.pl";  #used for validation.
use strict;
my $N_LIMIT = 2;
my $LIMIT = 0.01; #smaller number --> slower, but more accurate
my $RATPOISON = $ENV{RATPOISON} || 'ratpoison';

#-- main -----------------------------------------------------------------------

#&th_ratio (1400, 1050, 23);
#&th_split (\&split, 5, (0, 0, 1400, 1050));

# my $id = &xid2num(8388638);
# print "'$id'\n";
# exit 0;

my @xids = &rp('windows %i'); chomp @xids;
my $n = @xids; #@ in $ context evals to length of @.
my $frames_old = &rp('fdump'); chomp $frames_old;
my @r; # Sub-optimal way of grabbing screen x,y,w,h.

#fixed to use sdump
($_, $r[0], $r[1], $r[2], $r[3]) = split(/ /,&rp ('sdump'));

my $ret = join(", ", &rp_split(\@xids, \&split, $n, \@r));

&rp("frestore $ret");

$ret = &rpi('fselect');

&rp('only');

#-- subroutines ----------------------------------------------------------------

#-- rp-specific --------------------------------------------

sub rp  { return `$RATPOISON    -c "@_"`; }
sub rpi { return `$RATPOISON -i -c "@_"`; }

sub rpb {
    my @accum = ();
    for (@_)
    {
        push @accum, "-c \"$_\"";
    }
    return `$RATPOISON @accum`;
}

sub rp_split
{
    # Prints partitions in :fdump format.
    my ($xids, $alg, $n, $r) = @_;
    my @ret = ();
    my $num = 0;
    my $i;

    foreach $i (&$alg($n, @$r))
    {
        my ($x, $y, $w, $h) = @$i;
        my $xid = pop(@$xids);
        push @ret, "(frame :number $num :x $x :y $y :width $w :height $h :window $xid)";
        $num++;
    }
    return @ret;
}


# sub frame2xid {
#     my ($fnum) = @_;
#     my ($frame, $num, $xid);
#     foreach $frame ( split(/,/, &rp('sfdump')) )
#     {
# 	($num, $_, $_, $_, $_, $xid) = split(/ /, $frame);
# 	if ($num eq $fnum)
# 	{
# 	    chomp $xid;
# 	    return $xid;
# 	}
#     }
#     return -1;			# canthappen
# }

# sub xid2num {
#     my ($xid) = @_;
#     my @windows = &rp('windows %i %n');
#     my ($window, $id, $num);
#     foreach $window ( @windows )
#     {
# 	($id, $num) = split(/ /, $window);
# 	if ($id eq $xid)
# 	{
# 	    chomp $num;
# 	    return $num;
# 	}
#     }
#     return -1;			# canthappen
# }


#-- generic ------------------------------------------------


sub isint { #from http://google.com/groups?selm=BECK.95Oct20135611%40visi5.qtp.ufl.edu
    my $x = shift;
    return 0 if ($x eq "");
    my $sign ='^\s* [-+]? \s*';
    my $int ='\d+ \s* $ ';
    return ($x =~ /$sign $int/x) ? 1 : 0;
}


sub isnum { #from http://google.com/groups?selm=90ra0g%24u0m%241%40nnrp1.deja.com
    my $x = shift;
    return ($x eq $x+0) ? 1:0;
}

sub ratio {
    my ($t, $n) = @_;
    my $ret = 1;
    my $i;
    &assert(&isnum($t) and &isint($n) and $n >= 0);

    for $i ( 2 .. $n )
    {
        if ( &isint($n / $i) # $j must also be an integer.
             and abs(($i**2 / $n) - $t) < abs(($ret**2 / $n) - $t) )
        {
            $ret = $i;
        }
    }
    #Third return value is `error', used by split().
    return ( $ret, $n / $ret, abs(($ret**2 / $n) - $t));
}

sub hsplit ($@) {
    my ($n, $rx, $ry, $rw, $rh) = @_;
    my @ret = ();
    my $i;
    &assert(isint($n) and $n >= 0);
    &assert(isint($rx) and isint($ry) and isint($rw) and isint($rh));
    &assert($rx>=0 and $ry>=0 and $rw>0 and $rh>0);
    &assert($rw >= $n);

    # remove remainder from rw, add to the last rectangle.
    my $rem = $rw % $n;
    $rw -= $rem;
    &assert(0 == $rw % $n);

    for $i (1 .. $n)
    {
        push @ret, [ ($rx + ($i-1)*$rw/$n,
                      $ry,
                      $rw/$n + ($i==$n?$rem:0),
                      $rh) ];
    }
    return @ret;
}

sub vsplit ($@) {
    my ($n, $rx, $ry, $rw, $rh) = @_;
    my @ret = ();
    my $i;
    &assert(isint($n) and $n >= 0);
    &assert(isint($rx) and isint($ry) and isint($rw) and isint($rh));
    &assert($rx>=0 and $ry>=0 and $rw>0 and $rh>0);
    &assert($rh >= $n);

    # remove remainder from rh, add to the last rectangle.
    my $rem = $rh % $n;
    $rh -= $rem;
    &assert(0 == $rh % $n);

    for $i (1 .. $n)
    {
        push @ret, [ ($rx,
                      $ry + ($i-1)*$rh/$n,
                      $rw,
                      $rh/$n + ($i==$n?$rem:0)) ];
    }
    return @ret;
}

sub boxsplit ($@) {
    my ($n, $rx, $ry, $rw, $rh) = @_;
    my @ret = ();
    my ($rows, $cols) = &ratio($rw/$rh, $n);
    my $i;
    &assert(isint($n) and $n >= 0);
    &assert(isint($rx) and isint($ry) and isint($rw) and isint($rh));
    &assert($rx>=0 and $ry>=0 and $rw>0 and $rh>0);
    &assert(($rh * $rw) >= $n);

    foreach $i (&vsplit($rows, ($rx, $ry, $rw, $rh)))
    {
        @ret = (@ret, &hsplit($cols, @$i));
    }
    return @ret;
}

sub split ($@) {
    my ($n, $rx, $ry, $rw, $rh) = @_;
    my ($rows, $cols, $prox) = &ratio($rw/$rh, $n);

    # if base case, palm off to boxsplit()
    if ($n < $N_LIMIT or $prox < $LIMIT)
    {
        return &boxsplit($n, $rx, $ry, $rw, $rh);
    }
    else
    {
        my @ret = ();
        my $nA = int($n/2); #fixme: int() is bad.  Use POSIX::floor?
        my $x = $nA / ($n - $nA);
        my $i;
        &assert(isint($n) and $n >= 0);
        &assert(isint($rx) and isint($ry) and isint($rw) and isint($rh));
        &assert($rx>=0 and $ry>=0 and $rw>0 and $rh>0);
        &assert(($rh * $rw) >= $n);

        if ($rw > $rh) # Divide the larger dimension
        {
            my $k = int($rw * $x / (1 + $x)); #fixme: bad int().
            @ret = (@ret, &split($nA,      ($rx,    $ry, $k,     $rh)));
            @ret = (@ret, &split($n - $nA, ($rx+$k, $ry, $rw-$k, $rh)));
        }
        else
        {
            my $k = int($rh * $x / (1 + $x)); #fixme: bad int().
            @ret = (@ret, &split($nA,      ($rx, $ry,    $rw, $k    )));
            @ret = (@ret, &split($n - $nA, ($rx, $ry+$k, $rw, $rh-$k)));
        }
        return @ret;
    }
}

#-- test harnesses -------------------------------------------------------------

# Commented out to speed up compilation.

# sub th_ratio
# {
#     my ($num, $denom, $n) = @_;
#     my ($row, $col, $prox) = &ratio ($num / $denom, $n);
#     print "$n = $row * $col, proximity $prox\n";
# }

# sub th_split
# {   # Prints partitions as a SVG.  See inkscape.org for info.
#     my ($alg, $n, @r) = @_;
#     my $i;

#     print "<svg width=\"$r[2]\" height=\"$r[3]\">\n";
#     foreach $i (&$alg($n, @r))
#     {
#       my ($x, $y, $w, $h) = @$i;
#       print "<rect x=\"$x\"\ty=\"$y\"\twidth=\"$w\"\theight=\"$h\"",
#             " style=\"fill:white;stroke:black;\"/>\n";
#     }
#     print "</svg>\n";
# }




================================================
FILE: contrib/genrpbindings
================================================
#!/usr/bin/env perl
# genrpbindings -- generate ratpoison bindings for various languages
#
# Copyright (C) 2003, 2004 Ryan Yeske, Doug Kearns, Shawn Betts
#
# currently generates bindings for:
# * Perl        (Ratpoison.pm)       Ryan Yeske <rcyeske@sfu.ca>
# * Emacs Lisp  (ratpoison-cmd.el)   Ryan Yeske <rcyeske@sfu.ca>
# * Ruby        (ratpoison.rb)       Doug Kearns <djkea2@mugc.its.monash.edu.au>
# * Common Lisp (ratpoison.lisp)     Shawn Betts <sabetts@vcn.bc.ca>
# * Python      (ratpoison.py)       Mike O'Connor <stew@vireo.org>
# add more languages!
#
# Bindings are just very thin wrappers, no argument checking is done.
# All of the functions return a string.
#
# Example: ratpoison --command='echo hello world'
#
# #!perl
# use Ratpoison;
# Ratpoison::echo ("hello world")
#
# ;;; elisp
# (require 'ratpoison-cmd)
# (ratpoison-echo "hello world")
#
# #!ruby
# require "ratpoison"
# Ratpoison.echo ("hello world")
#
# ;;; Common Lisp
# (load "ratpoison.lisp")
# (ratpoison:rp-echo "hello world")
#
# #!python
# import ratpoison
# ratpoison.echo( "hello world" )

use warnings;

$\="\n";

# Feel free to hardcode this if you installed ratpoison in
# a non-standard path, but note that you can also use the RATPOISON
# environment variable
$RATPOISON = 'ratpoison';

# open source file
$ACTIONS_C="../src/actions.c";
open ACTIONS_C or die "Can't open $ACTIONS_C";

# open target files
$PERL_FILE="./Ratpoison.pm";
$ELISP_FILE="./ratpoison-cmd.el";
$RUBY_FILE="./ratpoison.rb";
$COMMONLISP_FILE="./ratpoison.lisp";
$PYTHON_FILE="./ratpoison.py";
open PERL, ">$PERL_FILE" or die "Can't create $PERL_FILE";
open ELISP, ">$ELISP_FILE" or die "Can't create $ELISP_FILE";
open RUBY, ">$RUBY_FILE" or die "Can't create $RUBY_FILE";
open COMMONLISP, ">$COMMONLISP_FILE" or die "Can't create $COMMONLISP_FILE";
open PYTHON, ">$PYTHON_FILE" or die "Can't create $PYTHON_FILE";

# PERL preamble
print PERL 'package Ratpoison;';
print PERL '$RATPOISON=$ENV{RATPOISON} ? $ENV{RATPOISON} : "',$RATPOISON,'";';
print PERL 'sub command { my $a = "@_"; $a =~ s/(\')/\'\\\\\'\'/g; return `$RATPOISON -c \'$a\'`; }';

# ELISP preamble
print ELISP <<PREAMBLE;
(defvar ratpoison-program (or (getenv "RATPOISON") "$RATPOISON"))

(defmacro defun-ratpoison (cmd)
  `(progn (defun ,(intern (concat "ratpoison-" (symbol-name cmd))) (&rest args)
          (apply 'ratpoison-cmd ,(symbol-name cmd) args))))

(defun ratpoison-cmd (cmd &rest args)
  (with-temp-buffer
    (call-process ratpoison-program nil (current-buffer) t
                  "-c" (format "%s %s"
                               cmd
                               (mapconcat (lambda (x)
                                            (if (stringp x)
                                                x
                                              (prin1-to-string x)))
                                          args " ")))
    (buffer-substring (point-min) (if (> (point-max) 1)
                                      (- (point-max) 1)
                                    (point-max)))))
PREAMBLE

# RUBY preamble
print RUBY  <<PREAMBLE;
module Ratpoison

  RATPOISON=ENV.fetch('RATPOISON', "$RATPOISON")

  def command(command, *args)
    return `#{RATPOISON} -c "#{command} #{args.join(' ')}"`
  end
  module_function :command
PREAMBLE

# Common Lisp preamble

print COMMONLISP <<PREAMBLE;
(require :asdf :asdf-utils)
(defpackage :ratpoison
  (:use :cl))

;; Needs the CLOCC PORT package
(asdf:operate 'asdf:load-op :port)

(in-package :ratpoison)

(defvar ratpoison-program
  (or (asdf-utils:getenv "RATPOISON")
      "$RATPOISON"))

(defmacro defun-ratpoison (cmd)
  (let ((sym (intern (concatenate 'string "RP-" (symbol-name cmd)))))
    `(progn (defun ,sym (&rest args)
              (apply 'ratpoison-cmd ,(string-downcase (symbol-name cmd)) args))
            (export ',sym))))

(defun ratpoison-cmd (cmd &rest args)
  (labels ((mapconcat (fn list sep)
                     (apply 'concatenate 'string
                            (loop for x on list
                                  collect (if (cdr x)
                                              (concatenate 'string (funcall fn (car x)) sep)
                                            (funcall fn (car x))))))
         (build-cmd (cmd args)
                    (mapconcat (lambda (x)
                                 (if (stringp x)
                                     x
                                   (prin1-to-string x)))
                               (nconc (list cmd) args) " ")))
    (let ((stream (port:pipe-input ratpoison-program
                                   "-c" (build-cmd cmd args))))
    (do ((line (read-line stream nil nil)
               (read-line stream nil nil))
         (accum nil (cons line accum)))
        ((null line) accum)))))
PREAMBLE

# python preamble

print PYTHON <<PREAMBLE;
import os
ratpoison = os.getenv('RATPOISON') or '$RATPOISON'
def rp_command( *args ):
    p = os.popen( ratpoison + ' -c ' + '"' + (' '.join(  args  ) ) + '"', 'r' )
    r = p.readlines();
    p.close();
    return r

PREAMBLE

# bindings
while (<ACTIONS_C>) {
    if (m!/\*\@begin !) {
        while (<ACTIONS_C>)
        {
            last if (m!/\*\@end !);
            if (/\s*add_command\s*\(\"([^\"]+)\",\s*[^\"]+,\s*([0-9]+),\s*[0-9]+,\s*([0-9]+)/) {
              my $name = $1;
              my $numargs = $2;
              my $optargs = $3;

              # Skip the arguments
              for (my $i=0; $i<$numargs; $i++) {
                <ACTIONS_C>;
              }

              $nbindings++;
              print PERL "sub $name { return command (\"$name\", \@_); }";
              print ELISP "(defun-ratpoison $name)";
              print COMMONLISP "(defun-ratpoison $name)";
              print RUBY "  def $name(*args)";
              print RUBY "    return command(\"$name\", args)";
              print RUBY "  end";
              print RUBY "  module_function :$name\n";
              print PYTHON "def rp_$name( *args ): return rp_command ( '$name ' +  ' '.join( args ) )";
            }
        }
    }
}
print "$nbindings bindings.";

# PERL postamble
# nothing

# ELISP postamble
print ELISP '(provide \'ratpoison-cmd)';

# RUBY postamble
print RUBY "end";

# COMMON-LISP postamble
# nothing

# PYTHON postamble
# nothing

close PERL;
print "Created $PERL_FILE";
close ELISP;
print "Created $ELISP_FILE";
close RUBY;
print "Created $RUBY_FILE";
close COMMONLISP;
print "Created $COMMONLISP_FILE";
close PYTHON;
print "Created $PYTHON_FILE";



================================================
FILE: contrib/Makefile.am
================================================
# Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
#
# This file is part of ratpoison.
#
# ratpoison is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# ratpoison is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

bin_SCRIPTS = rpws

pkgdata_DATA = allwindows.sh clickframe.pl genrpbindings ratdate.sh rpshowall.sh rpws sloppy.c split.sh unrat.c
lisp_DATA    = ratpoison.el
EXTRA_DIST   = allwindows.sh clickframe.pl genrpbindings ratdate.sh ratpoison.el rpshowall.sh rpws sloppy.c split.sh unrat.c
MAINTAINERCLEANFILES = Makefile.in



================================================
FILE: contrib/nogaps.el
================================================
;;; Copyright (C) 2003, 2004 Shawn Betts
;;;
;;; Copying and distribution of this file, with or without modification,
;;; are permitted in any medium without royalty provided the copyright
;;; notice and this notice are preserved.

(eval-when-compile
  (require 'cl))

(require 'ratpoison-cmd)

(defun ratpoison-nogaps ()
  (let ((wins (mapcar 'string-to-number (split-string (ratpoison-windows "%n")))))
  (loop for n in wins
        for i from 1 to (length wins)
        do (ratpoison-number i n))))



================================================
FILE: contrib/ratdate.sh
================================================
#!/bin/sh
#
# Copyright (C) 2013 Rob Paisley
#
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
# notice and this notice are preserved.
# 
# Description:	This script displays the date with a calendar indicating today
# 		via ratpoison's echo command.
# Suggest rebinding :time as follows: bind a exec exec ratdate.sh
t=`date +%e`
cal=`cal | sed -e '1s/.*//' -e 's/[^ [:alnum:]]//g' -e "s/\ $t\ /\<$t\>/"`
exec ratpoison -c "echo `date +'%r - %A%n   %D - %B'` $cal"



================================================
FILE: contrib/ratpoison.el
================================================
;;; ratpoison.el --- ratpoison support for Emacs
;;
;; Copyright (C) 2003 Gergely Nagy, Shawn Betts, Jay Belanger
;;
;; Authors: Gergely Nagy <algernon@debian.org>,
;;          Shawn Betts <sabetts@users.sourceforge.net>,
;;          Jay Belanger <belanger@truman.edu>,
;; Maintainer: Gergely Nagy <algernon@debian.org>
;; Version: 0.2
;; Keywords: faces, ratpoison, X

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2 of
;; the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public
;; License along with this program; if not, write to the Free
;; Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
;; MA 02111-1307 USA

;;; Commentary:
;;
;; This file provides a major mode for editing .ratpoisonrc files, and
;; functions to access ratpoison from within Emacs.

;;; History:
;; Version 0.2:
;;  - Added command-interpreter (from Shawn and Jay)
;;  - Added info-lookup functions (from Jay)
;;  - renamed to ratpoison.el
;;  - far better font-locking
;; Version 0.1:
;;  - initial version

;;; Todo:
;; - auto-completion of commands
;; - probably a bunch of other things

(require 'font-lock)
(require 'generic-x)

(defvar ratpoison-commands-0
  (list
   "abort"
   "banish"
   "clock"
   "curframe"
   "delete"
   "focus"
   "focusup"
   "focusdown"
   "focusleft"
   "focusright"
   "meta"
   "help"
   "info"
   "kill"
   "lastmsg"
   "redisplay"
   "restart"
   "next"
   "only"
   "other"
   "prev"
   "quit"
   "remove"
   "split"
   "hsplit"
   "version"
   "vsplit"
   ))

(defvar ratpoison-commands-rest
  (list
   "bind"
   "chdir"
   "colon"
   "defbarloc"
   "msgwait"
   "defborder"
   "deffont"
   "definputwidth"
   "defmaxsizepos"
   "defpadding"
   "deftranspos"
   "defwaitcursor"
   "defwinfmt"
   "defwinname"
   "defwinpos"
   "deffgcolor"
   "defbgcolor"
   "escape"
   "echo"
   "exec"
   "newwm"
   "number"
   "pos"
   "rudeness"
   "select"
   "setenv"
   "source"
   "startup_message"
   "title"
   "unbind"
   "unsetenv"
   "windows"
   ))

;; ratpoisonrc-mode
(define-generic-mode 'ratpoisonrc-mode
  ;; comments
  (list ?#)
  ;; keywords
  nil
  ;; font-lock stuff
  (list
    ;; commands without arguments
    (generic-make-keywords-list
     ratpoison-commands-0 font-lock-builtin-face "^[ \t]*")
    ;; commands with arguments
    (generic-make-keywords-list
     ratpoison-commands-rest font-lock-builtin-face "^[ \t]*" "[ \t]+")
    ;; exec <arg>
    (list "^[ \t]*\\(exec\\)[ \t]+\\(.*\\)"
          '(1 'font-lock-builtin-face)
          '(2 'font-lock-string-face))
    ;; arguments, the first is a keyword, the rest is tring
    (list (concat
                (car (generic-make-keywords-list
                      ratpoison-commands-rest font-lock-builtin-face "^[ \t]*" "[ \t]+"))
                "\\([0-9a-zA-Z\\/\\.\\-]+\\)[ \t]*\\(.*\\)")
          '(2 'font-lock-keyword-face)
          '(3 'font-lock-string-face)))
  ;; auto-mode alist
  (list "\\.ratpoisonrc\\'")
  ;; additional setup functions
  (list 'ratpoisonrc-mode-setup)
  "Generic mode for ratpoison configuration files.")

(defun ratpoisonrc-mode-setup()
  (defvar ratpoisonrc-mode-keymap (make-sparse-keymap)
    "Keymap for ratpoisonrc-mode")
  (define-key ratpoisonrc-mode-keymap "\C-c\C-e" 'ratpoison-line)
  (use-local-map ratpoisonrc-mode-keymap))

(provide 'ratpoisonrc-mode)

;; Ratpoison access
; Groups & Variables
(defgroup ratpoison nil "Ratpoison access"
  :group 'languages
  :prefix "ratpoison-")

(defcustom ratpoison-program "ratpoison"
  "The command to call the window manager."
  :group 'ratpoison
  :type 'string)

; Command stuff
(defun ratpoison-command (command)
  (interactive "sRP Command: ")
  (call-process ratpoison-program nil nil nil "-c" command))

(defun ratpoison-command-on-region (start end)
  (interactive "r")
  (mapcar 'ratpoison-command
          (split-string (buffer-substring start end)
                        "\n")))

(defun ratpoison-line ()
  "Send the current line to ratpoison."
  (interactive)
  (ratpoison-command
   (buffer-substring-no-properties
    (line-beginning-position)
    (line-end-position))))

;; Documentation
(defun ratpoison-manual ()
  "Call up the ratpoison info page."
  (interactive)
  (info "ratpoison"))

(defun ratpoison-manual-commands ()
  "Call up the info page listing the ratpoison commands."
  (interactive)
  (info "(ratpoison) Commands"))

(provide 'ratpoison)



================================================
FILE: contrib/rpbatch.pl
================================================
#!/usr/bin/env perl
#
# Copyright (C) 2003 Shawn Betts
# Execute a sequence of commands read from stdin.

$ratpoison = $ENV{RATPOISON} || 'ratpoison';

while (<>) {
    chomp;
    push @accum, "-c";
    push @accum, "\"$_\"";
}

system ("$ratpoison @accum");



================================================
FILE: contrib/rpshowall.sh
================================================
#!/bin/sh

# rpshowall
# ratpoison script to show all open windows
# Copyright (C) 2003 Florian Cramer <cantsin@zedat.fu-berlin.de>

# Usage :
#
# rpshowall [no arguments]
# if called from a terminal, show all open windows and
# restore previous frame layout upon keystroke
#
# rpshowall [n>1]
# show all open windows for n seconds,
# then restore previous frame layout
#
# rpshowall 0
# show all open windows, do not restore previous frame layout

if [ -z "$RATPOISON" ]; then
    RATPOISON=ratpoison
fi

# Parse input argument

case $# in
    0)  wait=-1
        ;;
    1)
        wait=$1
        ;;
    *)
        printf '%s\n' "Usage: $0 [sleep_seconds]" >&2
        exit 1
        ;;
esac

# Save current frameset

framecount=`$RATPOISON -c windows | wc -l | sed -e "s/[ ]*//g"`
curframe=`$RATPOISON -c windows | grep "^[0-9]*\*" | sed -e "s/^\([0-9]*\).*/\1/"`
curlayout=`$RATPOISON -c fdump`


# Create split view of all open windows

$RATPOISON -c only
i=2
while [ "$i" -le "$framecount" ]; do
        if [ "$i" -le $(($framecount/2)) ] ; then
                $RATPOISON -c vsplit
        else
                $RATPOISON -c hsplit
        fi
        $RATPOISON -c focus
        $RATPOISON -c focus
        i=$(($i+1));
done

# Depending on the argument the script was executed with,
# 1- select a new window and exit opening it fullscreen
# 2- restore frameset after keyboard input
# 3- restore frameset after $wait seconds of delay

$RATPOISON -c "select $curframe"
if [ $wait -eq 0 ]; then
        $RATPOISON -i -c fselect
        $RATPOISON -c only
else
        $RATPOISON -i -c windows
        if [ "$wait" -eq -1 ]; then
                printf '%s' "Hit return to restore window layout. "
                read i
        else
                sleep "$wait"
        fi
        $RATPOISON -c "frestore $curlayout"
fi



================================================
FILE: contrib/rpws
================================================
#!/usr/bin/perl

#
# Copyright (c) 2009 Hatem Nassrat <hnassrat@gmail.com>
# All rights reserved. Modifications under same license as original script.
# ChangeLog:
#
#   Added C-M-Right and C-M-Left for next and prev workspace
#   Added move window to next prev workspace
#   Added dump/restore workspaces
#
# Copyright (c) 2005 Mike O'Connor
# All rights reserved.
# Author Mike O'Connor <stew@vireo.org>
#
# Modified by Shawn Betts.
#
# Code was adapted from rpws that comes from ratpoison containing the
# following copyright:
# Copyright (C) 2003 Shawn Betts
# Author: Shawn Betts
#

use strict;
use warnings;
use Fcntl qw (:flock);
use Getopt::Std;

my $ratpoison = $ENV{ "RATPOISON" } || "ratpoison";
my $tmp=$ENV{ "TMP" } || "/tmp";
my $lockfile = $ENV{ "RPWS_LOCKFILE" } || "$tmp/rpws.$<.lock";

# Check if sfdump/sfrestore commands are available
my $use_multiscreen = 0;
my $test_sfdump = `$ratpoison -c "help sfdump" 2>&1`;
if ($test_sfdump !~ /unknown command/i && $test_sfdump !~ /error/i) {
    $use_multiscreen = 1;
}

sub help
{
    system("pod2usage", $0);
    print( "for more detailed documentation run \"perldoc $0\"\n" );
}

sub rp_call
{
    my $result = `$ratpoison -c "@_"`;
    chomp( $result );
    chomp( $result );
    return $result;
}

sub ws_init_ws
{

    my $num = shift;

    rp_call( "gnew wspl$num" );
    my $fd = fdump();
    rp_call( "setenv fspl$num $fd" );
}

sub fdump
{
    if ($use_multiscreen) {
        return rp_call( "sfdump" );
    } else {
        return rp_call( "fdump" );
    }
}

sub frestore
{
    my $data = shift;
    if ($use_multiscreen) {
        return rp_call( "sfrestore $data" );
    } else {
        return rp_call( "frestore $data" );
    }
}

sub ws_init
{
    my $num = shift;

    $num >= 2 || die "You must create at least 2 workspaces.";

    # Backup the frames
    my $fd = fdump();

    rp_call( "select -" );
    rp_call( "only" );

    my $i;
    for my $i (2..$num)
    {
        ws_init_ws( $i );
    }

    # Workspace 1 uses the 'default' group.
    # Start in workspace 1.
    my $fd1 = fdump();
    rp_call( "gselect default" );
    rp_call( "setenv fspl1 $fd1" );
    rp_call( "setenv wspl 1" );

    # Keep track of workspace count
    rp_call( "setenv wspc $num" );

    # restore the frames
    frestore( $fd );

    if( -e "$lockfile" )
    {
        unlink ("$lockfile" );
    }
}

sub ws_save
{
    my $ws = rp_call( "getenv wspl" );
    my $fd = fdump();
    rp_call( "setenv fspl$ws $fd" );
}

sub ws_restore
{
    my $which = shift;
    my $which_name;
    my $move;

    # Step1: determine which workspace to move to

    if ( $which =~ /^move/ )
    {
        $move = 1;
        $which = substr($which, 4);
    }

    if ( $which =~ /^(?:next|prev)$/ )
    {
        my $ws = rp_call( "getenv wspl" );
        my $wspc = rp_call( "getenv wspc" );

        if ( $which eq 'next' )
        {
            $ws++;
        }
        else
        {
            $ws--;
        }
        $which = ( ( $ws - 1 ) % $wspc ) + 1;
    }

    if ( $which == 1 )
    {
        $which_name = "default";
    }
    else
    {
        $which_name = "wspl$which";
    }

    # Step 2a: Moving Window if necessary
    if ( $move )
    {
        rp_call( "gmove $which_name" );
        rp_call( "select -" );
        rp_call( "prev" );
    }

    # Step2: Process the workspace switch
    ws_save();
    rp_call( "gselect $which_name");
    my $last = rp_call( "getenv fspl$which" );
    frestore( $last );
    rp_call( "setenv wspl $which" );

    # Step 2x: Display the moved Window
    if ( $move )
    {
        rp_call( "next" );
    }

    rp_call( "echo Workspace $which" );

}

sub ws_dump
{
    my $ws_dumpf = shift;
    my $wspc = rp_call( "getenv wspc" );

    open WSDUMP, ">$ws_dumpf" or die $!;

    ws_save();

    for my $i (1..$wspc)
    {
        print WSDUMP rp_call( "getenv fspl$i" )."\n";
    }

    close WSDUMP;

    rp_call( "echo Workspaces dumped to $ws_dumpf" );
}

sub ws_dumprestore
{
    my $ws_dumpf = shift;
    my $ws = rp_call( "getenv wspl" );
    my $wspc = rp_call( "getenv wspc" );

    # Get dumped frame info
    open WSDUMP, "$ws_dumpf" or die $!;
    my @wsdata=<WSDUMP>;
    close WSDUMP;

    my $wspc_dump = scalar @wsdata;

    if ($wspc < $wspc_dump)
    {
        # Number of workspaces to restore more than available
        die "Cannot restore all workspaces (dump_count = " . $wspc_dump . ", rp_count = " . $wspc . ")";
    }

    # Restoring all workspaces
    for my $i (1..$wspc_dump)
    {
        # calculating previous workspace number
        my $j = ( $wspc + $i - 2 ) % $wspc + 1;
        # moving to workspace $i -1
        ws_restore( $j );
        # restoring workspace $i
        rp_call( "setenv fspl$i $wsdata[$i-1]" );
    }

     # goto the originally visible workspace
     ws_restore( $ws );

    rp_call( "echo Workspaces loaded from $ws_dumpf" );
}

sub add_aliases
{
    my $n = shift;
    foreach my $i (1..$n) {
        # Switch Workspace
        rp_call ( "alias rpws$i exec $0 $i" );
        # Move Window to wrokspace
        rp_call ( "alias rpwsm$i exec $0 move$i" );
    }
    rp_call ( "alias rpwsn exec $0 next" );
    rp_call ( "alias rpwsp exec $0 prev" );
    rp_call ( "alias rpwsmn exec $0 movenext" );
    rp_call ( "alias rpwsmp exec $0 moveprev" );


}

sub add_keys
{
    my $n = shift;
    foreach my $i (1..$n) {
        # Switch Workspace
        rp_call ( "definekey top M-F$i rpws$i" );
        # Move Window to wrokspace
        rp_call ( "definekey top C-M-S-F$i rpwsm$i" );
    }
    rp_call ( "definekey top C-M-Right rpwsn" );
    rp_call ( "definekey top C-M-Left rpwsp" );
    rp_call ( "definekey top C-M-greater rpwsmn" );
    rp_call ( "definekey top C-M-less rpwsmp" );
}

my $arg = shift @ARGV || 'help';

if( $arg eq "help" ) {
    help();
} elsif( $arg eq "init" ) {
    my $num = shift @ARGV;
    my %opts;
    getopts('ka', \%opts);
    ws_init( $num );
    add_aliases( $num ) if $opts{'a'} || $opts{'k'};
    add_keys ( $num ) if $opts{'k'};
} elsif( $arg eq "dump" ) {
    my $filename = shift @ARGV;
    ws_dump($filename);
} elsif( $arg eq "restore" ) {
    my $filename = shift @ARGV;
    ws_dumprestore($filename);
} elsif ( $arg eq "current" ) {
    my $cws = rp_call( "getenv wspl" );
    print "$cws";
} else {
   open LOCK, ">>$lockfile" or die "Cannot open lockfile: $lockfile";
   flock(LOCK, LOCK_EX);
   ws_restore( $arg );
}

__END__

=head1 NAME

rpws - Implements multiple workspaces in ratpoison

=head1 SYNOPSIS

 rpws init n [-k] [-a]  - setup rpws with n workspaces.
                            -a sets up command aliases;
                            -k sets up key bindings and aliases.
 rpws dump <fname>      - dumps the current layout to <fname>
 rpws restore <fname>   - restores rpws workspaces from <fname>
 rpws current           - print the current workspace
 rpws help              - this documentation
 rpws n                 - switch to this workspace


=head1 DESCRIPTION

 B<rpws> implements multiple workspaces in ratpoison by making calls
 to fdump, freestore.  It was adapted from rpws which comes with
 ratpoison in the contrib directory.

 This version automatically detects and uses sfdump/sfrestore commands
 if available for proper multi-monitor support. If these commands are
 not available, it falls back to using fdump/frestore.

=head1 USAGE

Add the following line in ~/.ratpoisonrc

     exec /path/to/rpws init 6 -k

This creates 6 aliases rpws1, rpws2, etc. It also binds the keys M-F1,
M-F2, etc to each rpwsN alias. Moreover, rpwsn (Next) and rpwsp (Prev) are
created, and C-M-{Right,Left} are bound to rpws{n,p}. Aliases rpwsm1, rpwsm2,
etc. and rpwsm{n,p} are used to move the focused window to another workspace.

Full list of keybindings created are:

    M-F$i           Goto workspace $i
    C-M-Right       Goto Next workspace
    C-M-Left        Goto Prev workspace
    C-M-S-F$i       Move window to workspace $i
    C-M-greater     Move current window to next workspace
    C-M-less        Move current window to prev workspace

=head1 FILES

 rpws requires use of a lockfile.  It defaults to using
/tmp/rpws.<UID>.lock but this can be changed by setting the
environment variable RPWS_LOCKFILE to your desired lockfile.

=head1 AUTHOR

 Mike O'Connor <stew@vireo.org>

=head1 COPYRIGHT

 Copyright (c) 2005 Mike O'Connor
 All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.



================================================
FILE: contrib/sloppy.c
================================================
/* Sloppy focus
 *
 * Copyright (C) 2005 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * unrat is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * unrat is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xproto.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int (*defaulthandler) (Display *, XErrorEvent *);

int
errorhandler (Display *display, XErrorEvent *error)
{
  if (error->error_code != BadWindow)
    (*defaulthandler) (display, error);
  return 0;
}

int
spawn (char *cmd)
{
  int pid;

  pid = fork ();
  if (pid == 0)
    {
      execl ("/bin/sh", "sh", "-c", cmd, (char *)NULL);
      _exit (EXIT_FAILURE);
    }
  return pid;
}

int
main (void)
{
  Display *display;
  int i, numscreens;

  display = XOpenDisplay (NULL);
  if (!display)
    {
      fprintf (stderr, "sloppy: could not open display\n");
      exit (1);
    }

  /* Ensure child shell will have $RATPOISON set. */
  if (!getenv ("RATPOISON"))
    setenv ("RATPOISON", "ratpoison", 0);

  defaulthandler = XSetErrorHandler (errorhandler);
  numscreens = ScreenCount (display);

  for (i = 0; i < numscreens; i++)
    {
      unsigned int j, nwins;
      Window dw1, dw2, *wins;

      XSelectInput (display, RootWindow (display, i),
                    SubstructureNotifyMask);
      XQueryTree (display, RootWindow (display, i),
                  &dw1, &dw2, &wins, &nwins);
      for (j = 0; j < nwins; j++)
	XSelectInput (display, wins[j], EnterWindowMask);
    }

  while (1)
    {
      XEvent event;

      do
	{
	  XNextEvent (display, &event);
	  if (event.type == CreateNotify)
            {
              XSelectInput (display, event.xcreatewindow.window,
                            EnterWindowMask);
            }
	} while (event.type != EnterNotify);

      /* A window was entered. select it. */
      {
        char shell[256];

        snprintf (shell, sizeof(shell),
                  "$RATPOISON -c \"select $($RATPOISON -c 'windows %%i %%n %%f' | grep '%ld' | awk '$3 != '$($RATPOISON -c curframe)' && $3 != \"\" {print $2}')\" 2>/dev/null",
                  event.xcrossing.window);
        spawn (shell);
        wait (NULL);
      }
    }

  XCloseDisplay (display);

  return 0;
}

/*
Local Variables: ***
compile-command: "gcc -g -Wall -O2  -I/usr/X11R6/include -o sloppy sloppy.c -L/usr/X11R6/lib -lX11" ***
End: ***
*/



================================================
FILE: contrib/split.sh
================================================
#!/bin/sh
#
# Copyright (C) 2003 Shawn Betts
#
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
#
# Split the current frame into 16 little frames. This is an example of
# how to script ratpoison.

if [ -z "$RATPOISON" ]; then
    RATPOISON=ratpoison
fi

# $RATPOISON -c only

#split into 4 frames

$RATPOISON -c split
$RATPOISON -c hsplit
$RATPOISON -c focusdown
$RATPOISON -c hsplit

# split each new frame into 4

$RATPOISON -c split
$RATPOISON -c hsplit
$RATPOISON -c focusdown
$RATPOISON -c hsplit

$RATPOISON -c focusup
$RATPOISON -c focusup

$RATPOISON -c split
$RATPOISON -c hsplit
$RATPOISON -c focusdown
$RATPOISON -c hsplit

$RATPOISON -c focusright
$RATPOISON -c focusright

$RATPOISON -c split
$RATPOISON -c hsplit
$RATPOISON -c focusdown
$RATPOISON -c hsplit

$RATPOISON -c focusdown

$RATPOISON -c split
$RATPOISON -c hsplit
$RATPOISON -c focusdown
$RATPOISON -c hsplit



================================================
FILE: contrib/unrat.c
================================================
/* Warp the pointer to the bottom right corner of the screen any time a key is pressed.
 *
 * Copyright (C) 2005 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * unrat is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * unrat is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

/*
This is what I used to compile it:

gcc -g -Wall -O2  -I/usr/X11R6/include -o unrat unrat.c -L /usr/X11R6/lib -lX11
*/

#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xproto.h>
#include <stdio.h>
#include <stdlib.h>

int (*defaulthandler) (Display *, XErrorEvent *);

int
errorhandler (Display *display, XErrorEvent *error)
{
  if (error->error_code != BadWindow)
    (*defaulthandler) (display,error);

  return 0;
}

int
main (void)
{
  Display *display;
  int i, numscreens;

  display = XOpenDisplay (NULL);
  if (!display)
    {
      fprintf (stderr, "unrat: could not open display\n");
      exit (1);
    }

  defaulthandler = XSetErrorHandler (errorhandler);
  numscreens = ScreenCount (display);

  for (i = 0; i < numscreens; i++)
    {
      unsigned int j, nwins;
      Window dw1, dw2, *wins;

      XSelectInput (display, RootWindow (display, i),
                    KeyReleaseMask | SubstructureNotifyMask);
      XQueryTree (display, RootWindow (display, i),
                  &dw1, &dw2, &wins, &nwins);
      for (j = 0; j < nwins; j++)
        XSelectInput (display, wins[j], KeyReleaseMask);
    }

  while (1)
    {
      XEvent event;
      do
        {
          XNextEvent (display, &event);
          if (event.type == CreateNotify)
            {
              XSelectInput (display, event.xcreatewindow.window,
                          KeyReleaseMask);
            }
        } while (event.type != KeyRelease);

      /* A key was pressed. warp the rat. */
      for (i = 0; i < numscreens; i++)
        {
          int x, y, wx, wy;
          unsigned int mask;
          Window root, child;

          XQueryPointer (display, RootWindow (display, i),
                         &root, &child,
                         &x, &y, &wx, &wy,
                         &mask);
          if (x < DisplayWidth (display, i) - 1
              || y < DisplayHeight (display, i) - 1)
            {
              XWarpPointer (display, None, RootWindow (display, i),
                            0, 0, 0, 0,
                            DisplayWidth (display, i),
                            DisplayHeight (display, i));
            }
        }
    }

  XCloseDisplay (display);

  return 0;
}



================================================
FILE: doc/fdl.texi
================================================
@c The GNU Free Documentation License.
@center Version 1.2, November 2002

@c This file is intended to be included within another document,
@c hence no sectioning command or @node.

@display
Copyright @copyright{} 2000,2001,2002 Free Software Foundation, Inc.
51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
@end display

@enumerate 0
@item
PREAMBLE

The purpose of this License is to make a manual, textbook, or other
functional and useful document @dfn{free} in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.

This License is a kind of ``copyleft'', which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

@item
APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The ``Document'', below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as ``you''.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.

A ``Modified Version'' of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A ``Secondary Section'' is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The ``Invariant Sections'' are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.

The ``Cover Texts'' are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.

A ``Transparent'' copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not ``Transparent'' is called ``Opaque''.

Examples of suitable formats for Transparent copies include plain
@sc{ascii} without markup, Texinfo input format, La@TeX{} input
format, @acronym{SGML} or @acronym{XML} using a publicly available
@acronym{DTD}, and standard-conforming simple @acronym{HTML},
PostScript or @acronym{PDF} designed for human modification.  Examples
of transparent image formats include @acronym{PNG}, @acronym{XCF} and
@acronym{JPG}.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, @acronym{SGML} or
@acronym{XML} for which the @acronym{DTD} and/or processing tools are
not generally available, and the machine-generated @acronym{HTML},
PostScript or @acronym{PDF} produced by some word processors for
output purposes only.

The ``Title Page'' means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, ``Title Page'' means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

A section ``Entitled XYZ'' means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as ``Acknowledgements'',
``Dedications'', ``Endorsements'', or ``History''.)  To ``Preserve the Title''
of such a section when you modify the Document means that it remains a
section ``Entitled XYZ'' according to this definition.

The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.

@item
VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

@item
COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

@item
MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

@enumerate A
@item
Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

@item
List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

@item
State on the Title page the name of the publisher of the
Modified Version, as the publisher.

@item
Preserve all the copyright notices of the Document.

@item
Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

@item
Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

@item
Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

@item
Include an unaltered copy of this License.

@item
Preserve the section Entitled ``History'', Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled ``History'' in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

@item
Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the ``History'' section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

@item
For any section Entitled ``Acknowledgements'' or ``Dedications'', Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

@item
Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

@item
Delete any section Entitled ``Endorsements''.  Such a section
may not be included in the Modified Version.

@item
Do not retitle any existing section to be Entitled ``Endorsements'' or
to conflict in title with any Invariant Section.

@item
Preserve any Warranty Disclaimers.
@end enumerate

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.

You may add a section Entitled ``Endorsements'', provided it contains
nothing but endorsements of your Modified Version by various
parties---for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

@item
COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled ``History''
in the various original documents, forming one section Entitled
``History''; likewise combine any sections Entitled ``Acknowledgements'',
and any sections Entitled ``Dedications''.  You must delete all
sections Entitled ``Endorsements.''

@item
COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

@item
AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an ``aggregate'' if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.

@item
TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.

If a section in the Document is Entitled ``Acknowledgements'',
``Dedications'', or ``History'', the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.

@item
TERMINATION

You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.

@item
FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
@uref{http://www.gnu.org/copyleft/}.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License ``or any later version'' applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
@end enumerate

@page
@heading ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

@smallexample
@group
  Copyright (C)  @var{year}  @var{your name}.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.2
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
@end group
@end smallexample

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the ``with@dots{}Texts.'' line with this:

@smallexample
@group
    with the Invariant Sections being @var{list their titles}, with
    the Front-Cover Texts being @var{list}, and with the Back-Cover Texts
    being @var{list}.
@end group
@end smallexample

If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

@c Local Variables:
@c ispell-local-pdict: "ispell-dict"
@c End:



================================================
FILE: doc/ipaq.ratpoisonrc
================================================
# .ratpoisonrc for an iPaq36xx handheld pc running Linux
# Copyright (C) 2003, 2004 Ryan Yeske
#
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright


# make the "audio record" button the escape key:
escape XF86AudioRecord

# the "speaker" buttons
bind Up exec rxvt
bind Down windows
bind Left prev
bind Right next
bind KP_Enter echo

# the power button should be reserved?
bind XF86PowerDown exec (sleep 1; echo > /proc/sys/pm/suspend )

## the four buttons under the screen:
bind XF86Calendar exec xcalc
bind telephone exec contacts
bind Menu echo
bind XF86Start clock



================================================
FILE: doc/Makefile.am
================================================
# Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
#
# This file is part of ratpoison.
#
# ratpoison is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# ratpoison is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

info_TEXINFOS = ratpoison.texi
man_MANS      = ratpoison.1
CLEANFILES    = ratpoison.1
EXTRA_DIST    = $(srcdir)/ratpoison.mdoc.1 $(srcdir)/ratpoison.man.1 sample.ratpoisonrc ipaq.ratpoisonrc fdl.texi
MAINTAINERCLEANFILES = $(srcdir)/ratpoison.man.1 Makefile.in texinfo.tex

ratpoison.1: $(srcdir)/ratpoison.$(manpage_format).1 Makefile
	tmp=`mktemp` && \
	sed -e 's|%%sysconfdir%%|$(sysconfdir)|g' \
	    -e 's|%%docdir%%|$(docdir)|g' \
	    < $(srcdir)/ratpoison.$(manpage_format).1 > "$$tmp" && \
	chmod 0644 "$$tmp" && \
	mv "$$tmp" ratpoison.1

$(srcdir)/ratpoison.man.1: $(srcdir)/ratpoison.mdoc.1
	tmp=`mktemp` && \
	$(MANDOC) -Tman < $(srcdir)/ratpoison.mdoc.1 > "$$tmp" && \
	chmod 0644 "$$tmp" && \
	mv "$$tmp" $(srcdir)/ratpoison.man.1



================================================
FILE: doc/ratpoison.mdoc.1
================================================
.\" This man page is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2, or (at your option)
.\" any later version.
.\"
.\" This man page is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this software; see the file COPYING.  If not, write to
.\" the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
.\" Boston, MA 02111-1307 USA
.\"
.\"
.\" This manpage is written using the mdoc macro language.
.\" Examples of formatters which support mdoc are groff[1] and mandoc[2].
.\" An mdoc language reference is available[3].
.\"
.\" [1] https://gnu.org/software/groff/
.\" [2] http://mdocml.bsd.lv/
.\" [3] http://mdocml.bsd.lv/mdoc.7.html
.\"
.Dd Aug 22, 2017
.Dt RATPOISON 1
.Os
.Sh NAME
.Nm ratpoison
.Nd window manager without mouse dependency
.Sh SYNOPSIS
.Nm
.Op Fl hv
.Nm
.Op Fl d Ar dpy
.Op Fl s Ar num
.Op Fl f Ar file
.Nm
.Op Fl d Ar dpy
.Op Fl s Ar num
.Op Fl i
.Fl c Ar command Op Fl c Ar command ...
.Sh DESCRIPTION
.Nm
is a Window Manager without fat library dependencies, fancy graphics or
rat dependence.
.Pp
The screen can be split into non-overlapping frames.
All windows are kept maximized inside their frames.
.Pp
All interaction with the window manager is done through
keystrokes.
.Nm
has a prefix map to minimize key clobbering.
.Pp
The options are as follows:
.Bl -tag -width Bs
.It Fl c , Fl \-command
Send ratpoison a command.
There must be a ratpoison instance running as window manager for the
given display/screen for this to work.
Do not forget to quote the command if it contains spaces.
For example:
.Dl Nm Fl c Qq Ar "echo hello world"
.It Fl d , Fl \-display Ar display
Set the X display to use or send commands to.
.It Fl f , Fl \-file Ar filename
Specify an alternate configuration file.
If this is not given,
.Nm
will try
.Pa $HOME/.ratpoisonrc
and if that does not exist
.Pa /etc/ratpoisonrc
and execute each command when starting up.
.It Fl h , Fl \-help
Show summary of options.
.It Fl i , Fl \-interactive
Execute commands given with
.Fl c
or
.Fl \-command
in interactive mode.
That means it will behave exactly as if called with
.Ic C\-t \&:
like prompting for missing arguments and things like that.
.It Fl s , Fl \-screen Ar number
Only use the specified screen.
.It Fl v , Fl \-version
Show version of program.
.El
.Sh KEY BINDINGS
To avoid conflicts with other programs, all default ratpoison key
bindings start with an escape key, per default
.Ic C\-t
(read Control\-t).
Some important default key bindings:
.Bl -tag -width Ds
.It Ic C\-t \&?
Show key bindings
.It Ic C\-t c
Start an X terminal
.It Ic C\-t n
Switch to next window
.It Ic C\-t p
Switch to previous window
.It Ic C\-t 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
Switch to window number 1 | 2 | ...
.It Ic C\-t k
Close the current window
.It Ic C\-t K
XKill the current application
.It Ic C\-t s | S
Split the current frame into two vertical | horizontal ones
.It Ic C\-t Tab | Left | Up | Right | Down
Switch to the next | left | top | right | bottom frame.
.It Ic C\-t Q
Make the current frame the only one
.It Ic C\-t \&:
Execute a ratpoison command
.El
.Pp
Further default key bindings can be found in parentheses after the
commands in the next section.
.Sh COMMANDS AND DEFAULT ALIASES
.Bl -tag -width Ds
.It Ic abort
.Pq Ic C\-t C\-g
Do nothing and that successfully.
.Po
Useful if you pressed
.Ic C\-t
in error
.Pc .
.It Ic addhook Ar event command
Add a hook: run
.Ar command
whenever
.Ar event
is called.
Possible events are:
.Bl -tag -width Ds
.It Cm deletewindow
Run after a window is withdrawn.
.It Cm newwindow
Run after a new window is mapped.
.It Cm key
Run whenever a top level key is pressed (by default
.Ic C\-t ) .
.It Cm quit
Run before exiting
.Nm .
.It Cm restart
Run before restarting
.Nm .
.It Cm switchframe
Run after a frame actually switched, but before the window in it is
focused.
.It Cm switchgroup
Run after selecting a new group.
.It Cm switchscreen
Run when the user switches to a different screen.
.It Cm switchwin
Run after a new window is selected.
(With dedication, it may already be inactive again, if it was put into
another frame)
.El
.It Ic alias Ar alias command
Add
.Ar alias
as new way to call
.Ar command .
.It Ic bind Ar key command
alias for
.Qq Ic definekey Li root Ar key command
.It Ic banish
.Pq Ic C\-t b
Banish the rat cursor to the lower right corner of the screen.
.It Ic banishrel
Banish the rat cursor to the lower right corner of the current window.
If there isn't a window in the current frame, it banishes the rat cursor
to the lower right corner of the frame.
.It Ic chdir Op Ar directory
If the optional argument is given, change the current directory
of
.Nm
to
.Ar directory .
If nothing is given, change it to the value of the environment variable
.Qq Ev HOME .
.It Ic clrunmanaged
Clears the unmanaged window list.
.It Ic cnext
Like
.Ic next
but switch to the next window with another resource class than the
current one.
(That means the next window belonging to another type of application
than the current one.)
.It Ic cprev
Like
.Ic prev
but switch to the previous window with another resource class than the
current one.
(That means the previous window belonging to another type of application
than the current one.)
.It Ic colon Ar ratpoison\-command Pq Ic C\-t \&:
Execute
.Ar ratpoison\-command
interactively.
(i.e. ask for possible missing arguments.)
.It Ic cother
Like
.Ic other
but switch to the window of the current group that was last accessed and
has another resource class but is not currently visible.
.It Ic curframe Pq Ic C\-t F
Show a bar marking the current frame.
.It Ic definekey Ar keymap key command
Add a new key binding in
.Ar keymap
for
.Ar key
to execute
.Ar command .
Default keymaps are
.Li top
normally only containing
.Ic C\-t ,
which reads a key from
.Li root ,
containing all the normal commands.
.Pp
Note that you have to describe ":" by "colon", "!" by "exclam" and so on.
If you cannot guess a name of a key, try either
.Ic C\-t Ar key
and look at the error message, or try
.Ic :describekey Li root
and pressing the key.
.It Ic dedicate Op Cm 0 | 1
Consider the current frame dedicated/chaste
.Pq Cm 1
or promiscuous
.Pq Cm 0 .
.Pp
A dedicated frame will not accept new windows.
When new windows are to be focused, they will be opened in a non-dedicated
frame instead.
.Pp
If no argument is given, toggle the current dedicateness.
By default no windows are dedicated.
.It Ic delete Pq Ic C\-t k
Close the current window.
.It Ic delkmap Ar keymap
Deletes the keymap named
.Ar keymap ,
that was generated with
.Ic newkmap .
The keymaps
.Li top
(or whatever was specified by
.Ic set Ar topkmap )
and
.Li root
cannot be deleted.
.It Ic describekey Ar keymap
Grab the next key.
Similar to
.Ic readkey ,
.Ic describekey
shows only the command in
.Ar keymap ,
that would be executed by
.Ic readkey .
.It Ic echo Ar text
Show
.Ar text
as
.Nm
message.
.It Ic escape Ar key
Update the default escape key to
.Ar key .
.Pp
Strictly speaking it updates the
.Ic readkey Li root
command in the keymap
.Li top
to
.Ar key ,
the
.Ic other
binding
in
.Li root
to
.Ar key ,
and
.Ic meta
binding in
.Li root
to
.Ar key
without modifiers or
.Ic "C\-" Ns Ar key
if
.Ar key
has no modifiers.
(If
.Ic set Ar topkmap
was called with an argument other than
.Ar top
that will be used instead of
.Ar top . )
.It Ic exchangedown Pq Ic C\-t C\-Down
Exchange the window in the current frame with the window in the frame
below the current frame.
.It Ic exchangeleft Pq Ic C\-t C\-Left
Exchange the window in the current frame with the window in the frame
left of the current frame.
.It Ic exchangeright Pq Ic C\-t C\-Right
Exchange the window in the current frame with the window in the frame
right of the current frame.
.It Ic exchangeup Pq Ic C\-t C\-Up
Exchange the window in the current frame with the window in the frame
above the current frame.
.It Ic exec Ar shell\-command Pq Ic C\-t \&!
Spawn a shell executing
.Ar shell\-command .
.It Ic execa Ar shell\-command
Spawn a shell executing
.Ar shell\-command ,
without remembering the current frame, so that _NET_WM_PID declaring
programs will be placed into the frame active when they open a window
instead of the frame active when
.Nm
gets this command.
.It Ic execf Ar frame shell\-command
Spawn a shell executing
.Ar shell\-command ,
showing _NET_WM_PID supporting programs in the given frame instead of
the frame selected when this program is run.
.It Ic fdump Op Ar screenno
Output the defining data for all frames of the current screen, or
for screen number
.Ar screenno
if this is specified.
.It Ic focus Pq Ic C\-t Tab
Focus the next frame.
.It Ic focuslast
Switch to the last selected focus.
.It Ic focusleft Pq Ic C\-t Left
Switch to the frame to the left of the current one.
.It Ic focusdown Pq Ic C\-t Down
Switch to the frame beneath the current one.
.It Ic focusright Pq Ic C\-t Right
Switch to the frame to the right of the current one.
.It Ic focusprev
Focus the previous frame.
.It Ic focusup Pq Ic C\-t Up
Switch to the frame above the current one.
.It Ic frestore Ar frames
Replace the current frames with the ones specified in
.Ar frames
in the format as generated by
.Ic fdump .
.It Ic fselect Oo Ar frameno Oc Pq Ic C\-t f
If an argument is supplied, switch to a frame given by number
.Ar frameno .
.Pp
If no argument is given, show a frame selector in each frame and wait for
a key to be pressed.
If the key matches an existing frame selector, this frame gets focused.
.Pp
Frame selectors are by default the numbers starting with zero, but they
can be changed by
.Ic set Ns
ting
.Ar framesels .
.It Ic gdelete Op Ar group
If the optional argument
.Ar group
is supplied, delete
.Ar group .
Otherwise delete the current group.
If the last group is deleted, a new group with name
.Li default
is created.
The group has to be empty, otherwise it cannot be deleted.
.It Ic getenv Ar variable
Output the value of the environment variable
.Ar variable .
.It Ic getsel
Paste the current X Selection into the current window.
.It Ic gmerge Ar group
Move all windows from group
.Ar group
into the current group.
.It Ic gmove Ar group
Move the current window into group
.Ar group .
.It Ic gnew Ar group
Create a new group with name
.Ar group
and select it.
Most window commands only see (and thus select, consider next,
previous or last) windows within the group active when they are
issued.
.It Ic gnewbg Ar group
Create a new group named
.Ar group ,
but do not select it.
.It Ic gnext
Select the next group.
Most window commands only see windows in the effective group.
.It Ic gnumber Op Ar old new
Give the number
.Ar new
to the group with the number
.Ar old
or the current group.
.It Ic gother
Select the last accessed group.
Most window commands only see windows in the effective group.
.It Ic gprev
Select the prior group.
Most window commands only see windows in the effective group.
.It Ic gravity Op Cm nw | w | sw | n | c | s | ne | e | se
Change how in its frame the current window is aligned.
.It Ic grename
Rename current group.
.It Ic groups
Output a list of all groups with their number.
.It Ic gselect Ar group
Select the group named
.Ar group .
.It Ic help Op Ar keymap
If the optional parameter
.Ar keymap
is given, list all keybindings in this keymap, otherwise list all key
bindings in keymap
.Li root .
.It Ic hsplit Oo Ar l Ns Li / Ns Ar p | Oo Li \- Oc Ns Ar pixels Oc Pq Ic C\-t S
Split the current frame into left frame and a right frame.
If no parameter is given, split in halves.
If two numbers separated by a slash
.Pq Ql "/"
are given, the left one is
.Ar l
times the
.Ar p Ns
th
part and the right one
.Pq Ar p Li \- Ar l
times the
.Ar p Ns
th
part of the prior width.
Otherwise the right half is
.Ar pixels
wide or the left one is
.Ar pixels
wide, depending whether there is
.Ql \-
in front of the number or not.
.It Ic inext
Like
.Ic next
but switch to the next window with the same resource class as the
current one.
(That means the next window belonging to the same application
as the current one.)
.It Ic info Pq Ic C\-t i
Output the current the width, height, window number and window name of
the current window.
.Po
What name means is chosen by
.Dq Ic set Ar winname .
.Pc
.It Ic iprev
Like
.Ic prev
but switch to the previous window with the same resource class as the
current one.
(That means the previous window belonging to the same application as the
current one.)
.It Ic iother
Like
.Ic other
but switch to the window of the current group that was last accessed and
has the same resource class but is not currently visible.
.It Ic kill Pq Ic C\-t K
Close the X-connection of the X-client responsible for the current window.
.It Ic lastmsg Pq Ic C\-t m
Reshow the last message.
.It Ic license Pq Ic C\-t V
Show
.Nm Ap
s license.
.It Ic link Ar key Op Ar keymap
Do what
.Ar key
is bound to in the keymap
.Ar keymap
if supplied.
Otherwise what
.Ar key
is bound to in keymap
.Li root .
.It Ic listhook Ar event
List all commands specified with
.Ic addhook
to be executed when even
.Ar event
occurs.
.It Ic meta Oo Ar key Oc Pq Ic C\-t t
Send the escape key (that which normally is
.Ic C\-t )
to the current window.
If a
.Ar key
is specified, this is sent instead.
Note that some applications by default ignore the synthetic key that is
sent using this command as it is considered a security hole.
xterm is one such application.
.It Ic msgwait Op Ar seconds
Set the duration the message window is shown.
If
.Ar seconds
is zero, wait infinitely.
This command is deprecated, please set the
.Va msgwait
variable instead.
.It Ic newkmap Ar keymap
Generate a new keymap named
.Ar keymap .
This keymap can be used to add new key-command mappings to it with
.Ic definekey
and can be called with
.Ic readkey .
.It Ic newwm Ar new-window-manager
Quit
.Nm
and execute
.Ar new-window-manager
instead.
.It Ic next Pq Ic C\-t Return | C\-t n | C\-t space
Switch to the next window in the current group.
.It Ic nextscreen Pq Ic C\-t N
Switch to the next screen. (If you have multiple physical ones.)
.It Ic number Ar new Op Ar old
Give the number
.Ar new
to the window with the number
.Ar old
or the current window.
.It Ic only Pq Ic C\-t Q
Remove all frames on the current screen except the current frame and
maximize this one to the size of the whole screen.
.It Ic other Pq Ic C\-t C\-t
Switch to the window of the current group that was last
accessed but is not currently visible.
.It Ic prev Pq Ic C\-t p
Switch to the previous window in the current group.
.It Ic prevscreen Pq Ic C\-t P
Switch to the previous screen. (If you have multiple physical ones.)
.It Ic prompt Op Ar prompt
.Nm
will ask the user for input, showing
.Ar prompt
(or a single colon, if no argument is given) and output the input the
user has made.
Note that this command probably does not make much sense in interactive
mode.
.It Ic putsel Ar x\-selection
Replace the X selection with the text
.Ar x\-selection .
It can be inserted into the current window with
.Ic getsel .
.It Ic quit
Quit
.Nm .
.It Ic ratinfo
Display the x y coordinates of the rat cursor relative to the screen.
.It Ic ratrelinfo
Display the x y coordinates of the rat cursor relative to the current
window or current frame if no window is focused
.It Ic ratwarp Ar x y
Move the rat cursor to the position
.Ar ( x , y ) .
.It Ic ratrelwarp Ar deltax deltay
Move the rat cursor to
.Ar ( deltax , deltay ) ,
relative to the current position.
.It Ic ratclick Op Ar button
Simulate a rat click with
.Ar button
(button 1=left button if none given).
.It Ic rathold Cm ( up | down ) Op Ar button
Simulate pressing|releasing rat button
.Ar button
(1=left button if none given).
.It Ic readkey Ar keymap
Grab the next key pressed, and execute the command associated to this key
in
.Ar keymap .
To show it is waiting for a key,
.Nm
will change the rat cursor to a square if
.Va waitcursor
is set.
This command is perhaps best described with its usage in the default
configuration: by pressing
.Ic C\-t ,
which is the only key in the keymap
top ,
the command
.Qq Ic readkey Ar root
is executed.
The next key then executes the command in keymap
.Li root
belonging to
this command.
.It Ic redisplay Pq Ic C\-t l
Extend the current window to the whole size of its current frame and
redisplay it.
(Useful to redisplay normal windows or bring transient windows to the
full size of the frame as only normal windows are maximized by
.Nm )
.It Ic redo Pq Ic C\-t U
Revert the last
.Ic undo
of frame changes.
.It Ic remhook Ar event command
Remove command
.Ar command
from the list of commands to be called when event
.Ar event
is hit.
(The command has to specified, as an event can have multiple commands
attached to it.)
Use
.Qq Ic listhook Ar hook
to get a list of all attached commands.
.It Ic remove Pq Ic C\-t R
Remove the current frame and extend some frames around to fill the
remaining gap.
.It Ic resize Oo Ar deltax deltay Oc Pq Ic C\-t r
If
.Ar deltax
and
.Ar deltay
are supplied, resize the current frame by that (i.e. move the bottom
right corner by the given offsets and then move this frame and resize
adjacent frames to make the frames fill the whole screen again.)
.Pp
If in interactive mode no arguments are supplied, resize the current
frame interactively:
.Pp
.Bl -tag -offset 2n -width "C-f, Right, l" -compact
.It Ic Return
finish resizing
.It Ic C\-g , Escape
abort resizing
.It Ic C\-n , Down , j
grow vertically
.It Ic C\-p , Up , k
shrink vertically
.It Ic C\-f , Right , l
grow horizontally
.It Ic C\-b , Left , h
shrink horizontally
.It Ic s
shrink to size of current window
.El
.Pp
While resizing interactively, changes are in multiples of the amount
of pixels given by
.Ic set Cm resizeunit
(by default 10).
.It Ic restart
Restart
.Nm .
.It Ic rudeness Op Ar rudeness
This command is deprecated, please use the
.Va rudeness
variable instead.
.It Ic sdump
Output the list of all screens.
The screens are separated by commas.
Each screen is shown as 6 values: its number, its x-coordinate, its
y-coordinate, its width, its height and if it is currently selected
(1=true, 0=false).
.It Ic select ( Cm \- | Ar name | Ar number ) Pq Ic C\-t \&'
If a number is given, switch to the window with number
.Ar number .
If a name is given, switch to the window in the current group with
name
.Ar name .
Blank the current frame, if
.Cm \-
is given.
.It Ic set Op Ar variable Op Ar value
If no argument is given, output all
.Nm
variables and their values.
.Pp
If one argument is given, output the value of
.Nm
variable
.Ar variable .
Otherwise set
.Ar variable
to
.Ar value .
What values are valid depends on the variable.
See the section
.Sx VARIABLES
later in this document for details.
.It Ic setenv Ar variable value
Set the environment variable
.Ar variable
to
.Ar value .
.Po
Environment variables will be passed to all programs started from
.Nm .
.Pc
.It Ic sfdump
Output all frames similar to
.Ic fdump ,
but not limited to one screen, but all screens at once and with the
screen number after each frame.
.It Ic sfrestore Ar frames
Replace the current frames with the ones specified in
.Ar frames
in the format as generated by
.Ic sfdump .
.It Ic shrink
Shrink the current frame to the size of the current window with in.
.It Ic split Oo Ar split Oc Pq Ic C\-t s
alias for
.Ic vsplit
.It Ic source Ar file
Read
.Ar file
and execute each line as
.Nm
command.
.It Ic sselect Ar screennumber
Switch to the screen
.Ar screennumber .
(If you have multiple physical ones.)
.It Ic startup_message Cm ( on | off )
Select whether
.Nm
will show a startup message or not.
This command is deprecated, please use the
.Va startupmessage
variable instead.
.It Ic swap Ar dest-frame Oo Ar src-frame Oc Pq Ic C\-t x
Exchange the window in
.Ar src\-frame
(or the current frame if there is no second argument) with the window
.Ar dest\-frame
(or ask interactively which frame to swap with if there is no argument).
.It Ic time Pq Ic C\-t a
Output current data and time.
.It Ic title Ar newname Pq Ic C\-t A
Overwrite the title of the current window with
.Ar newname .
All following
.Nm
commands will only know the window under the new name.
.It Ic tmpwm Ar tmpwm
Temporarily give control over to the other window manager
.Ar tmpwm ,
reclaiming control when that WM terminates.
.It Ic unalias Ar alias
Remove the alias
.Ar alias .
.It Ic unbind Ar key
alias for
.Dl Ic undefinekey Ar root key
.It Ic undefinekey Ar keymap key
Remove the binding for
.Ar key
from
.Ar keymap .
.It Ic undo Pq Ic C\-t _ , C\-t u
Un\-do the last change to the frameset.
(Like splitting, resizing, deleting, ...)
.Pp
The amount of steps that can be undone is specified by the variable
.Va maxundos .
.It Ic unmanage Op Ar name
Add
.Ar name
to the list of unmanaged windows.
Thus, windows of this name will not be managed but allowed to choose
their position themselves.
.Pp
In non\-interactive mode calling it without arguments will print the list.
.Pp
The list can be cleared again by calling
.Ic clrunmanaged .
.It Ic unsetenv Ar variable
Remove variable
.Ar variable
from the list of environment variables.
.It Ic verbexec Ar cmdline
Spawn a shell executing
.Ar cmdline
after showing a message with the command.
.It Ic version Pq Ic C\-t v
Output version and compile time information.
.It Ic vsplit Oo Ar l Ns Li / Ns Ar p | Ar "pixels-from-top" | Li \- Ns Ar "pixels-from-bottom" Oc Pq Ic C\-t s
Split the current frame into upper frame and a lower frame.
If no parameter is given, split in halves.
If two numbers separated by a slash
.Pq Dq Li /
are given, the upper one is
.Ar l
times the
.Ar p Ns
th part and the lower one
.Pq Ar p Li \- Ar l
times the
.Ar p Ns
th
part of the prior height.
Otherwise the lower one is
.Ar "pixels from bottom"
wide or the upper one
.Ar "pixels from top"
high, depending whether there is a
.Dq Li \-
in front of the number or not.
.It Ic warp Cm ( on | off )
Select if focusing a window moves the rat cursor to the place it had been last
time this window was focused, or not.
This command is deprecated, please set the
.Va warp
variable instead.
.It Ic windows Oo Ar format Oc Pq Ic C\-t w
In interactive mode,
show the list of all windows in the current group for the duration
specified by the variable
.Va msgwait .
If
.Va msgwait
was zero, toggle between indefinitely showing and not showing.
.Pp
The messages are shown in columns or rows depending on the value of
.Va winliststyle
in the format set by
.Ic set Ar winfmt .
The following substitutions happen in format:
.Pp
.Bl -tag -offset 2n -width 2n -compact
.It Li %a
application name (resource name)
.It Li %c
resource class
.It Li %f
frame number
.It Li %g
gravity of the window
.It Li %h
height of the window
.It Li %H
unit to resize the window vertically (height_inc)
.It Li %i
X Window ID
.It Li %p
process ID
.It Li %l
last access number
.It Li %M
string
.Li Maxsize ,
if it specifies a maximum size
.It Li %n
window number
.It Li %s
window status
.Po
.Ql *
is active window,
.Ql +
would be chosen by
.Ic other ,
.Ql \-
otherwise
.Pc
.It Li %S
screen number
.It Li %t
window name
.Po see
.Ic set Ar winname
.Pc ,
.It Li \&%T
the string
.Dq Li Transient ,
if it is a transient window
.It Li %w
width of the window
.It Li %W
unit to resize the window horizontally (width_inc)
.It Li %x
xrandr screen number
.It Li %%
litteral
.Ql %
.El
.Pp
Additionally there can be a positive decimal integer number between the
percent sign and the format string to specify the length this value
should be truncated to if longer.
.Po
For example:
.Li %20t
.Pc
.Pp
In non\-interactive mode, output the list of windows in the current group
line by line.
The format string can be overwritten by the optional parameter
.Ar format .
.El
.Sh VARIABLES
.Nm
variables can be shown and set with
.Ic set .
The following variables are supported:
.Bl -tag -width Ds
.It Cm resizeunit Ar pixels
Set the amount of pixels interactive
.Ic resize
will add/subtract in each step.
.Pp
Default is 5.
.It Cm maxundos Ar number
The maximal amount of step
.Nm
can undo with the
.Ic undo
command.
.Pp
Default is 20.
.It Cm wingravity Li nw | w | sw | n | c | s | ne | e | se
Set the default gravity new normal windows will get.
Possible values are the same as in the
.Ic gravity
command, which changes the gravity of an existing window: cardinal
points or numbers 1 to 9.
.Pp
Default is
.Li nw .
.It Cm maxsizegravity Li nw | w | sw | n | c | s | ne | e | se
Set the default gravity new self-maximized windows will get.
Possible values are the same as in the
.Ic gravity
command, which changes the gravity of an existing window: cardinal
points or numbers 1 to 9.
.Pp
Default is
.Li c .
.It Cm transgravity Li nw | w | sw | n | c | s | ne | e | se
Set the default gravity new transient windows will get.
Possible values are the same as in the
.Ic gravity
command, which changes the gravity of an existing window: cardinal
points or numbers 1 to 9.
.Pp
Default is
.Li c .
.It Cm bargravity Li nw | w | sw | n | c | s | ne | e | se
Select the location where message and prompt bars appear.
.Pp
Default is
.Li ne .
.It Cm font Ar font
Make
.Nm
use font
.Ar font .
.It Cm padding Ar left top right bottom
Set how much space at the borders of the screen will not be used.
.Pp
Default is
.Li 0 0 0 0 .
.It Cm border Ar pixels
Selects how thick the frame around windows is.
.Pp
Default is
.Li 1 .
.It Cm onlyborder Li 0 | 1
Determine whether to show borders
.Pq Li 1
or not
.Pq Li 0
when there is only one frame on the screen.
.Pp
Default is
.Li 1 .
.It Cm barborder Ar pixels
Selects how thick the frame around
.Nm Ap
s
prompt or message windows is.
.Pp
Default is
.Li 1 .
.It Cm inputwidth Ar pixels
Determine the width of the input window.
.Pp
Default is
.Li 200 .
.It Cm barinpadding Li 0 | 1
If there is padding, determines whether the bar appears at the edge of
the screen
.Pq Li 1
or at the edge of the window area
.Pq Li 0 .
.Pp
Default is
.Li 0 .
.It Cm topkmap Ar kmap
Make
.Ar kmap
the top keymap
.Nm
grabs directly.
.Pp
The default value is
.Li top .
.It Cm waitcursor Li 0 | 1
Determine whether to change the rat cursor when waiting for a key
.Pq Li 1
or not
.Pq Li 0
See
.Ic readkey
and
.Ic describekey .
.Pp
Default is
.Li 1 .
.It Cm winfmt Ar format
Choose the default format for the the
.Ic windows
command.
.Pp
Default is
.Li %n%s%t .
.It Cm winname Li title | name | class
Choose what is considered the "name" of the window by
.Nm :
.Pp
.Bl -tag -width Ds -compact
.It title
The title of the window.
.It name
The resource name of the window.
.It class
The resource class i.e. the name of the application.
.El
.Pp
Default is
.Li title .
.It Cm fgcolor Ar color
The foreground color of the windows
.Nm
creates.
.Pp
Default is
.Li black .
.It Cm bgcolor Ar color
The background color of the windows
.Nm
creates.
.Pp
Default is
.Li white .
.It Cm fwcolor Ar color
The border color of the focused window.
.Pp
Default is
.Li black .
.It Cm bwcolor Ar color
The border color of unfocused windows.
.Pp
Default is
.Li black .
.It Cm barpadding Ar x y
Set horizontal padding of
.Nm
windows to
.Ar x
and vertical padding to
.Ar y .
.Pp
Default is
.Li 4 0 .
.It Cm winliststyle Li row | column
Determines whether windows are shown in rows or in columns.
.Pp
Default is column.
.It Cm framesels Ar selectors
Override the frame selectors
.Ic fselect
uses.
The first character is the selector for the first frame,
the second character is the selector for the second frame and so on.
.Pp
Using this variable, one can directly access more than 10 frames.
.Pp
Default is an empty string, which is equivalent to "0123456789".
.It Cm historysize Ar number
Specify maximum number of values kept in input history.
.Pp
Default is
.Li 20 .
.It Cm historycompaction Li 0 | 1
Decide if new input lines added to history delete
older equal lines from history.
.Pp
Default is
.Li 1
(on).
.It Cm historyexpansion Li 0 | 1
Decide if history expansion using ! is available.
(Can only be activated when compiled with readline's libhistory.)
.It Cm msgwait Ar seconds
The duration the message window is shown.
If
.Ar seconds
is zero, wait infinitely.
.It Cm framemsgwait Ar seconds
The duration the
.Ql Current frame
indicator is shown.
If
.Ar seconds
is zero, wait until the next interactive command.
If
.Ar seconds
is
.Li -1 ,
don't show any message.
.It Cm startupmessage Li 0 | 1
Decide whether to show a greeting message at startup.
.It Cm warp Li 0 | 1
Decide if focusing a window moves the rat cursor to the place it had
been last time this window was focused, or not.
.Pp
Default is
.Li 0
(off).
.It Cm rudeness Ar number
Show or set what kind of windows are allowed to jostle into the
foreground.
.sp
.Ar number
is a bitwise OR of the following values:
.Pp
.Bl -tag -offset 2n -width 2n -compact
.It 1
Transient windows may raise.
.It 2
Normal windows may raise.
.It 4
New transient windows end up in the foreground.
.It 8
New normal windows end up in the foreground.
.El
.Pp
Default is all allowed i.e.\& 15.
.El
.Sh FILES
.Bl -tag -width "%%sysconfdir%%/ratpoisonrc" -compact
.It Pa ~/.ratpoisonrc
Configuration file read at startup time, if present.
.It Pa %%sysconfdir%%/ratpoisonrc
Fallback configuration file, if
.Pa ~/.ratpoisonrc
is not found.
.El
.Sh EXIT STATUS
.Ex -std
.Sh AUTHORS
.An -nosplit
Upstream author is
.An Shawn Betts Aq Mt sabetts@gmail.com .
.Pp
See the
.Pa %%docdir%%/AUTHORS
file for other contributors.
.Pp
This manual page was written by
.An Bernhard R. Link Aq Mt brlink@debian.org .
The conversion to the
.Xr mdoc 7
language
.Pq Lk http://mdocml.bsd.lv
was done by
.An Jeremie Courreges-Anglas Aq Mt jca@wxcvbn.org .
.Sh BUGS
Please report any bug you find to the ratpoison mailing-list,
.Aq Mt ratpoison-devel@nongnu.org .



================================================
FILE: doc/sample.ratpoisonrc
================================================
# This is a sample .ratpoisonrc file
# Copyright (C) 2003, 2004 Shawn Betts
#
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright

# Set the prefix key to that of screen's default
escape C-a

# Gets rid of that ugly crosshairs default cursor
# and set the background to black
exec xsetroot -solid black -cursor_name left_ptr

# Emulate screen by starting with a new xterm
exec xterm

# Bind e to our favorite editor
bind e exec emacs

# bind s to interactively run a surfraw query on freshmeat
bind s colon exec xterm -e freshmeat

# bind b (`b' for browse) to interactively ask for an URL to open
bind b colon exec mozilla http://www.

# Use the name of the program rather than the title in the window list
defwinname name

# bind M-! to store the current frame layout in slot #1
bind M-exclam exec ratpoison -c "setenv fs1 `ratpoison -c 'fdump'`"

#bind M-1 to restore the frame layout in slot #1
bind M-1 exec ratpoison -c "frestore `ratpoison -c 'getenv fs1'`"

# Do the same for slot #2 and bind it to M-@ and M-2, respectively.
bind M-at exec ratpoison -c "setenv fs2 `ratpoison -c 'fdump'`"
bind M-2 exec ratpoison -c "frestore `ratpoison -c 'getenv fs2'`"

# Give ourselves another slot on M-# and M-3, respectively.
bind M-numbersign exec ratpoison -c "setenv fs3 `ratpoison -c 'fdump'`"
bind M-3 exec ratpoison -c "frestore `ratpoison -c 'getenv fs3'`"

# Here's a hack from John Meacham:

bind a exec ratpoison -d :0.0 -c "echo `date +'%r - %A %n    %D - %B'`  `cal | tail -n +2 | sed -e 's/^Su/\n\n Su/' -e 's/.*/ & /' -e \"s/\ $(date +%e)\ /\<$(date +%e)\>/\"`"

# it produces output like the following in the message window, very handy:
#         +-----------------------+
#         |05:05:24 PM - Tuesday  |
#         |   09/09/03 - September|
#         |                       |
#         |Su Mo Tu We Th Fr Sa   |
#         |    1  2  3  4  5  6   |
#         | 7  8< 9>10 11 12 13   |
#         |14 15 16 17 18 19 20   |
#         |21 22 23 24 25 26 27   |
#         |28 29 30               |
#         +-----------------------+



================================================
FILE: m4/ax_check_compile_flag.m4
================================================
# ===========================================================================
#  https://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html
# ===========================================================================
#
# SYNOPSIS
#
#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
#
# DESCRIPTION
#
#   Check whether the given FLAG works with the current language's compiler
#   or gives an error.  (Warnings, however, are ignored)
#
#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
#   success/failure.
#
#   If EXTRA-FLAGS is defined, it is added to the current language's default
#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
#   force the compiler to issue an error when a bad flag is given.
#
#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
#
#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.
#
# LICENSE
#
#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#   Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program. If not, see <https://www.gnu.org/licenses/>.
#
#   As a special exception, the respective Autoconf Macro's copyright owner
#   gives unlimited permission to copy, distribute and modify the configure
#   scripts that are the output of Autoconf when processing the Macro. You
#   need not follow the terms of the GNU General Public License when using
#   or distributing such scripts, even though portions of the text of the
#   Macro appear in them. The GNU General Public License (GPL) does govern
#   all other use of the material that constitutes the Autoconf Macro.
#
#   This special exception to the GPL applies to versions of the Autoconf
#   Macro released by the Autoconf Archive. When you make and distribute a
#   modified version of the Autoconf Macro, you may extend this special
#   exception to the GPL to apply to your modified version as well.

#serial 5

AC_DEFUN([AX_CHECK_COMPILE_FLAG],
[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
    [AS_VAR_SET(CACHEVAR,[yes])],
    [AS_VAR_SET(CACHEVAR,[no])])
  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
AS_VAR_IF(CACHEVAR,yes,
  [m4_default([$2], :)],
  [m4_default([$3], :)])
AS_VAR_POPDEF([CACHEVAR])dnl
])dnl AX_CHECK_COMPILE_FLAGS



================================================
FILE: m4/codeset.m4
================================================
# codeset.m4 serial 4 (gettext-0.18)
dnl Copyright (C) 2000-2002, 2006, 2008-2010 Free Software Foundation, Inc.
dnl This file is free software; the Free Software Foundation
dnl gives unlimited permission to copy and/or distribute it,
dnl with or without modifications, as long as this notice is preserved.

dnl From Bruno Haible.

AC_DEFUN([AM_LANGINFO_CODESET],
[
  AC_CACHE_CHECK([for nl_langinfo and CODESET], [am_cv_langinfo_codeset],
    [AC_TRY_LINK([#include <langinfo.h>],
      [char* cs = nl_langinfo(CODESET); return !cs;],
      [am_cv_langinfo_codeset=yes],
      [am_cv_langinfo_codeset=no])
    ])
  if test $am_cv_langinfo_codeset = yes; then
    AC_DEFINE([HAVE_LANGINFO_CODESET], [1],
      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
  fi
])



================================================
FILE: src/actions.h
================================================
/* Prototypes of all actions that can be performed with keystrokes.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_ACTIONS_H
#define _RATPOISON_ACTIONS_H 1

#include "ratpoison.h"

/* The structure returned by a command. */
typedef struct cmdret
{
  char *output;
  int success;
} cmdret;

void clear_frame_undos (void);
rp_keymap *find_keymap (char *name);
void init_user_commands(void);
void initialize_default_keybindings (void);
cmdret *command (int interactive, char *data);
cmdret *cmdret_new (int success, char *fmt, ...);
void cmdret_free (cmdret *ret);
void free_user_commands (void);
void free_aliases (void);
void free_keymaps (void);
char *wingravity_to_string (int g);
rp_action* find_keybinding (KeySym keysym, unsigned int state, rp_keymap *map);
rp_action* find_keybinding_by_action (char *action, rp_keymap *map);


#endif /* ! _RATPOISON_ACTIONS_H */



================================================
FILE: src/bar.c
================================================
/* Functionality for a bar listing the windows currently managed.
 *
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#ifdef USE_XFT_FONT
#include <X11/Xft/Xft.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ratpoison.h"

/* Possible values for bar_is_raised status. */
#define BAR_IS_HIDDEN  0
#define BAR_IS_WINDOW_LIST 1
#define BAR_IS_GROUP_LIST  2
#define BAR_IS_MESSAGE     3

/* A copy of the last message displayed in the message bar. */
static char *last_msg = NULL;
static int last_mark_start = 0;
static int last_mark_end = 0;

static void marked_message_internal (char *msg, int mark_start, int mark_end);

/* Reset the alarm to auto-hide the bar in BAR_TIMEOUT seconds. */
static void
reset_alarm (void)
{
  alarm (defaults.bar_timeout);
  alarm_signalled = 0;
}

/* Hide the bar from sight. */
int
hide_bar (rp_screen *s)
{
  if (s->bar_is_raised)
    {
      s->bar_is_raised = 0;
      XUnmapWindow (dpy, s->bar_window);

      /* Possibly restore colormap. */
      if (current_window())
	{
	  XUninstallColormap (dpy, s->def_cmap);
	  XInstallColormap (dpy, current_window()->colormap);
	}

      return 1;
    }

  return 0;
}

/* Show window listing in bar. */
int
show_bar (rp_screen *s, char *fmt)
{
  if (!s->bar_is_raised)
    {
      s->bar_is_raised = BAR_IS_WINDOW_LIST;
      XMapRaised (dpy, s->bar_window);
      update_window_names (s, fmt);

      /* Switch to the default colormap */
      if (current_window())
	XUninstallColormap (dpy, current_window()->colormap);
      XInstallColormap (dpy, s->def_cmap);

      reset_alarm();
      return 1;
    }

  /* If the bar is raised we still need to display the window
     names. */
  update_window_names (s, fmt);
  return 0;
}

/* Show group listing in bar. */
int
show_group_bar (rp_screen *s)
{
  if (!s->bar_is_raised)
    {
      s->bar_is_raised = BAR_IS_GROUP_LIST;
      XMapRaised (dpy, s->bar_window);
      update_group_names (s);

      /* Switch to the default colormap */
      if (current_window())
	XUninstallColormap (dpy, current_window()->colormap);
      XInstallColormap (dpy, s->def_cmap);

      reset_alarm();
      return 1;
    }

  /* If the bar is raised we still need to display the window
     names. */
  update_group_names (s);
  return 0;
}

int
bar_x (rp_screen *s, int width)
{
  int x = 0;

  switch (defaults.bar_location)
    {
    case NorthWestGravity:
    case WestGravity:
    case SouthWestGravity:
      x = s->left + (defaults.bar_in_padding ? 0 : defaults.padding_left);
      break;
    case NorthGravity:
    case CenterGravity:
    case SouthGravity:
      x = s->left + (s->width - width - defaults.bar_border_width * 2) / 2
          - (defaults.bar_in_padding ? 0 : defaults.padding_left);
      break;
    case NorthEastGravity:
    case EastGravity:
    case SouthEastGravity:
      x = s->left + s->width - width - defaults.bar_border_width * 2
          - (defaults.bar_in_padding ? 0 : defaults.padding_right);
      break;
    }

  return x;
}

int
bar_y (rp_screen *s, int height)
{
  int y = 0;

  switch (defaults.bar_location)
    {
    case NorthEastGravity:
    case NorthGravity:
    case NorthWestGravity:
      y = s->top + (defaults.bar_in_padding ? 0 : defaults.padding_top);
      break;
    case EastGravity:
    case CenterGravity:
    case WestGravity:
      y = s->top + (s->height - height
           - defaults.bar_border_width * 2) / 2
	   - (defaults.bar_in_padding ? 0 : defaults.padding_top);
      break;
    case SouthEastGravity:
    case SouthGravity:
    case SouthWestGravity:
      y = s->top + (s->height - height
           - defaults.bar_border_width * 2)
 	   - (defaults.bar_in_padding ? 0 : defaults.padding_top);
      break;
    }

  return y;
}

void
update_bar (rp_screen *s)
{
  if (s->bar_is_raised == BAR_IS_WINDOW_LIST) {
    update_window_names (s, defaults.window_fmt);
    return;
  }

  if (s->bar_is_raised == BAR_IS_GROUP_LIST) {
    update_group_names (s);
    return;
  }

  if (s->bar_is_raised == BAR_IS_HIDDEN)
    return;

  redraw_last_message();
}

/* Note that we use marked_message_internal to avoid resetting the
   alarm. */
void
update_window_names (rp_screen *s, char *fmt)
{
  struct sbuf *bar_buffer;
  int mark_start = 0;
  int mark_end = 0;
  char *delimiter;

  if (s->bar_is_raised != BAR_IS_WINDOW_LIST) return;

  delimiter = (defaults.window_list_style == STYLE_ROW) ? " " : "\n";

  bar_buffer = sbuf_new (0);

  get_window_list (fmt, delimiter, bar_buffer, &mark_start, &mark_end);
  marked_message (sbuf_get (bar_buffer), mark_start, mark_end);

  sbuf_free (bar_buffer);
}

/* Note that we use marked_message_internal to avoid resetting the
   alarm. */
void
update_group_names (rp_screen *s)
{
  struct sbuf *bar_buffer;
  int mark_start = 0;
  int mark_end = 0;
  char *delimiter;

  if (s->bar_is_raised != BAR_IS_GROUP_LIST) return;

  delimiter = (defaults.window_list_style == STYLE_ROW) ? " " : "\n";

  bar_buffer = sbuf_new (0);

  get_group_list (delimiter, bar_buffer, &mark_start, &mark_end);
  marked_message_internal (sbuf_get (bar_buffer), mark_start, mark_end);

  sbuf_free (bar_buffer);
}

void
message (char *s)
{
  marked_message (s, 0, 0);
}

void
marked_message_printf (int mark_start, int mark_end, char *fmt, ...)
{
  char *buffer;
  va_list ap;

  va_start (ap, fmt);
  buffer = xvsprintf (fmt, ap);
  va_end (ap);

  marked_message (buffer, mark_start, mark_end);
  free (buffer);
}

static int
count_lines (char* msg, int len)
{
  int ret = 1;
  int i;

  if (len < 1)
    return 1;

  for(i=0; i<len; i++)
    {
      if (msg[i] == '\n') ret++;
    }

  return ret;
}


static int
max_line_length (char* msg)
{
  rp_screen *s = rp_current_screen;
  size_t i;
  size_t start;
  int ret = 0;

  /* Count each line and keep the length of the longest one. */
  for(start=0, i=0; i <= strlen(msg); i++)
    {
      if(msg[i] == '\n' || msg[i] == '\0')
        {
          int current_width;

          /* Check if this line is the longest so far. */
          current_width = rp_text_width (s, msg + start, i - start);
          if(current_width > ret)
            {
              ret = current_width;
            }

          /* Update the start of the new line. */
          start = i + 1;
        }
    }

  return ret;
}

static int
pos_in_line (char* msg, int pos)
{
  int ret;
  int i;

  if(pos <= 0)
    return 0;

  /* Go backwards until we hit the beginning of the string or a new
     line. */
  ret = 0;
  for(i=pos-1; i>=0; ret++, i--)
    {
      if(msg[i]=='\n')
        break;
    }

  return ret;
}

static int
line_beginning (char* msg, int pos)
{
  int ret = 0;
  int i;

  if(pos <= 0)
    return 0;

  /* Go backwards until we hit a new line or the beginning of the
     string. */
  for(i=pos-1; i>=0; --i)
    {
      if (msg[i]=='\n')
        {
          ret = i + 1;
          break;
        }
    }

  return ret;
}

static void
draw_partial_string (rp_screen *s, char *msg, int len,
                     int x_offset, int y_offset, int style)
{
  rp_draw_string (s, s->bar_window, style,
                  defaults.bar_x_padding + x_offset,
                  defaults.bar_y_padding + FONT_ASCENT(s)
                  + y_offset * FONT_HEIGHT (s),
                  msg, len + 1);
}

#define REASON_NONE    0x00
#define REASON_STYLE   0x01
#define REASON_NEWLINE 0x02
static void
draw_string (rp_screen *s, char *msg, int mark_start, int mark_end)
{
  int i, start;
  int x_offset, y_offset;          /* Base coordinates where to print. */
  int print_reason = REASON_NONE;  /* Should we print something? */
  int style = STYLE_NORMAL, next_style = STYLE_NORMAL;
  int msg_len, part_len;

  start = 0;
  x_offset = y_offset = 0;
  msg_len = strlen (msg);

  /* Walk through the string, print each part. */
  for (i = 0; i < msg_len; ++i)
    {

      /* Should we ignore style hints? */
      if (mark_start != mark_end)
        {
          if (i == mark_start)
            {
              next_style = STYLE_INVERSE;
              if (i > start)
                print_reason |= REASON_STYLE;
            }
          else if (i == mark_end)
            {
              next_style = STYLE_NORMAL;
              if (i > start)
                print_reason |= REASON_STYLE;
            }
        }

      if (msg[i] == '\n')
          print_reason |= REASON_NEWLINE;

      if (print_reason != REASON_NONE)
        {
          /* Strip the trailing newline if necessary. */
          part_len = i - start - ((print_reason & REASON_NEWLINE) ? 1 : 0);

          draw_partial_string (s, msg + start, part_len,
                               x_offset, y_offset, style);

          /* Adjust coordinates. */
          if (print_reason & REASON_NEWLINE)
            {
              x_offset = 0;
              y_offset++;
              /* Skip newline. */
              start = i + 1;
            }
          else
            {
              x_offset += rp_text_width (s, msg + start, part_len);
              start = i;
            }

          print_reason = REASON_NONE;
        }
      style = next_style;
    }

  part_len = i - start - 1;

  /* Print the last line. */
  draw_partial_string (s, msg + start, part_len, x_offset, y_offset, style);

  XSync (dpy, False);
}
#undef REASON_NONE
#undef REASON_STYLE
#undef REASON_NEWLINE

/* Move the marks if they are outside the string or if the start is
   after the end. */
static void
correct_mark (int msg_len, int *mark_start, int *mark_end)
{
  /* Make sure the marks are inside the string. */
  if (*mark_start < 0)
    *mark_start = 0;

  if (*mark_end < 0)
    *mark_end = 0;

  if (*mark_start > msg_len)
    *mark_start = msg_len;

  if (*mark_end > msg_len)
    *mark_end = msg_len;

  /* Make sure the marks aren't reversed. */
  if (*mark_start > *mark_end)
    {
      int tmp;
      tmp = *mark_start;
      *mark_start = *mark_end;
      *mark_end = tmp;
    }

}

/* Raise the bar and put it in the right spot */
static void
prepare_bar (rp_screen *s, int width, int height)
{
  width = width < s->width ? width : s->width;
  height = height < s->height ? height : s->height;
  XMoveResizeWindow (dpy, s->bar_window,
                     bar_x (s, width), bar_y (s, height),
                     width, height);

  /* Map the bar if needed */
  if (!s->bar_is_raised)
    {
      s->bar_is_raised = BAR_IS_MESSAGE;
      XMapRaised (dpy, s->bar_window);

      /* Switch to the default colormap */
      if (current_window())
	XUninstallColormap (dpy, current_window()->colormap);
      XInstallColormap (dpy, s->def_cmap);
    }

  XRaiseWindow (dpy, s->bar_window);
  XClearWindow (dpy, s->bar_window);
  XSync (dpy, False);
}

static void
get_mark_box (char *msg, size_t mark_start, size_t mark_end,
              int *x, int *y, int *width, int *height)
{
  rp_screen *s = rp_current_screen;
  int start, end;
  int mark_end_is_new_line = 0;
  int start_line;
  int end_line;
  int start_pos_in_line;
  int end_pos_in_line;
  int start_line_beginning;
  int end_line_beginning;

  /* If the mark_end is on a new line or the end of the string, then
     back it up one character. */
  if (msg[mark_end-1] == '\n' || mark_end == strlen (msg))
    {
      mark_end--;
      mark_end_is_new_line = 1;
    }

  start_line = count_lines(msg, mark_start);
  end_line = count_lines(msg, mark_end);

  start_pos_in_line = pos_in_line(msg, mark_start);
  end_pos_in_line = pos_in_line(msg, mark_end);

  start_line_beginning = line_beginning(msg, mark_start);
  end_line_beginning = line_beginning(msg, mark_end);

  PRINT_DEBUG (("start_line = %d, end_line = %d\n", start_line, end_line));
  PRINT_DEBUG (("start_line_beginning = %d, end_line_beginning = %d\n",
                start_line_beginning, end_line_beginning));

  if (mark_start == 0 || start_pos_in_line == 0)
    start = 0;
  else
    start = rp_text_width (s, &msg[start_line_beginning],
                           start_pos_in_line) + defaults.bar_x_padding;

  end = rp_text_width (s, &msg[end_line_beginning],
                       end_pos_in_line) + defaults.bar_x_padding * 2;

  if (mark_end != strlen (msg))
    end -= defaults.bar_x_padding;

  /* A little hack to highlight to the end of the line, if the
     mark_end is at the end of a line. */
  if (mark_end_is_new_line)
    {
      *width = max_line_length(msg) + defaults.bar_x_padding * 2;
    }
  else
    {
      *width = end - start;
    }

  *x = start;
  *y = (start_line - 1) * FONT_HEIGHT (s) + defaults.bar_y_padding;
  *height = (end_line - start_line + 1) * FONT_HEIGHT (s);
}

static void
draw_box (rp_screen *s, int x, int y, int width, int height)
{
  XGCValues lgv;
  GC lgc;
  unsigned long mask;

  lgv.foreground = rp_glob_screen.fg_color;
  mask = GCForeground;
  lgc = XCreateGC(dpy, s->root, mask, &lgv);

  XFillRectangle (dpy, s->bar_window, lgc,
                  x, y, width, height);
  XFreeGC (dpy, lgc);
}

static void
draw_mark (rp_screen *s, char *msg, int mark_start, int mark_end)
{
  int x, y, width, height;

  /* when this happens, there is no mark. */
  if (mark_end == 0 || mark_start == mark_end)
    return;

  get_mark_box (msg, mark_start, mark_end,
                &x, &y, &width, &height);
  draw_box (s, x, y, width, height);
}

static void
update_last_message (char *msg, int mark_start, int mark_end)
{
  free (last_msg);
  last_msg = xstrdup (msg);
  last_mark_start = mark_start;
  last_mark_end = mark_end;
}

void
marked_message (char *msg, int mark_start, int mark_end)
{
  /* Schedule the bar to be hidden after some amount of time. */
  reset_alarm ();
  marked_message_internal (msg, mark_start, mark_end);
}

static void
marked_message_internal (char *msg, int mark_start, int mark_end)
{
  rp_screen *s = rp_current_screen;
  int num_lines;
  int width;
  int height;

  PRINT_DEBUG (("msg = %s\n", msg?msg:"NULL"));
  PRINT_DEBUG (("mark_start = %d, mark_end = %d\n", mark_start, mark_end));

  /* Calculate the width and height of the window. */
  num_lines = count_lines (msg, strlen(msg));
  width = defaults.bar_x_padding * 2 + max_line_length(msg);
  height = FONT_HEIGHT (s) * num_lines + defaults.bar_y_padding * 2;

  prepare_bar (s, width, height);

  /* Draw the mark over the designated part of the string. */
  correct_mark (strlen (msg), &mark_start, &mark_end);
  draw_mark (s, msg, mark_start, mark_end);

  draw_string (s, msg, mark_start, mark_end);

  /* Keep a record of the message. */
  update_last_message (msg, mark_start, mark_end);
}

/* Use this just to update the bar. show_last_message will draw it and
   leave it up for a period of time. */
void
redraw_last_message (void)
{
  char *msg;

  if (last_msg == NULL) return;

  /* A little kludge to avoid last_msg in marked_message from being
     strdup'd right after freeing the pointer. Note: in this case
     marked_message's msg arg would have been the same as
     last_msg.  */
  msg = xstrdup (last_msg);
  marked_message_internal (msg, last_mark_start, last_mark_end);
  free (msg);
}

void
show_last_message (void)
{
  redraw_last_message();
  reset_alarm();
}

/* Free any memory associated with the bar. */
void
free_bar (void)
{
  free (last_msg);
  last_msg = NULL;
}



================================================
FILE: src/bar.h
================================================
/* functions for managing the program bar
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_BAR_H
#define _RATPOISON_BAR_H 1

void update_window_names (rp_screen *s, char *fmt);
void update_group_names (rp_screen *s);
void update_bar (rp_screen *s);
int show_bar (rp_screen *s, char *fmt);
int show_group_bar (rp_screen *s);
int hide_bar (rp_screen *s);
int bar_y (rp_screen *s, int height);
int bar_x (rp_screen *s, int width);

void message (char *s);
void marked_message (char *s, int mark_start, int mark_end);
void marked_message_printf (int mark_start, int mark_end, char *fmt, ...);
void redraw_last_message (void);
void show_last_message (void);
void free_bar (void);

#endif /* ! _RATPOISON_BAR_H */



================================================
FILE: src/communications.c
================================================
/* communications.c -- Send commands to a running copy of ratpoison.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/Xproto.h>

#include <string.h>

#include "ratpoison.h"


/* Sending commands to ratpoison */
static int
receive_command_result (Window w)
{
  int query;
  int return_status = RET_FAILURE;
  Atom type_ret;
  int format_ret;
  unsigned long nitems;
  unsigned long bytes_after;
  unsigned char *result = NULL;

  /* First, find out how big the property is. */
  query = XGetWindowProperty (dpy, w, rp_command_result,
			      0, 0, False, xa_string,
			      &type_ret, &format_ret, &nitems, &bytes_after,
			      &result);

  /* Failed to retrieve property. */
  if (query != Success || result == NULL)
    {
      PRINT_DEBUG (("failed to get command result length\n"));
      return return_status;
    }

  /* XGetWindowProperty always allocates one extra byte even if
     the property is zero length. */
  XFree (result);

  /* Now that we have the length of the message, we can get the
     whole message. */
  query = XGetWindowProperty (dpy, w, rp_command_result,
			      0, (bytes_after / 4) + (bytes_after % 4 ? 1 : 0),
			      True, xa_string, &type_ret, &format_ret, &nitems,
			      &bytes_after, &result);

  /* Failed to retrieve property. */
  if (query != Success || result == NULL)
    {
      PRINT_DEBUG (("failed to get command result\n"));
      return return_status;
    }

  /*
   * We can receive:
   * - an empty string, indicating a success but no output
   * - a string starting with '1', indicating a success and an output
   * - a string starting with '0', indicating a failure and an optional output
   */
  switch (result[0])
    {
    case '\0': /* Command succeeded but no string to print */
      return_status = RET_SUCCESS;
      break;
    case '0': /* Command failed, don't print an empty line if no explanation
		 was given */
      if (result[1] != '\0')
	fprintf (stderr, "%s\n", &result[1]);
      return_status = RET_FAILURE;
      break;
    case '1': /* Command succeeded, print the output */
      printf ("%s\n", &result[1]);
      return_status = RET_SUCCESS;
      break;
    default: /* We probably got junk, so ignore it */
      return_status = RET_FAILURE;
    }

  /* Free the result. */
  XFree (result);

  return return_status;
}

int
send_command (unsigned char interactive, unsigned char *cmd)
{
  Window w, root;
  int done = 0, return_status = RET_FAILURE;
  struct sbuf *s;

  s = sbuf_new(0);
  sbuf_printf(s, "%c%s", interactive, cmd);

  root = RootWindow (dpy, DefaultScreen (dpy));
  w = XCreateSimpleWindow (dpy, root, 0, 0, 1, 1, 0, 0, 0);

  /* Select first to avoid race condition */
  XSelectInput (dpy, w, PropertyChangeMask);

  XChangeProperty (dpy, w, rp_command, xa_string,
                   8, PropModeReplace, (unsigned char*)sbuf_get(s), strlen ((char *)cmd) + 2);

  XChangeProperty (dpy, root,
                   rp_command_request, XA_WINDOW,
                   8, PropModeAppend, (unsigned char *)&w, sizeof (Window));

  sbuf_free (s);

  while (!done)
    {
      XEvent ev;

      XMaskEvent (dpy, PropertyChangeMask, &ev);
      if (ev.xproperty.atom == rp_command_result
          && ev.xproperty.state == PropertyNewValue)
        {
	  return_status = receive_command_result(ev.xproperty.window);
	  done = 1;
        }
    }

  XDestroyWindow (dpy, w);

  return return_status;
}



================================================
FILE: src/communications.h
================================================
/* communications.h -- Send commands to a running copy of ratpoison.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_COMMUNICATIONS_H
#define _RATPOISON_COMMUNICATIONS_H 1

int send_command (unsigned char interactive, unsigned char *cmd);

#endif /* ! _RATPOISON_COMMUNICATIONS_H */



================================================
FILE: src/completions.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#define _GNU_SOURCE
#include <string.h>

#include "ratpoison.h"
#include "completions.h"

rp_completions *
completions_new (completion_fn list_fn, enum completion_styles style)
{
  rp_completions *c;

  c = xmalloc (sizeof(rp_completions));

  INIT_LIST_HEAD (&c->completion_list);
  c->complete_fn = list_fn;
  c->last_match = NULL;
  c->partial = NULL;
  c->virgin = 1;
  c->style = style;

  return c;
}

void
completions_free (rp_completions *c)
{
  struct sbuf *cur;
  struct list_head *tmp, *iter;

  /* Clear our list */
  list_for_each_safe_entry (cur, iter, tmp, &c->completion_list, node)
    {
      list_del (&cur->node);
      sbuf_free (cur);
    }

  /* Free the partial string. */
  free (c->partial);

  free (c);
}

static void
completions_assign (rp_completions *c, struct list_head *new_list)
{
  struct sbuf *cur;
  struct list_head *tmp, *iter;

  /* Clear our list */
  list_for_each_safe_entry (cur, iter, tmp, &c->completion_list, node)
    {
      list_del (&cur->node);
      sbuf_free (cur);
    }

  /* splice the list into completion_list. Note that we SHOULDN'T free
     new_list, because they share the same memory. */
  INIT_LIST_HEAD (&c->completion_list);
  list_splice (new_list, &c->completion_list);

  list_first (c->last_match, &c->completion_list, node);
}

static void
completions_update (rp_completions *c, char *partial)
{
  struct list_head *new_list;

  new_list = c->complete_fn (partial);

  c->virgin = 0;
  free (c->partial);
  c->partial = xstrdup (partial);

  completions_assign (c, new_list);

  /* Free the head structure for our list. */
  free (new_list);
}


/* Return true if completion is an alternative for partial string,
   given the style used. */
static int
completions_match(rp_completions *c, char *completion, char *partial)
{
  int match = 0;

  switch (c->style)
    {
    case BASIC:
      match = str_comp (completion, partial, strlen(partial));
      break;
    case SUBSTRING:
      match = (strcasestr (completion, partial) != NULL);
      break;
    }

  return match;
}

static char *
completions_prev_match (rp_completions *c)
{
  struct sbuf *cur;

  /* search forward from our last match through the list looking for
     another match. */
  for (cur = list_prev_entry (c->last_match, &c->completion_list, node);
       cur != c->last_match;
       cur = list_prev_entry (cur, &c->completion_list, node))
    {
      if (completions_match (c, sbuf_get (cur), c->partial))
        {
          /* We found a match so update our last_match pointer and
             return the string. */
          c->last_match = cur;
          return sbuf_get (cur);
        }
    }

  return NULL;
}

static char *
completions_next_match (rp_completions *c)
{
  struct sbuf *cur;

  /* search forward from our last match through the list looking for
     another match. */
  for (cur = list_next_entry (c->last_match, &c->completion_list, node);
       cur != c->last_match;
       cur = list_next_entry (cur, &c->completion_list, node))
    {
      if (completions_match (c, sbuf_get (cur), c->partial))
        {
          /* We found a match so update our last_match pointer and
             return the string. */
          c->last_match = cur;
          return sbuf_get (cur);
        }
    }

  return NULL;
}

/* Return a completed string that starts with partial. */
char *
completions_complete (rp_completions *c, char *partial, int direction)
{
  if (c->virgin)
    {
      completions_update (c, partial);

      /* Since it's never been completed on and c->last_match points
         to the first element of the list which may be a match. So
         check it. FIXME: This is a bit of a hack. */
      if (c->last_match == NULL)
        return NULL;

      /* c->last_match contains the first match in the forward
         direction. So if we're looking for the previous match, then
         check the previous element from last_match. */
      if (direction == COMPLETION_PREVIOUS)
        c->last_match = list_prev_entry (c->last_match, &c->completion_list, node);

      /* Now check if last_match is a match for partial. */
      if (completions_match (c, sbuf_get (c->last_match), c->partial))
        return sbuf_get (c->last_match);
    }

  if (c->last_match == NULL)
    return NULL;

  /* Depending on the direction, find our "next" match. */
  if (direction == COMPLETION_NEXT)
    return completions_next_match (c);

  /* Otherwise get the previous match */
  return completions_prev_match (c);
}



================================================
FILE: src/completions.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_COMPLETIONS_H
#define _RATPOISON_COMPLETIONS_H 1

char *completions_complete (rp_completions *c, char *partial, int direction);
rp_completions *completions_new (completion_fn list_fn, enum completion_styles style);
void completions_free (rp_completions *c);

#endif /* ! _RATPOISON_COMPLETIONS_H */



================================================
FILE: src/conf.h
================================================
/* Config file for ratpoison. Edit these values and recompile.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_CONF_H
#define _RATPOISON_CONF_H 1

#include "data.h"
#include "actions.h"

#define KEY_PREFIX      XK_t
#define MODIFIER_PREFIX RP_CONTROL_MASK

/* This is the abort key when typing input. */
#define INPUT_ABORT_KEY      XK_g
#define INPUT_ABORT_MODIFIER RP_CONTROL_MASK

/* This is the previous history entry key when typing input. */
#define INPUT_PREV_HISTORY_KEY      XK_p
#define INPUT_PREV_HISTORY_MODIFIER RP_CONTROL_MASK

/* This is the next history entry key when typing input. */
#define INPUT_NEXT_HISTORY_KEY      XK_n
#define INPUT_NEXT_HISTORY_MODIFIER RP_CONTROL_MASK

/* Key used to enlarge frame vertically when in resize mode.  */
#define RESIZE_VGROW_KEY      XK_n
#define RESIZE_VGROW_MODIFIER RP_CONTROL_MASK

/* Key used to shrink frame vertically when in resize mode.  */
#define RESIZE_VSHRINK_KEY      XK_p
#define RESIZE_VSHRINK_MODIFIER RP_CONTROL_MASK

/* Key used to enlarge frame horizontally when in resize mode.  */
#define RESIZE_HGROW_KEY      XK_f
#define RESIZE_HGROW_MODIFIER RP_CONTROL_MASK

/* Key used to shrink frame horizontally when in resize mode.  */
#define RESIZE_HSHRINK_KEY      XK_b
#define RESIZE_HSHRINK_MODIFIER RP_CONTROL_MASK

/* Key used to shrink frame to fit it's current window.  */
#define RESIZE_SHRINK_TO_WINDOW_KEY             XK_s
#define RESIZE_SHRINK_TO_WINDOW_MODIFIER        0

/* Key used to exit resize mode.  */
#define RESIZE_END_KEY      XK_Return
#define RESIZE_END_MODIFIER 0

/* Number of history items to store. */
#define INPUT_MAX_HISTORY 50

/* Treat windows with maxsize hints as if they were a transient window
   (don't hide the windows underneath, and center them) */
#define MAXSIZE_WINDOWS_ARE_TRANSIENTS

/* Treat windows with aspect hints as if they were a transient window
   (don't hide the windows underneath, and center them) */
#define ASPECT_WINDOWS_ARE_TRANSIENTS

/* An alias command could recursively call inself infinitely. This
   stops that behavior. */
#define MAX_ALIAS_RECURSIVE_DEPTH 16

/* Pressing a key sends the mouse to the bottom right corner. This
   doesn't work very well yet. */
/* #define HIDE_MOUSE  */

/* When the last window closes, quit ratpoison. */
/* #define AUTO_CLOSE */

/* If for some sick reason you don't want ratpoison to manage a
   window, put its name in this list. These windows get drawn but
   ratpoison won't have any knowledge of them and you won't be able to
   jump to them or give them keyboard focus. This has been added
   mostly for use with hand-helds. */
#define UNMANAGED_WINDOW_LIST "xapm","xclock","xscribble"

/* Maximum depth of a link. Used in the 'link' command. */
#define MAX_LINK_DEPTH 16

/* Bad window messages can be safely ignored now that ratpoison has
   become stable enough. Comment this line if you wish to be notified
   about bad window messages. */
#define IGNORE_BADWINDOW 1

/* This is the name of the first group that is created. */
#define DEFAULT_GROUP_NAME "default"

/* Maximum allowed history size */
#define MAX_HISTORY_SIZE 100

/* The default filename in which to store the history */
#define HISTORY_FILE ".ratpoison_history"

/* Use a visual bell in the input window */
#define VISUAL_BELL 1

/* The name of the root keymap */
#define ROOT_KEYMAP "root"

/* The name of the top level keymap */
#define TOP_KEYMAP "top"

/* The default font */
#define DEFAULT_FONT "-*-fixed-bold-r-normal-*-15-*-*-*-c-*-*-*"
#define BACKUP_FONT "*"

#define DEFAULT_XFT_FONT "Mono-11"

/* maximum xvsprintf result string length for systems with pre-C99 snprintf:
 * on errors that are either permanent or cannot be distinguished from those
 * as libc's snprintf might by returning -1 for too small buffers, at most
 * the double of this value is tried before giving up */
#define MAX_LEGACY_SNPRINTF_SIZE 102400

#endif /* !_ _RATPOISON_CONF_H */



================================================
FILE: src/data.h
================================================
/* our datatypes and global variables
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_DATA_H
#define _RATPOISON_DATA_H

#include "linkedlist.h"
#include "number.h"

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#ifdef USE_XFT_FONT
#include <X11/Xft/Xft.h>
#endif

typedef struct rp_window rp_window;
typedef struct rp_screen rp_screen;
typedef struct rp_global_screen rp_global_screen;
typedef struct rp_action rp_action;
typedef struct rp_keymap rp_keymap;
typedef struct rp_frame rp_frame;
typedef struct rp_child_info rp_child_info;
typedef struct rp_group rp_group;
typedef struct rp_window_elem rp_window_elem;
typedef struct rp_completions rp_completions;
typedef struct rp_input_line rp_input_line;

struct rp_frame
{
  int number;
  int x, y, width, height;

  /* The number of the window that is focused in this frame. */
  int win_number;

  /* For determining the last frame. */
  int last_access;

  /* Boolean that is set when a frame is
     `dedicated' (a.k.a. glued) to one window. */
  unsigned int dedicated;

  struct list_head node;
};

struct rp_window
{
  rp_screen *scr;
  Window w;
  int state;
  int last_access;
  int named;

  /* A number uniquely identifying this window. This is a different
     number than the one given to it by the group it is in. This
     number is used for internal purposes, whereas the group number is
     what the user sees. */
  int number;

  /* Window name hints. */
  char *user_name;
  char *wm_name;
  char *res_name;
  char *res_class;

  /* Dimensions */
  int x, y, width, height, border;

  /* WM Hints */
  XSizeHints *hints;

  /* Colormap */
  Colormap colormap;

  /* Is this a transient window? */
  int transient;
  Window transient_for;

  /* Saved mouse position */
  int mouse_x, mouse_y;

  /* The alignment of the window. Decides to what side or corner the
     window sticks to. */
  int gravity;

  /* A window can be visible inside a frame but not the frame's
     current window. This keeps track of what frame the window was
     mapped into. */
  int frame_number;

  /* Sometimes a window is intended for a certain frame. When a window
     is mapped and this is >0 then use the frame (if it exists). */
  int intended_frame_number;

  struct list_head node;
};

struct rp_window_elem
{
  rp_window *win;
  int number;
  struct list_head node;
};

/* An rp_group is a group of windows. By default all windows are added
   to the same group. But a new group can be created. All new windows
   will be part of this new current group. The windows of any other
   group may be visible in another frame, but will not show up in the
   window list and will not be accessible with select, next, or
   prev. These window navigation commands only navigate the current
   group. */
struct rp_group
{
  /* The name and number of this group. This is to allow the user to
     quickly jump to the desired group. */
  char *name;
  int number;

  /* For determining the last group. */
  int last_access;

  /* The list of windows participating in this group. */
  struct list_head mapped_windows, unmapped_windows;

  /* This numset is responsible for giving out numbers for each window
     in the group. */
  struct numset *numset;

  /* This structure can exist in a list. */
  struct list_head node;
};

struct rp_global_screen
{
  Window root;
  unsigned long fg_color, bg_color, fw_color, bw_color; /* The pixel color. */

  /* This numset is responsible for giving out numbers for each screen */
  struct numset *numset;
};

struct xrandr_info {
  int output;
  int crtc;
  int primary;
  char *name;
};

struct rp_screen
{
  GC normal_gc, inverse_gc;
  Window root, bar_window, key_window, input_window, frame_window, help_window;
  int bar_is_raised;
  int screen_num;               /* Our screen number as dictated by X */
  Colormap def_cmap;
  Cursor rat;

  /* Screen number, handled by rp_global_screen numset */
  int number;

  struct xrandr_info xrandr;

  /* Here to abstract over the Xrandr vs X screens difference */
  int left, top, width, height;

  char *display_string;

  /* A list of frames that may or may not contain windows. There should
     always be one in the list. */
  struct list_head frames;

  /* Keep track of which numbers have been given to frames. */
  struct numset *frames_numset;

  /* The number of the currently focused frame. One for each screen so
     when you switch screens the focus doesn't get frobbed. */
  int current_frame;

  /* This structure can exist in a list. */
  struct list_head node;

  /* Used by sfrestore */
  struct sbuf *scratch_buffer;

#ifdef USE_XFT_FONT
  XftFont *xft_font;
  XftColor xft_fg_color, xft_bg_color;
#endif
};

struct rp_action
{
  KeySym key;
  unsigned int state;
  char *data;                   /* misc data to be passed to the function */
/*   void (*func)(void *); */
};

struct rp_keymap
{
  char *name;
  rp_action *actions;
  int actions_last;
  int actions_size;

  /* This structure can be part of a list. */
  struct list_head node;
};

struct rp_key
{
  KeySym sym;
  unsigned int state;
};

struct rp_defaults
{
  /* Default positions for new normal windows, transient windows, and
     normal windows with maxsize hints. */
  int win_gravity;
  int trans_gravity;
  int maxsize_gravity;

  int input_window_size;
  int window_border_width;
  int only_border;

  int bar_x_padding;
  int bar_y_padding;
  int bar_location;
  int bar_timeout;
  int bar_border_width;
  int bar_in_padding;

  int frame_indicator_timeout;
  int frame_resize_unit;

  int padding_left;
  int padding_right;
  int padding_top;
  int padding_bottom;

  XFontSet font;
  char *font_string;

  char *fgcolor_string;
  char *bgcolor_string;
  char *fwcolor_string;
  char *bwcolor_string;

  int wait_for_key_cursor;

  char *window_fmt;
  char *info_fmt;

  /* Which name to use: wm_name, res_name, res_class. */
  int win_name;

  int startup_message;

  /* Decides whether the window list is displayed in a row or a
     column. */
  int window_list_style;

  /* Pointer warping toggle. */
  int warp;

  int history_size;
  /* remove older history when adding the same again */
  int history_compaction;
  /* expand ! when compiled with libhistory */
  int history_expansion;

  char *frame_selectors;

  /* How many frame sets to remember when undoing. */
  int maxundos;

  /* The name of the top level keymap */
  char *top_kmap;

  /* Frame indicator format */
  char *frame_fmt;
};

/* Information about a child process. */
struct rp_child_info
{
  /* The command that was executed. */
  char *cmd;

  /* PID of the process. */
  int pid;

  /* Return status when the child process finished. */
  int status;

  /* When this is != 0 then the process finished. */
  int terminated;

  /* what was current when it was launched? */
  rp_group *group;
  rp_frame *frame;
  rp_screen *screen;

  /* Non-zero when the pid has mapped a window. This is to prevent
     every window the program opens from getting mapped in the frame
     it was launched from. Only the first window should do this. */
  int window_mapped;

  /* This structure can exist in a list. */
  struct list_head node;
};

/* These defines should be used to specify the modifier mask for keys
   and they are translated into the X11 modifier mask when the time
   comes to compare modifier masks. */
#define RP_SHIFT_MASK   1
#define RP_CONTROL_MASK 2
#define RP_META_MASK    4
#define RP_ALT_MASK     8
#define RP_SUPER_MASK   16
#define RP_HYPER_MASK   32

struct modifier_info
{
/*   unsigned int mode_switch_mask; */
  unsigned int meta_mod_mask;
  unsigned int alt_mod_mask;
  unsigned int super_mod_mask;
  unsigned int hyper_mod_mask;

  /* Keep track of these because they mess up the grab and should be
     ignored. */
  unsigned int num_lock_mask;
  unsigned int scroll_lock_mask;
};

typedef struct list_head *(*completion_fn)(char *string);

/*
  BASIC: The completion shall begin with the same characters as the partial
  string. Case is ignored.

  SUBSTRING: The partial string shall be a subpart of the completion. Case
  is ignored.
*/
enum completion_styles
{
  BASIC,
  SUBSTRING
};

struct rp_completions
{
  /* A pointer to the partial string that is being completed. We need
     to store this so that the user can cycle through all possible
     completions. */
  char *partial;

  /* A pointer to the string that was last matched string. Used to
     keep track of where we are in the completion list. */
  struct sbuf *last_match;

  /* A list of sbuf's which are possible completions. */
  struct list_head completion_list;

  /* The function that generates the completions. */
  completion_fn complete_fn;

  /* virgin = 1 means no completions have been attempted on the input
     string. */
  unsigned short int virgin;

  /* The completion style used to perform string comparisons */
  enum completion_styles style;
};

struct rp_input_line
{
  char *buffer;
  char *prompt;
  char *saved;
  size_t position;
  size_t length;
  size_t size;
  rp_completions *compl;
  Atom  selection;
  int   history_id;
};

/* The hook dictionary. */
struct rp_hook_db_entry
{
  char *name;
  struct list_head *hook;
};

typedef struct rp_xselection rp_xselection;
struct rp_xselection
{
  char *text;
  int len;
};

#endif /* _RATPOISON_DATA_H */



================================================
FILE: src/editor.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>

#include "ratpoison.h"

/* bind functions */
static edit_status editor_forward_char (rp_input_line *line);
static edit_status editor_backward_char (rp_input_line *line);
static edit_status editor_forward_word (rp_input_line *line);
static edit_status editor_backward_word (rp_input_line *line);
static edit_status editor_beginning_of_line (rp_input_line *line);
static edit_status editor_end_of_line (rp_input_line *line);
static edit_status editor_delete_char (rp_input_line *line);
static edit_status editor_backward_delete_char (rp_input_line *line);
static edit_status editor_kill_word (rp_input_line *line);
static edit_status editor_backward_kill_word (rp_input_line *line);
static edit_status editor_kill_line (rp_input_line *line);
static edit_status editor_paste_selection (rp_input_line *line);
static edit_status editor_abort (rp_input_line *line);
static edit_status editor_no_action (rp_input_line *line);
static edit_status editor_enter (rp_input_line *line);
static edit_status editor_history_previous (rp_input_line *line);
static edit_status editor_history_next (rp_input_line *line);
static edit_status editor_backward_kill_line (rp_input_line *line);
static edit_status editor_complete_prev (rp_input_line *line);
static edit_status editor_complete_next (rp_input_line *line);

/* default edit action */
static edit_status editor_insert (rp_input_line *line, char *keysym_buf);


static char *saved_command = NULL;

typedef struct edit_binding edit_binding;

struct edit_binding
{
  struct rp_key key;
  edit_status (*func)(rp_input_line *);
};

static edit_binding edit_bindings[] =
  { {{XK_g,             RP_CONTROL_MASK},       editor_abort},
     {{XK_Escape,       0},             editor_abort},
     {{XK_f,            RP_CONTROL_MASK},       editor_forward_char},
     {{XK_Right,        0},             editor_forward_char},
     {{XK_b,            RP_CONTROL_MASK},       editor_backward_char},
     {{XK_Left, 0},             editor_backward_char},
     {{XK_f,            RP_META_MASK},          editor_forward_word},
     {{XK_b,            RP_META_MASK},          editor_backward_word},
     {{XK_a,            RP_CONTROL_MASK},       editor_beginning_of_line},
     {{XK_Home, 0},             editor_beginning_of_line},
     {{XK_e,            RP_CONTROL_MASK},       editor_end_of_line},
     {{XK_End,          0},     editor_end_of_line},
     {{XK_d,            RP_CONTROL_MASK},       editor_delete_char},
     {{XK_Delete,       0},             editor_delete_char},
     {{XK_BackSpace,    0},             editor_backward_delete_char},
     {{XK_h,            RP_CONTROL_MASK},       editor_backward_delete_char},
     {{XK_BackSpace,    RP_META_MASK},          editor_backward_kill_word},
     {{XK_d,            RP_META_MASK},          editor_kill_word},
     {{XK_k,            RP_CONTROL_MASK},       editor_kill_line},
     {{XK_u,            RP_CONTROL_MASK},       editor_backward_kill_line},
     {{XK_y,            RP_CONTROL_MASK},       editor_paste_selection},
     {{XK_p,            RP_CONTROL_MASK},       editor_history_previous},
     {{XK_Up,           0},     editor_history_previous},
     {{XK_n,            RP_CONTROL_MASK},       editor_history_next},
     {{XK_Down, 0},             editor_history_next},
     {{XK_Return,       0},             editor_enter},
     {{XK_m,            RP_CONTROL_MASK},       editor_enter},
     {{XK_KP_Enter,     0},             editor_enter},
     {{XK_Tab,          0},             editor_complete_next},
     {{XK_ISO_Left_Tab, 0},             editor_complete_prev},
     { {0,              0},     0} };

rp_input_line *
input_line_new (char *prompt, char *preinput, int history_id,
                enum completion_styles style, completion_fn fn)
{
  rp_input_line *line;
  size_t length;

  line = xmalloc (sizeof (rp_input_line));
  line->prompt = prompt;
  line->compl = completions_new (fn, style);
  line->history_id = history_id;

  /* Allocate some memory to start with (100 extra bytes) */
  length = strlen (preinput);
  line->size = length + 1 + 100;
  line->buffer = xmalloc (line->size);

  /* load in the preinput */
  memcpy (line->buffer, preinput, length);
  line->buffer[length] = '\0';
  line->position = line->length = length;

  return line;
}

void
input_line_free (rp_input_line *line)
{
  completions_free (line->compl);
  free (line->buffer);
  free (line);
}

edit_status
execute_edit_action (rp_input_line *line, KeySym ch, unsigned int modifier, char *keysym_buf)
{
  struct edit_binding *binding = NULL;
  int found_binding = 0;
  edit_status status;

  for (binding = edit_bindings; binding->func; binding++)
    {
      if (ch == binding->key.sym && modifier == binding->key.state)
        {
          found_binding = 1;
          break;
        }
    }

  if (found_binding)
    status = binding->func (line);
  else if (modifier)
    status = editor_no_action (line);
  else
    status = editor_insert (line, keysym_buf);

  return status;
}

static edit_status
editor_forward_char (rp_input_line *line)
{
  if (line->position == line->length)
    return EDIT_NO_OP;

  if (isu8start (line->buffer[line->position]))
    {
      do
        line->position++;
      while (isu8cont (line->buffer[line->position]));
    }
  else
    line->position++;

  return EDIT_MOVE;
}

static edit_status
editor_backward_char (rp_input_line *line)
{
  if (line->position == 0)
    return EDIT_NO_OP;

  do
    line->position--;
  while (line->position > 0 && isu8cont (line->buffer[line->position]));

  return EDIT_MOVE;
}

static edit_status
editor_forward_word (rp_input_line *line)
{
  if (line->position == line->length)
    return EDIT_NO_OP;

  while (line->position < line->length
	 && !isalnum ((unsigned char)line->buffer[line->position]))
    line->position++;

  while (line->position < line->length
	 && (isalnum ((unsigned char)line->buffer[line->position])
	     || isu8char (line->buffer[line->position])))
    line->position++;

  return EDIT_MOVE;
}

static edit_status
editor_backward_word (rp_input_line *line)
{
  if (line->position == 0)
    return EDIT_NO_OP;

  while (line->position > 0 && !isalnum ((unsigned char)line->buffer[line->position]))
    line->position--;

  while (line->position > 0
	 && (isalnum ((unsigned char)line->buffer[line->position])
	     || isu8char (line->buffer[line->position])))
    line->position--;

  return EDIT_MOVE;
}

static edit_status
editor_beginning_of_line (rp_input_line *line)
{
  if (line->position == 0)
    return EDIT_NO_OP;
  else
    {
      line->position = 0;
      return EDIT_MOVE;
    }
}

static edit_status
editor_end_of_line (rp_input_line *line)
{
  if (line->position == line->length)
    return EDIT_NO_OP;
  else
    {
      line->position = line->length;
      return EDIT_MOVE;
    }
}

static edit_status
editor_delete_char (rp_input_line *line)
{
  size_t diff = 0;

  if (line->position == line->length)
    return EDIT_NO_OP;

  if (isu8start (line->buffer[line->position]))
    {
      do
        diff++;
      while (isu8cont (line->buffer[line->position + diff]));
    }
  else
    diff++;

  memmove (&line->buffer[line->position],
           &line->buffer[line->position + diff],
           line->length - line->position + diff + 1);

  line->length -= diff;

  return EDIT_DELETE;
}

static edit_status
editor_backward_delete_char (rp_input_line *line)
{
  size_t diff = 1;

  if (line->position == 0)
    return EDIT_NO_OP;

  while (line->position - diff > 0
         && isu8cont (line->buffer[line->position - diff]))
    diff++;

  memmove (&line->buffer[line->position - diff],
           &line->buffer[line->position],
           line->length - line->position + 1);

  line->position -= diff;
  line->length -= diff;

  return EDIT_DELETE;
}

static edit_status
editor_kill_word (rp_input_line *line)
{
  size_t diff = 0;

  if (line->position == line->length)
    return EDIT_NO_OP;

  while (line->position + diff < line->length &&
         !isalnum ((unsigned char)line->buffer[line->position + diff]))
    diff++;

  while (line->position + diff < line->length
	 && (isalnum ((unsigned char)line->buffer[line->position + diff])
	     || isu8char (line->buffer[line->position + diff])))
    diff++;

  /* Add the word to the X11 selection. */
  set_nselection (&line->buffer[line->position], diff);

  memmove (&line->buffer[line->position],
           &line->buffer[line->position + diff],
           line->length - line->position + diff + 1);

  line->length -= diff;

  return EDIT_DELETE;
}

static edit_status
editor_backward_kill_word (rp_input_line *line)
{
  size_t diff = 1;

  if (line->position == 0)
    return EDIT_NO_OP;

  while (line->position - diff > 0 &&
         !isalnum ((unsigned char)line->buffer[line->position - diff]))
    diff++;

  while (line->position - diff > 0
	 && (isalnum ((unsigned char)line->buffer[line->position - diff])
	     || isu8char (line->buffer[line->position - diff])))
    diff++;

  /* Add the word to the X11 selection. */
  set_nselection (&line->buffer[line->position - diff], diff);

  memmove (&line->buffer[line->position - diff],
           &line->buffer[line->position],
           line->length - line->position + 1);

  line->position -= diff;
  line->length -= diff;

  return EDIT_DELETE;
}

static edit_status
editor_kill_line (rp_input_line *line)
{
  if (line->position == line->length)
    return EDIT_NO_OP;

  /* Add the line to the X11 selection. */
  set_selection (&line->buffer[line->position]);

  line->length = line->position;
  line->buffer[line->length] = '\0';

  return EDIT_DELETE;
}

/* Do the dirty work of killing a line backwards. */
static void
backward_kill_line (rp_input_line *line)
{
  memmove (&line->buffer[0],
           &line->buffer[line->position],
           line->length - line->position + 1);

  line->length -= line->position;
  line->position = 0;
}

static edit_status
editor_backward_kill_line (rp_input_line *line)
{
  if (line->position == 0)
    return EDIT_NO_OP;

  /* Add the line to the X11 selection. */
  set_nselection (line->buffer, line->position);

  backward_kill_line (line);

  return EDIT_DELETE;
}

static edit_status
editor_history_previous (rp_input_line *line)
{
  const char *entry = history_previous (line->history_id);

  if (entry)
    {
      if (!saved_command)
        {
          line->buffer[line->length] = '\0';
          saved_command = xstrdup (line->buffer);
          PRINT_DEBUG (("saved current command line: \'%s\'\n", saved_command));
        }

      free (line->buffer);
      line->buffer = xstrdup (entry);
      line->length = strlen (line->buffer);
      line->size = line->length + 1;
      line->position = line->length;
      PRINT_DEBUG (("entry: \'%s\'\n", line->buffer));
    }
  else
    {
      PRINT_DEBUG (("- do nothing -\n"));
      return EDIT_NO_OP;
    }

  return EDIT_INSERT;
}

static edit_status
editor_history_next (rp_input_line *line)
{
  const char *entry = history_next (line->history_id);

  if (entry)
    {
      free (line->buffer);
      line->buffer = xstrdup (entry);
      PRINT_DEBUG (("entry: \'%s\'\n", line->buffer));
    }
  else if (saved_command)
    {
          free (line->buffer);
          line->buffer = saved_command;
          saved_command = NULL;
          PRINT_DEBUG (("restored command line: \'%s\'\n", line->buffer));
    }
  else
    {
      PRINT_DEBUG (("- do nothing -\n"));
          return EDIT_NO_OP;
    }

  line->length = strlen (line->buffer);
  line->size = line->length + 1;
  line->position = line->length;

  return EDIT_INSERT;
}

static edit_status
editor_abort (rp_input_line *line UNUSED)
{
  return EDIT_ABORT;
}

static edit_status
editor_no_action (rp_input_line *line UNUSED)
{
  return EDIT_NO_OP;
}

static edit_status
editor_insert (rp_input_line *line, char *keysym_buf)
{
  size_t nbytes;

  PRINT_DEBUG (("keysym_buf: '%s'\n", keysym_buf));

  nbytes = strlen (keysym_buf);
  if (line->length + nbytes > line->size - 1)
    {
      line->size += nbytes + 100;
      line->buffer = xrealloc (line->buffer, line->size);
    }

  memmove (&line->buffer[line->position + nbytes],
	   &line->buffer[line->position],
	   line->length - line->position + 1);
  memcpy (&line->buffer[line->position], keysym_buf, nbytes);

  line->length += nbytes;
  line->position += nbytes;

  return EDIT_INSERT;
}

static edit_status
editor_enter (rp_input_line *line)
{
  int result;
  char *expansion;

  line->buffer[line->length] = '\0';

  if (!defaults.history_expansion) {
      history_add (line->history_id, line->buffer);
      return EDIT_DONE;
  }

  result = history_expand_line (line->history_id, line->buffer, &expansion);

  PRINT_DEBUG (("History Expansion - result: %d\n", result));
  PRINT_DEBUG (("History Expansion - expansion: \'%s\'\n", expansion));

  if (result == -1 || result == 2)
    {
      marked_message_printf (0, 0, "%s", expansion);
      free (expansion);
      return EDIT_ABORT;
    }
  else /* result == 0 || result == 1 */
    {
      history_add (line->history_id, expansion);
      free (line->buffer);
      line->buffer = expansion;
    }

  return EDIT_DONE;
}

static edit_status
editor_paste_selection (rp_input_line *line)
{
  char *text;

  text = get_selection ();
  if (text)
    {
      editor_insert (line, text);
      free (text);
      return EDIT_INSERT;
    }
  else
    return EDIT_NO_OP;
}

static edit_status
editor_complete (rp_input_line *line, int direction)
{
  char *tmp;
  char *s;

  /* Create our partial string that will be used for completion. It is
     the characters up to the position of the cursor. */
  tmp = xmalloc (line->position + 1);
  memcpy (tmp, line->buffer, line->position);
  tmp[line->position] = '\0';

  /* We don't need to free s because it's a string from the completion
     list. */
  s = completions_complete (line->compl, tmp, direction);
  free (tmp);

  if (s == NULL)
    return EDIT_NO_OP;

  /* Insert the completion. */
  backward_kill_line (line);
  editor_insert (line, s);

  return EDIT_COMPLETE;
}

static edit_status
editor_complete_next (rp_input_line *line)
{
  return editor_complete (line, COMPLETION_NEXT);
}

static edit_status
editor_complete_prev (rp_input_line *line)
{
  return editor_complete (line, COMPLETION_PREVIOUS);
}



================================================
FILE: src/editor.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_EDITOR_H
#define _RATPOISON_EDITOR_H 1

#include "utf8.h"

typedef enum edit_status
{
  EDIT_INSERT,
  EDIT_DELETE,
  EDIT_MOVE,
  EDIT_COMPLETE,
  EDIT_ABORT,
  EDIT_DONE,
  EDIT_NO_OP
} edit_status;

/* Input line functions */
rp_input_line *input_line_new (char *prompt, char *preinput, int history_id, enum completion_styles style, completion_fn fn);
void input_line_free (rp_input_line *line);

edit_status execute_edit_action (rp_input_line *line, KeySym ch, unsigned int modifier, char *keysym_buf);

#endif /* ! _RATPOISON_EDITOR_H */



================================================
FILE: src/events.c
================================================
/* Ratpoison X events
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/keysym.h>
#include <X11/Xmd.h>            /* for CARD32. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <errno.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/wait.h>

#include "ratpoison.h"

/* The event currently being processed. Mostly used in functions from
   action.c which need to forward events to other windows. */
XEvent rp_current_event;

/* RAISED is non zero if a raised message should be used 0 for a map message. */
void
show_rudeness_msg (rp_window *win, int raised)
{
  rp_group *g = groups_find_group_by_window (win);
  rp_window_elem *elem = group_find_window (&g->mapped_windows, win);
  if (g == rp_current_group)
    {
      if (win->transient)
        marked_message_printf (0, 0, raised ? MESSAGE_RAISE_TRANSIENT:MESSAGE_MAP_TRANSIENT,
                               elem->number, window_name (win));
      else
        marked_message_printf (0, 0, raised ? MESSAGE_RAISE_WINDOW:MESSAGE_MAP_WINDOW,
                               elem->number, window_name (win));
    }
  else
    {
      if (win->transient)
        marked_message_printf (0, 0, raised ? MESSAGE_RAISE_TRANSIENT_GROUP:MESSAGE_MAP_TRANSIENT_GROUP,
                               elem->number, window_name (win), g->name);
      else
        marked_message_printf (0, 0, raised ? MESSAGE_RAISE_WINDOW_GROUP:MESSAGE_MAP_WINDOW_GROUP,
                               elem->number, window_name (win), g->name);
    }
}

static void
new_window (XCreateWindowEvent *e)
{
  rp_window *win;
  rp_screen *s;

  if (e->override_redirect)
    return;

  win = find_window (e->window);

  /* New windows belong to the current screen */
  s = rp_current_screen;

  if (is_rp_window (e->window)) return;

  if (s && win == NULL
      && e->window != s->key_window
      && e->window != s->bar_window
      && e->window != s->input_window
      && e->window != s->frame_window
      && e->window != s->help_window)
    {
      win = add_to_window_list (s, e->window);
      update_window_information (win);
    }
}

static void
unmap_notify (XEvent *ev)
{
  rp_frame *frame;
  rp_window *win;

  /* ignore SubstructureNotify unmaps. */
  if(ev->xunmap.event != ev->xunmap.window
     && ev->xunmap.send_event != True)
    return;

  /* FIXME: Should we only look in the mapped window list? */
  win = find_window_in_list (ev->xunmap.window, &rp_mapped_window);

  if (win == NULL)
    return;

  switch (win->state)
    {
    case IconicState:
      PRINT_DEBUG (("Withdrawing iconized window '%s'\n", window_name (win)));
      if (ev->xunmap.send_event) withdraw_window (win);
      break;
    case NormalState:
      PRINT_DEBUG (("Withdrawing normal window '%s'\n", window_name (win)));
      /* If the window was inside a frame, fill the frame with another
         window. */
      frame = find_windows_frame (win);
      if (frame)
        {
          cleanup_frame (frame);
          if (frame->number == win->scr->current_frame
              && rp_current_screen == win->scr)
            set_active_frame (frame, 0);
	  /* Since we may have switched windows, call the hook. */
	  if (frame->win_number != EMPTY)
	    hook_run (&rp_switch_win_hook);
        }

      withdraw_window (win);
      break;
    }

  update_window_names (win->scr, defaults.window_fmt);
}

static void
map_request (XEvent *ev)
{
  rp_window *win;

  win = find_window (ev->xmap.window);
  if (win == NULL)
    {
      PRINT_DEBUG (("Map request from an unknown window.\n"));
      XMapWindow (dpy, ev->xmap.window);
      return;
    }

  PRINT_DEBUG (("Map request from a managed window\n"));

  switch (win->state)
    {
    case WithdrawnState:
      if (unmanaged_window (win->w))
        {
          PRINT_DEBUG (("Mapping Unmanaged Window\n"));
          XMapWindow (dpy, win->w);
          break;
        }
      else
        {
          PRINT_DEBUG (("Mapping Withdrawn Window\n"));
          map_window (win);
          break;
        }
      break;
    case IconicState:
      PRINT_DEBUG (("Mapping Iconic window\n"));
      if (win->last_access == 0)
        {
          /* Depending on the rudeness level, actually map the
             window. */
          if ((rp_honour_transient_map && win->transient)
              || (rp_honour_normal_map && !win->transient))
            set_active_window (win);
        }
      else
        {
          /* Depending on the rudeness level, actually map the
             window. */
          if ((rp_honour_transient_raise && win->transient)
              || (rp_honour_normal_raise && !win->transient))
            set_active_window (win);
          else
            show_rudeness_msg (win, 1);
        }
      break;
    }
}

static void
destroy_window (XDestroyWindowEvent *ev)
{
  rp_window *win;

  win = find_window (ev->window);
  if (win == NULL) return;

  ignore_badwindow++;

  /* If, somehow, the window is not withdrawn before it is destroyed,
     perform the necessary steps to withdraw the window before it is
     unmanaged. */
  if (win->state == IconicState)
    {
      PRINT_DEBUG (("Destroying Iconic Window (%s)\n", window_name (win)));
      withdraw_window (win);
    }
  else if (win->state == NormalState)
    {
      rp_frame *frame;

      PRINT_DEBUG (("Destroying Normal Window (%s)\n", window_name (win)));
      frame = find_windows_frame (win);
      if (frame)
        {
          cleanup_frame (frame);
          if (frame->number == win->scr->current_frame
              && rp_current_screen == win->scr)
            set_active_frame (frame, 0);
          /* Since we may have switched windows, call the hook. */
          if (frame->win_number != EMPTY)
            hook_run (&rp_switch_win_hook);
        }
      withdraw_window (win);
    }

  /* Now that the window is guaranteed to be in the unmapped window
     list, we can safely stop managing it. */
  unmanage (win);
  ignore_badwindow--;
}

static void
configure_request (XConfigureRequestEvent *e)
{
  XWindowChanges changes;
  rp_window *win;

  win = find_window (e->window);

  if (win)
    {
      if (e->value_mask & CWStackMode)
        {
          if (e->detail == Above && win->state != WithdrawnState)
            {
              /* Depending on the rudeness level, actually map the
                 window. */
              if ((rp_honour_transient_raise && win->transient)
                  || (rp_honour_normal_raise && !win->transient))
                {
                  if (win->state == IconicState)
                    set_active_window (win);
                  else if (find_windows_frame (win))
                    goto_window (win);
                }
              else if (current_window() != win)
                {
                  show_rudeness_msg (win, 1);
                }

            }

          PRINT_DEBUG(("request CWStackMode %d\n", e->detail));
        }

      PRINT_DEBUG (("'%s' window size: %d %d %d %d %d\n", window_name (win),
                   win->x, win->y, win->width, win->height, win->border));

      /* Collect the changes to be granted. */
      if (e->value_mask & CWBorderWidth)
        {
          changes.border_width = e->border_width;
          win->border = e->border_width;
          PRINT_DEBUG(("request CWBorderWidth %d\n", e->border_width));
        }

      if (e->value_mask & CWWidth)
        {
          changes.width = e->width;
          win->width = e->width;
          PRINT_DEBUG(("request CWWidth %d\n", e->width));
        }

      if (e->value_mask & CWHeight)
        {
          changes.height = e->height;
          win->height = e->height;
          PRINT_DEBUG(("request CWHeight %d\n", e->height));
        }

      if (e->value_mask & CWX)
        {
          changes.x = e->x;
          win->x = e->x;
          PRINT_DEBUG(("request CWX %d\n", e->x));
        }

      if (e->value_mask & CWY)
        {
          changes.y = e->y;
          win->y = e->y;
          PRINT_DEBUG(("request CWY %d\n", e->y));
        }

      if (e->value_mask & (CWX|CWY|CWBorderWidth|CWWidth|CWHeight))
        {
          /* Grant the request, then immediately maximize it. */
          XConfigureWindow (dpy, win->w,
                            e->value_mask & (CWX|CWY|CWBorderWidth|CWWidth|CWHeight),
                            &changes);
          XSync(dpy, False);
          if (win->state == NormalState)
            maximize (win);
        }
    }
  else
    {
      /* Its an unmanaged window, so give it what it wants. But don't
         change the stack mode.*/
      if (e->value_mask & CWX) changes.x = e->x;
      if (e->value_mask & CWY) changes.x = e->x;
      if (e->value_mask & CWWidth) changes.x = e->x;
      if (e->value_mask & CWHeight) changes.x = e->x;
      if (e->value_mask & CWBorderWidth) changes.x = e->x;
      XConfigureWindow (dpy, e->window,
                        e->value_mask & (CWX|CWY|CWBorderWidth|CWWidth|CWHeight),
                        &changes);
    }
}

static void
client_msg (XClientMessageEvent *ev)
{
  PRINT_DEBUG (("Received client message.\n"));

  if (ev->message_type == wm_change_state)
    {
      rp_window *win;

      PRINT_DEBUG (("WM_CHANGE_STATE\n"));

      win = find_window (ev->window);
      if (win == NULL) return;
      if (ev->format == 32 && ev->data.l[0] == IconicState)
        {
          /* FIXME: This means clients can hide themselves without the
             user's intervention. This is bad, but Emacs is the only
             program I know of that iconifies itself and this is
             generally from the user pressing C-z.  */
          PRINT_DEBUG (("Iconify Request.\n"));
          if (win->state == NormalState)
            {
              rp_window *w = find_window_other(win->scr);

              if (w)
                set_active_window (w);
              else
                blank_frame (screen_get_frame (win->scr, win->scr->current_frame));
            }
        }
      else
        {
          PRINT_ERROR (("Non-standard WM_CHANGE_STATE format\n"));
        }
    }
}

static void
handle_key (KeySym ks, unsigned int mod, rp_screen *s)
{
  rp_action *key_action;
  rp_keymap *map = find_keymap (defaults.top_kmap);

  if (map == NULL)
    {
      PRINT_ERROR (("Unable to find %s keymap\n", defaults.top_kmap));
      return;
    }

  PRINT_DEBUG (("handling key...\n"));

  /* All functions hide the program bar and the frame indicator. */
  if (defaults.bar_timeout > 0) hide_bar (s);
  hide_frame_indicator();

  /* Disable any alarm that was going to go off. */
  alarm (0);
  alarm_signalled = 0;

  /* Call the top level key pressed hook. */
  hook_run (&rp_key_hook);

  PRINT_DEBUG (("handle_key\n"));

  /* Read a key and execute the command associated with it on the
     default keymap. Ignore the key if it doesn't have a binding. */
  if ((key_action = find_keybinding (ks, x11_mask_to_rp_mask (mod), map)))
    {
      cmdret *result;

      PRINT_DEBUG(("%s\n", key_action->data));

      result = command (1, key_action->data);

      if (result)
        {
          if (result->output)
            message (result->output);
          cmdret_free (result);
        }
    }
  else
    {
      PRINT_DEBUG(("Impossible: No matching key"));
    }
}

static void
key_press (XEvent *ev)
{
  rp_screen *s;
  unsigned int modifier;
  KeySym ks;

  s = rp_current_screen;
  if (!s) return;

#ifdef HIDE_MOUSE
  XWarpPointer (dpy, None, s->root, 0, 0, 0, 0, s->left + s->width - 2, s->top + s->height - 2);
#endif

  modifier = ev->xkey.state;
  cook_keycode ( &ev->xkey, &ks, &modifier, NULL, 0, 1);

  handle_key (ks, modifier, s);
}

/* Read a command off the window and execute it. Some commands return
   text. This text is passed back using the RP_COMMAND_RESULT
   Atom. The client will wait for this property change so something
   must be returned. */
static cmdret *
execute_remote_command (Window w)
{
  int status;
  cmdret *ret;
  Atom type_ret;
  int format_ret;
  unsigned long nitems;
  unsigned long bytes_after;
  unsigned char *req;

  status = XGetWindowProperty (dpy, w, rp_command,
                               0, 0, False, xa_string,
                               &type_ret, &format_ret, &nitems, &bytes_after,
                               &req);

  if (status != Success || req == NULL)
    {
      return cmdret_new (RET_FAILURE, "Couldn't get RP_COMMAND Property");
    }

  /* XGetWindowProperty always allocates one extra byte even if
     the property is zero length. */
  XFree (req);

  status = XGetWindowProperty (dpy, w, rp_command,
                               0, (bytes_after / 4) + (bytes_after % 4 ? 1 : 0),
                               True, xa_string, &type_ret, &format_ret, &nitems,
                               &bytes_after, &req);

  if (status != Success || req == NULL)
    {
      return cmdret_new (RET_FAILURE, "Couldn't get RP_COMMAND Property");
    }

  PRINT_DEBUG (("command: %s\n", req));
  ret = command (req[0], (char *)&req[1]);
  XFree (req);

  return ret;
}

/* Command requests are posted as a property change using the
   RP_COMMAND_REQUEST Atom on the root window. A Command request is a
   Window that holds the actual command as a property using the
   RP_COMMAND Atom. receive_command reads the list of Windows and
   executes their associated command. */
static void
receive_command (Window root)
{
  cmdret *cmd_ret;
  char *result;
  Atom type_ret;
  int format_ret;
  unsigned long nitems;
  unsigned long bytes_after;
  unsigned char *prop_return;
  int offset;

  /* Init offset to 0. In the case where there is more than one window
     in the property, a partial read does not delete the property and
     we need to grab the next window by incementing offset to the
     offset of the next window. */
  offset = 0;
  do
    {
      int ret;
      int length;
      Window w;

      length = sizeof (Window) / 4 + (sizeof (Window) % 4 ?1:0);
      ret = XGetWindowProperty (dpy, root,
                                rp_command_request,
                                offset, length,
                                True, XA_WINDOW, &type_ret, &format_ret,
                                &nitems,
                                &bytes_after, &prop_return);

      /* Update the offset to point to the next window (if there is
         another one). */
      offset += length;

      if (ret != Success)
        {
          PRINT_ERROR (("XGetWindowProperty Failed\n"));
          if (prop_return)
            XFree (prop_return);
          break;
        }

      /* If there was no window, then we're done. */
      if (prop_return == NULL)
        {
          PRINT_DEBUG (("No property to read\n"));
          break;
        }

      /* We grabbed a window, so now read the command stored in
         this window and execute it. */
      w = *(Window *)prop_return;
      XFree (prop_return);
      cmd_ret = execute_remote_command (w);

      /* notify the client of any text that was returned by the
         command.  see communications.c:receive_command_result() */
      if (cmd_ret->output)
        result = xsprintf ("%c%s", cmd_ret->success ? '1':'0', cmd_ret->output);
      else if (!cmd_ret->success)
        result = xstrdup("0");
      else
	result = NULL;

      if (result)
        XChangeProperty (dpy, w, rp_command_result, xa_string,
                         8, PropModeReplace, (unsigned char *)result, strlen (result));
      else
        XChangeProperty (dpy, w, rp_command_result, xa_string,
                         8, PropModeReplace, NULL, 0);
      free (result);
      cmdret_free (cmd_ret);
    } while (bytes_after > 0);
}

static void
property_notify (XEvent *ev)
{
  rp_window *win;

  PRINT_DEBUG (("atom: %ld\n", ev->xproperty.atom));

  if (ev->xproperty.atom == rp_command_request
      && is_a_root_window (ev->xproperty.window)
      && ev->xproperty.state == PropertyNewValue)
    {
      PRINT_DEBUG (("ratpoison command\n"));
      receive_command(ev->xproperty.window);
    }

  win = find_window (ev->xproperty.window);

  if (win)
    {
      if (ev->xproperty.atom == _net_wm_pid)
        {
          struct rp_child_info *child_info;

          PRINT_DEBUG (("updating _NET_WM_PID\n"));
          child_info = get_child_info(win->w);
          if (child_info && !child_info->window_mapped)
            {
              if (child_info->frame)
                {
                  PRINT_DEBUG (("frame=%p\n", child_info->frame));
                  win->intended_frame_number = child_info->frame->number;
		  /* Only map the first window in the launch frame. */
		  child_info->window_mapped = 1;
                }
              /* TODO: also adopt group information? */
            }
        } else
        switch (ev->xproperty.atom)
          {
          case XA_WM_NAME:
            PRINT_DEBUG (("updating window name\n"));
            if (update_window_name (win)) {
	      update_window_names (win->scr, defaults.window_fmt);
	      hook_run (&rp_title_changed_hook);
	    }
            break;

          case XA_WM_NORMAL_HINTS:
            PRINT_DEBUG (("updating window normal hints\n"));
            update_normal_hints (win);
            if (win->state == NormalState)
              maximize (win);
            break;

          case XA_WM_TRANSIENT_FOR:
            PRINT_DEBUG (("Transient for\n"));
            win->transient = XGetTransientForHint (dpy, win->w, &win->transient_for);
            break;

          default:
            PRINT_DEBUG (("Unhandled property notify event: %ld\n", ev->xproperty.atom));
            break;
          }
    }
}

static void
colormap_notify (XEvent *ev)
{
  rp_window *win;

  win = find_window (ev->xcolormap.window);

  if (win != NULL)
    {
      XWindowAttributes attr;

      /* SDL sets the colormap just before destroying the window, so
         ignore BadWindow errors. */
      ignore_badwindow++;

      XGetWindowAttributes (dpy, win->w, &attr);
      win->colormap = attr.colormap;

      if (win == current_window()
	  && !rp_current_screen->bar_is_raised)
        {
          XInstallColormap (dpy, win->colormap);
        }

      ignore_badwindow--;
    }
}

static void
focus_change (XFocusChangeEvent *ev)
{
  rp_window *win;

  /* We're only interested in the NotifyGrab mode */
  if (ev->mode != NotifyGrab) return;

  win = find_window (ev->window);

  if (win != NULL)
    {
      PRINT_DEBUG (("Re-grabbing prefix key\n"));
      grab_top_level_keys (win->w);
    }
}

static void
mapping_notify (XMappingEvent *ev)
{
  ungrab_keys_all_wins();

  switch (ev->request)
    {
    case MappingModifier:
      update_modifier_map();
      /* This is meant to fall through.  */
    case MappingKeyboard:
      XRefreshKeyboardMapping (ev);
      break;
    }

  grab_keys_all_wins();
}

static void
configure_notify (XConfigureEvent *ev)
{
  rp_screen *s;

  s = find_screen(ev->window);
  if (s != NULL)
    /* This is a root window of a screen,
     * look if its width or height changed: */
    screen_update (s, ev->x, ev->y, ev->width, ev->height);
}

/* This is called when an application has requested the
   selection. Copied from rxvt. */
static void
selection_request (XSelectionRequestEvent *rq)
{
  XEvent          ev;
  CARD32          target_list[4];
  Atom            target;
  static Atom     xa_targets = None;
  static Atom     xa_text = None; /* XXX */
  XTextProperty   ct;
  XICCEncodingStyle style;
  char           *cl[4];

  if (xa_text == None)
    xa_text = XInternAtom(dpy, "TEXT", False);
  if (xa_targets == None)
    xa_targets = XInternAtom(dpy, "TARGETS", False);

  ev.xselection.type = SelectionNotify;
  ev.xselection.property = None;
  ev.xselection.display = rq->display;
  ev.xselection.requestor = rq->requestor;
  ev.xselection.selection = rq->selection;
  ev.xselection.target = rq->target;
  ev.xselection.time = rq->time;

  if (rq->target == xa_targets) {
    target_list[0] = (CARD32) xa_targets;
    target_list[1] = (CARD32) xa_string;
    target_list[2] = (CARD32) xa_text;
    target_list[3] = (CARD32) xa_compound_text;
    XChangeProperty(dpy, rq->requestor, rq->property, rq->target,
                    (8 * sizeof(target_list[0])), PropModeReplace,
                    (unsigned char *)target_list,
                    (sizeof(target_list) / sizeof(target_list[0])));
    ev.xselection.property = rq->property;
  } else if (rq->target == xa_string
             || rq->target == xa_compound_text
             || rq->target == xa_text) {
    if (rq->target == xa_string) {
      style = XStringStyle;
      target = xa_string;
    } else {
      target = xa_compound_text;
      style = (rq->target == xa_compound_text) ? XCompoundTextStyle
        : XStdICCTextStyle;
    }
    cl[0] = selection.text;
    XmbTextListToTextProperty(dpy, cl, 1, style, &ct);
    XChangeProperty(dpy, rq->requestor, rq->property,
                    target, 8, PropModeReplace,
                    ct.value, ct.nitems);
    ev.xselection.property = rq->property;
  }
  XSendEvent(dpy, rq->requestor, False, 0, &ev);
}

static void
selection_clear (void)
{
  free (selection.text);
  selection.text = NULL;
  selection.len = 0;
}

/* Given an event, call the correct function to handle it. */
static void
delegate_event (XEvent *ev)
{

  if (rp_have_xrandr)
    xrandr_notify (ev);

  switch (ev->type)
    {
    case ConfigureRequest:
      PRINT_DEBUG (("--- Handling ConfigureRequest ---\n"));
      configure_request (&ev->xconfigurerequest);
      break;

    case CreateNotify:
      PRINT_DEBUG (("--- Handling CreateNotify ---\n"));
      new_window (&ev->xcreatewindow);
      break;

    case DestroyNotify:
      PRINT_DEBUG (("--- Handling DestroyNotify ---\n"));
      destroy_window (&ev->xdestroywindow);
      break;

    case ClientMessage:
      PRINT_DEBUG (("--- Handling ClientMessage ---\n"));
      client_msg (&ev->xclient);
      break;

    case ColormapNotify:
      PRINT_DEBUG (("--- Handling ColormapNotify ---\n"));
      colormap_notify (ev);
      break;

    case PropertyNotify:
      PRINT_DEBUG (("--- Handling PropertyNotify ---\n"));
      property_notify (ev);
      break;

    case MapRequest:
      PRINT_DEBUG (("--- Handling MapRequest ---\n"));
      map_request (ev);
      break;

    case KeyPress:
      PRINT_DEBUG (("--- Handling KeyPress ---\n"));
      key_press (ev);
      break;

    case UnmapNotify:
      PRINT_DEBUG (("--- Handling UnmapNotify ---\n"));
      unmap_notify (ev);
      break;

    case FocusOut:
      PRINT_DEBUG (("--- Handling FocusOut ---\n"));
      focus_change (&ev->xfocus);
      break;

    case FocusIn:
      PRINT_DEBUG (("--- Handling FocusIn ---\n"));
      focus_change (&ev->xfocus);
      break;

    case MappingNotify:
      PRINT_DEBUG (("--- Handling MappingNotify ---\n"));
      mapping_notify( &ev->xmapping );
      break;

    case SelectionRequest:
      selection_request(&ev->xselectionrequest);
      break;

    case SelectionClear:
      selection_clear();
      break;

    case ConfigureNotify:
      if (!rp_have_xrandr)
        {
          PRINT_DEBUG (("--- Handling ConfigureNotify ---\n"));
          configure_notify (&ev->xconfigure);
        }
      break;

    case MapNotify:
    case Expose:
    case MotionNotify:
    case KeyRelease:
    case ReparentNotify:
    case EnterNotify:
    case SelectionNotify:
    case CirculateRequest:
      /* Ignore these events. */
      break;

    default:
      PRINT_DEBUG (("--- Unknown event %d ---\n",- ev->type));
    }
}

static void
handle_signals (void)
{
  /* An alarm means we need to hide the popup windows. */
  if (alarm_signalled > 0)
    {
      rp_screen *cur;

      PRINT_DEBUG (("Alarm received.\n"));

      /* Only hide the bar if it times out. */
      if (defaults.bar_timeout > 0)
        {
          list_for_each_entry (cur, &rp_screens, node)
            {
              hide_bar (cur);
            }
        }

      hide_frame_indicator();
      alarm_signalled = 0;
    }

  if (chld_signalled > 0)
    {
      rp_child_info *cur;
      struct list_head *iter, *tmp;

      /* Report and remove terminated processes. */
      list_for_each_safe_entry (cur, iter, tmp, &rp_children, node)
        {
          if (cur->terminated)
            {
              /* Report any child that didn't return 0. */
              if (cur->status != 0)
                marked_message_printf (0,0, "/bin/sh -c \"%s\" finished (%d)",
                                       cur->cmd, cur->status);
              list_del  (&cur->node);
              free (cur->cmd);
              free (cur);
            }
        }

      chld_signalled = 0;
    }

  if (rp_exec_newwm)
    {
      rp_screen *cur;

      PRINT_DEBUG (("Switching to %s\n", rp_exec_newwm));

      putenv (rp_current_screen->display_string);
      unhide_all_windows();
      XSync(dpy, False);

      list_for_each_entry (cur, &rp_screens, node)
        {
          deactivate_screen (cur);
        }

      execlp (rp_exec_newwm, rp_exec_newwm, (char *)NULL);

      /* Failed. Clean up. */
      PRINT_ERROR (("exec %s ", rp_exec_newwm));
      perror(" failed");
      free (rp_exec_newwm);
      rp_exec_newwm = NULL;

      list_for_each_entry (cur, &rp_screens, node)
        {
          activate_screen (cur);
        }
    }

  if (hup_signalled > 0)
    {
      PRINT_DEBUG (("Restarting\n"));
      hook_run (&rp_restart_hook);
      clean_up ();
      execvp(myargv[0], myargv);
    }

  if (kill_signalled > 0)
    {
      PRINT_DEBUG (("Exiting\n"));
      hook_run (&rp_quit_hook);
      clean_up ();
      exit (EXIT_SUCCESS);
    }

  /* Report any X11 errors that have occurred. */
  if (rp_error_msg)
    {
      marked_message_printf (0, 6, "ERROR: %s", rp_error_msg);
      free (rp_error_msg);
      rp_error_msg = NULL;
    }
}

/* The main loop. */
void
listen_for_events (void)
{
  int x_fd;
  fd_set fds;

  x_fd = ConnectionNumber (dpy);
  FD_ZERO (&fds);

  /* Loop forever. */
  for (;;)
    {
      handle_signals ();

      /* Handle the next event. */
      FD_SET (x_fd, &fds);
      XFlush(dpy);

      if (QLength (dpy) > 0
          || select(x_fd+1, &fds, NULL, NULL, NULL) == 1)
        {
          XNextEvent (dpy, &rp_current_event);
          delegate_event (&rp_current_event);
          XSync(dpy, False);
        }
    }
}



================================================
FILE: src/events.h
================================================
/* Function prototypes
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_EVENTS_H
#define _RATPOISON_EVENTS_H 1

void listen_for_events (void);
void show_rudeness_msg (rp_window *win, int raised);

#endif /* _RATPOISON_EVENTS_H */



================================================
FILE: src/format.c
================================================
[Binary file]


================================================
FILE: src/format.h
================================================
[Binary file]


================================================
FILE: src/frame.c
================================================
/* functions that manipulate the frame structure.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "ratpoison.h"

#include <string.h>

int
frame_left (rp_frame *frame)
{
  return frame->x;
}

int
frame_top (rp_frame *frame)
{
  return frame->y;
}

int
frame_right (rp_frame *frame)
{
  return frame->x + frame->width;
}

int
frame_bottom (rp_frame *frame)
{
  return frame->y + frame->height;
}


int
frame_left_abs (rp_frame *frame)
{
  rp_screen *s = frames_screen (frame);
  return s->left + frame->x;
}

int
frame_top_abs (rp_frame *frame)
{
  rp_screen *s = frames_screen (frame);
  return s->top + frame->y;
}

int
frame_right_abs (rp_frame *frame)
{
  return frame_left_abs (frame) + frame->width;
}

int
frame_bottom_abs (rp_frame *frame)
{
  return frame_top_abs (frame) + frame->height;
}

int
frame_width(rp_frame *frame)
{
  return frame->width;
}

int
frame_height(rp_frame *frame)
{
  return frame->height;
}

void
frame_resize_left (rp_frame *frame, int amount)
{
  frame->x -= amount;
  frame->width += amount;
}

void
frame_resize_right (rp_frame *frame, int amount)
{
  frame->width += amount;
}

void
frame_resize_up (rp_frame *frame, int amount)
{
  frame->y -= amount;
  frame->height += amount;
}

void
frame_resize_down (rp_frame *frame, int amount)
{
  frame->height += amount;
}

static void
init_frame (rp_frame *f)
{
  f->number = 0;
  f->x = 0;
  f->y = 0;
  f->width = 0;
  f->height = 0;
  f->win_number = 0;
  f->last_access = 0;
  f->dedicated = 0;
}

rp_frame *
frame_new (rp_screen *s)
{
  rp_frame *f;

  f = xmalloc (sizeof (rp_frame));
  init_frame(f);
  f->number = numset_request (s->frames_numset);

  return f;
}

void
frame_free (rp_screen *s, rp_frame *f)
{
  numset_release (s->frames_numset, f->number);
  free (f);
}


rp_frame *
frame_copy (rp_frame *frame)
{
  rp_frame *copy;

  copy = xmalloc (sizeof (rp_frame));

  copy->number = frame->number;
  copy->x = frame->x;
  copy->y = frame->y;
  copy->width = frame->width;
  copy->height = frame->height;
  copy->win_number = frame->win_number;
  copy->last_access = frame->last_access;

  return copy;
}

char *
frame_dump (rp_frame *frame, rp_screen *screen)
{
  rp_window *win;
  char *tmp;
  struct sbuf *s;

  /* rather than use win_number, use the X11 window ID. */
  win = find_window_number (frame->win_number);

  s = sbuf_new (0);
  sbuf_printf (s, "(frame :number %d :x %d :y %d :width %d :height %d :screenw %d :screenh %d :window %ld :last-access %d :dedicated %d)", 
               frame->number,
               frame->x,
               frame->y,
               frame->width,
               frame->height,
	       screen->width,
	       screen->height,
               win ? win->w:0,
               frame->last_access,
               frame->dedicated);

  /* Extract the string and return it, and don't forget to free s. */
  tmp = sbuf_get (s);
  free (s);
  return tmp;
}

/* Used only by frame_read */
#define read_slot(x) do { tmp = strtok_ws (NULL); x = strtol(tmp,NULL,10); } while(0)

rp_frame *
frame_read (char *str, rp_screen *screen)
{
  Window w = 0L;
  rp_window *win;
  rp_frame *f;
  char *tmp, *d;
  int s_width = -1;
  int s_height = -1;

  /* Create a blank frame. */
  f = xmalloc (sizeof (rp_frame));
  init_frame(f);

  PRINT_DEBUG(("parsing '%s'\n", str));

  d = xstrdup(str);
  tmp = strtok_ws (d);

  /* Verify it starts with '(frame ' */
  if (strcmp(tmp, "(frame"))
    {
      PRINT_DEBUG(("Doesn't start with '(frame '\n"));
      free (d);
      free (f);
      return NULL;
    }
  /* NOTE: there is no check to make sure each field was filled in. */
  tmp = strtok_ws(NULL);
  while (tmp)
    {
      if (!strcmp(tmp, ":number"))
        read_slot(f->number);
      else if (!strcmp(tmp, ":x"))
        read_slot(f->x);
      else if (!strcmp(tmp, ":y"))
        read_slot(f->y);
      else if (!strcmp(tmp, ":width"))
        read_slot(f->width);
      else if (!strcmp(tmp, ":height"))
        read_slot(f->height);
      else if (!strcmp(tmp, ":screenw"))
	read_slot(s_width);
      else if (!strcmp(tmp, ":screenh"))
	read_slot(s_height);
      else if (!strcmp(tmp, ":window"))
        read_slot(w);
      else if (!strcmp(tmp, ":last-access"))
        read_slot(f->last_access);
      else if (!strcmp(tmp, ":dedicated")) {
  	/* f->dedicated is unsigned, so read into local variable. */
        long dedicated;

	read_slot(dedicated);
        if (dedicated <= 0)
          f->dedicated = 0;
        else
          f->dedicated = 1;
      }
      else if (!strcmp(tmp, ")"))
        break;
      else
        PRINT_ERROR(("Unknown slot %s\n", tmp));
      /* Read the next token. */
      tmp = strtok_ws(NULL);
    }
  if (tmp)
    PRINT_ERROR(("Frame has trailing garbage\n"));
  free (d);

  /* adjust x, y, width and height to a possible screen size change */
  if (s_width > 0)
    {
      f->x = (f->x*screen->width)/s_width;
      f->width = (f->width*screen->width)/s_width;
    }
  if (s_height > 0)
    {
      f->y = (f->y*screen->height)/s_height;
      f->height = (f->height*screen->height)/s_height;
    }

  /* Perform some integrity checks on what we got and fix any
     problems. */
  if (f->number <= 0)
    f->number = 0;
  if (f->x <= 0)
    f->x = 0;
  if (f->y <= 0)
    f->y = 0;
  if (f->width <= defaults.window_border_width*2)
    f->width = defaults.window_border_width*2 + 1;
  if (f->height <= defaults.window_border_width*2)
    f->height = defaults.window_border_width*2 + 1;
  if (f->last_access < 0)
    f->last_access = 0;

  /* Find the window with the X11 window ID. */
  win = find_window_in_list (w, &rp_mapped_window);
  if (win)
    f->win_number = win->number;
  else
    f->win_number = EMPTY;

  return f;
}

#undef read_slot



================================================
FILE: src/frame.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef FRAME_H
#define FRAME_H

void frame_resize_down (rp_frame *frame, int amount);
void frame_resize_up (rp_frame *frame, int amount);
void frame_resize_right (rp_frame *frame, int amount);
void frame_resize_left (rp_frame *frame, int amount);
int frame_height(rp_frame *frame);
int frame_width(rp_frame *frame);
int frame_bottom (rp_frame *frame);
int frame_right (rp_frame *frame);
int frame_top (rp_frame *frame);
int frame_left (rp_frame *frame);
int frame_bottom_abs (rp_frame *frame);
int frame_right_abs (rp_frame *frame);
int frame_top_abs (rp_frame *frame);
int frame_left_abs (rp_frame *frame);

rp_frame *frame_new (rp_screen *s);
void frame_free (rp_screen *s, rp_frame *f);
rp_frame *frame_copy (rp_frame *frame);
char *frame_dump (rp_frame *frame, rp_screen *screen);
rp_frame *frame_read (char *str, rp_screen *screen);

rp_screen *frames_screen (rp_frame *);

#endif



================================================
FILE: src/getopt.c
================================================
/* Getopt for GNU.
   NOTE: getopt is now part of the C library, so if you don't know what
   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
   before changing it!

   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97
        Free Software Foundation, Inc.

   NOTE: The canonical source of this file is maintained with the GNU C Library.
   Bugs can be reported to bug-glibc@prep.ai.mit.edu.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
   USA.  */

/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
   Ditto for AIX 3.2 and <stdlib.h>.  */

#ifndef _NO_PROTO
#define _NO_PROTO
#endif

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <strings.h>

#ifndef HAVE_GETOPT_LONG

#if !defined (__STDC__) || !__STDC__
/* This is a separate conditional since some stdc systems
   reject `defined (const)'.  */
#ifndef const
#define const
#endif
#endif

#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#define GETOPT_INTERFACE_VERSION 2
#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2
#include <gnu-versions.h>
#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
#define ELIDE_CODE
#endif
#endif

#ifndef ELIDE_CODE


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef  __GNU_LIBRARY__
/* Don't include stdlib.h for non-GNU C libraries because some of them
   contain conflicting prototypes for getopt.  */
#include <stdlib.h>
#include <unistd.h>
#endif  /* GNU C library.  */

#ifdef VMS
#include <unixlib.h>
#if HAVE_STRING_H - 0
#include <string.h>
#endif
#endif

#ifndef _
/* This is for other GNU distributions with internationalized messages.
   When compiling libc, the _ macro is predefined.  */
#ifdef HAVE_LIBINTL_H
# include <libintl.h>
# define _(msgid)       gettext (msgid)
#else
# define _(msgid)       (msgid)
#endif
#endif

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.

   Setting the environment variable POSIXLY_CORRECT disables permutation.
   Then the behavior is completely standard.

   GNU application programs can use a third alternative mode in which
   they can distinguish the relative order of options and other arguments.  */

#include "getopt.h"

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

char *optarg = NULL;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

/* 1003.2 says this must be 1 before any call.  */
int optind = 1;

/* Formerly, initialization of getopt depended on optind==0, which
   causes problems with re-calling getopt as programs generally don't
   know that. */

int __getopt_initialized = 0;

/* The next char to be scanned in the option-element
   in which the last option character we returned was found.
   This allows us to pick up the scan where we left off.

   If this is zero, or a null string, it means resume the scan
   by advancing to the next ARGV-element.  */

static char *nextchar;

/* Callers store zero here to inhibit the error message
   for unrecognized options.  */

int opterr = 1;

/* Set to an option character which was unrecognized.
   This must be initialized on some systems to avoid linking in the
   system's own getopt implementation.  */

int optopt = '?';

/* Describe how to deal with options that follow non-option ARGV-elements.

   If the caller did not specify anything,
   the default is REQUIRE_ORDER if the environment variable
   POSIXLY_CORRECT is defined, PERMUTE otherwise.

   REQUIRE_ORDER means don't recognize them as options;
   stop option processing when the first non-option is seen.
   This is what Unix does.
   This mode of operation is selected by either setting the environment
   variable POSIXLY_CORRECT, or using `+' as the first character
   of the list of option characters.

   PERMUTE is the default.  We permute the contents of ARGV as we scan,
   so that eventually all the non-options are at the end.  This allows options
   to be given in any order, even with programs that were not written to
   expect this.

   RETURN_IN_ORDER is an option available to programs that were written
   to expect options and other ARGV-elements in any order and that care about
   the ordering of the two.  We describe each non-option ARGV-element
   as if it were the argument of an option with character code 1.
   Using `-' as the first character of the list of option characters
   selects this mode of operation.

   The special argument `--' forces an end of option-scanning regardless
   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */

static enum
{
  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
} ordering;

/* Value of POSIXLY_CORRECT environment variable.  */
static char *posixly_correct;

#ifdef  __GNU_LIBRARY__
/* We want to avoid inclusion of string.h with non-GNU libraries
   because there are many ways it can cause trouble.
   On some systems, it contains special magic macros that don't work
   in GCC.  */
#include <string.h>
#define my_index        strchr
#else

/* Avoid depending on library functions or files
   whose names are inconsistent.  */

char *getenv ();

static char *
my_index (str, chr)
     const char *str;
     int chr;
{
  while (*str)
    {
      if (*str == chr)
        return (char *) str;
      str++;
    }
  return 0;
}

/* If using GCC, we can safely declare strlen this way.
   If not using GCC, it is ok not to declare it.  */
#ifdef __GNUC__
/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
   That was relevant to code that was here before.  */
#if !defined (__STDC__) || !__STDC__
/* gcc with -traditional declares the built-in strlen to return int,
   and has done so at least since version 2.4.5. -- rms.  */
extern int strlen (const char *);
#endif /* not __STDC__ */
#endif /* __GNUC__ */

#endif /* not __GNU_LIBRARY__ */

/* Handle permutation of arguments.  */

/* Describe the part of ARGV that contains non-options that have
   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
   `last_nonopt' is the index after the last of them.  */

static int first_nonopt;
static int last_nonopt;

#ifdef _LIBC
/* Bash 2.0 gives us an environment variable containing flags
   indicating ARGV elements that should not be considered arguments.  */

/* Defined in getopt_init.c  */
extern char *__getopt_nonoption_flags;

static int nonoption_flags_max_len;
static int nonoption_flags_len;

static int original_argc;
static char *const *original_argv;

/* Make sure the environment variable bash 2.0 puts in the environment
   is valid for the getopt call we must make sure that the ARGV passed
   to getopt is that one passed to the process.  */
static void
__attribute__ ((unused))
store_args_and_env (int argc, char *const *argv)
{
  /* XXX This is no good solution.  We should rather copy the args so
     that we can compare them later.  But we must not use malloc(3).  */
  original_argc = argc;
  original_argv = argv;
}
# ifdef text_set_element
text_set_element (__libc_subinit, store_args_and_env);
# endif /* text_set_element */

# define SWAP_FLAGS(ch1, ch2) \
  if (nonoption_flags_len > 0)                                                \
    {                                                                         \
      char __tmp = __getopt_nonoption_flags[ch1];                             \
      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];          \
      __getopt_nonoption_flags[ch2] = __tmp;                                  \
    }
#else   /* !_LIBC */
# define SWAP_FLAGS(ch1, ch2)
#endif  /* _LIBC */

/* Exchange two adjacent subsequences of ARGV.
   One subsequence is elements [first_nonopt,last_nonopt)
   which contains all the non-options that have been skipped so far.
   The other is elements [last_nonopt,optind), which contains all
   the options processed since those non-options were skipped.

   `first_nonopt' and `last_nonopt' are relocated so that they describe
   the new indices of the non-options in ARGV after they are moved.  */

#if defined (__STDC__) && __STDC__
static void exchange (char **);
#endif

static void
exchange (argv)
     char **argv;
{
  int bottom = first_nonopt;
  int middle = last_nonopt;
  int top = optind;
  char *tem;

  /* Exchange the shorter segment with the far end of the longer segment.
     That puts the shorter segment into the right place.
     It leaves the longer segment in the right place overall,
     but it consists of two parts that need to be swapped next.  */

#ifdef _LIBC
  /* First make sure the handling of the `__getopt_nonoption_flags'
     string can work normally.  Our top argument must be in the range
     of the string.  */
  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
    {
      /* We must extend the array.  The user plays games with us and
         presents new arguments.  */
      char *new_str = malloc (top + 1);
      if (new_str == NULL)
        nonoption_flags_len = nonoption_flags_max_len = 0;
      else
        {
          memset (__mempcpy (new_str, __getopt_nonoption_flags,
                             nonoption_flags_max_len),
                  '\0', top + 1 - nonoption_flags_max_len);
          nonoption_flags_max_len = top + 1;
          __getopt_nonoption_flags = new_str;
        }
    }
#endif

  while (top > middle && middle > bottom)
    {
      if (top - middle > middle - bottom)
        {
          /* Bottom segment is the short one.  */
          int len = middle - bottom;
          register int i;

          /* Swap it with the top part of the top segment.  */
          for (i = 0; i < len; i++)
            {
              tem = argv[bottom + i];
              argv[bottom + i] = argv[top - (middle - bottom) + i];
              argv[top - (middle - bottom) + i] = tem;
              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
            }
          /* Exclude the moved bottom segment from further swapping.  */
          top -= len;
        }
      else
        {
          /* Top segment is the short one.  */
          int len = top - middle;
          register int i;

          /* Swap it with the bottom part of the bottom segment.  */
          for (i = 0; i < len; i++)
            {
              tem = argv[bottom + i];
              argv[bottom + i] = argv[middle + i];
              argv[middle + i] = tem;
              SWAP_FLAGS (bottom + i, middle + i);
            }
          /* Exclude the moved top segment from further swapping.  */
          bottom += len;
        }
    }

  /* Update records for the slots the non-options now occupy.  */

  first_nonopt += (optind - last_nonopt);
  last_nonopt = optind;
}

/* Initialize the internal data when the first call is made.  */

#if defined (__STDC__) && __STDC__
static const char *_getopt_initialize (int, char *const *, const char *);
#endif
static const char *
_getopt_initialize (argc, argv, optstring)
     int argc;
     char *const *argv;
     const char *optstring;
{
  /* Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  first_nonopt = last_nonopt = optind;

  nextchar = NULL;

  posixly_correct = getenv ("POSIXLY_CORRECT");

  /* Determine how to handle the ordering of options and nonoptions.  */

  if (optstring[0] == '-')
    {
      ordering = RETURN_IN_ORDER;
      ++optstring;
    }
  else if (optstring[0] == '+')
    {
      ordering = REQUIRE_ORDER;
      ++optstring;
    }
  else if (posixly_correct != NULL)
    ordering = REQUIRE_ORDER;
  else
    ordering = PERMUTE;

#ifdef _LIBC
  if (posixly_correct == NULL
      && argc == original_argc && argv == original_argv)
    {
      if (nonoption_flags_max_len == 0)
        {
          if (__getopt_nonoption_flags == NULL
              || __getopt_nonoption_flags[0] == '\0')
            nonoption_flags_max_len = -1;
          else
            {
              const char *orig_str = __getopt_nonoption_flags;
              int len = nonoption_flags_max_len = strlen (orig_str);
              if (nonoption_flags_max_len < argc)
                nonoption_flags_max_len = argc;
              __getopt_nonoption_flags =
                (char *) malloc (nonoption_flags_max_len);
              if (__getopt_nonoption_flags == NULL)
                nonoption_flags_max_len = -1;
              else
                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
                        '\0', nonoption_flags_max_len - len);
            }
        }
      nonoption_flags_len = nonoption_flags_max_len;
    }
  else
    nonoption_flags_len = 0;
#endif

  return optstring;
}

/* Scan elements of ARGV (whose length is ARGC) for option characters
   given in OPTSTRING.

   If an element of ARGV starts with '-', and is not exactly "-" or "--",
   then it is an option element.  The characters of this element
   (aside from the initial '-') are option characters.  If `getopt'
   is called repeatedly, it returns successively each of the option characters
   from each of the option elements.

   If `getopt' finds another option character, it returns that character,
   updating `optind' and `nextchar' so that the next call to `getopt' can
   resume the scan with the following option character or ARGV-element.

   If there are no more option characters, `getopt' returns -1.
   Then `optind' is the index in ARGV of the first ARGV-element
   that is not an option.  (The ARGV-elements have been permuted
   so that those that are not options now come last.)

   OPTSTRING is a string containing the legitimate option characters.
   If an option character is seen that is not listed in OPTSTRING,
   return '?' after printing an error message.  If you set `opterr' to
   zero, the error message is suppressed but we still return '?'.

   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
   so the following text in the same ARGV-element, or the text of the following
   ARGV-element, is returned in `optarg'.  Two colons mean an option that
   wants an optional arg; if there is text in the current ARGV-element,
   it is returned in `optarg', otherwise `optarg' is set to zero.

   If OPTSTRING starts with `-' or `+', it requests different methods of
   handling the non-option ARGV-elements.
   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.

   Long-named options begin with `--' instead of `-'.
   Their names may be abbreviated as long as the abbreviation is unique
   or is an exact match for some defined option.  If they have an
   argument, it follows the option name in the same ARGV-element, separated
   from the option name by a `=', or else the in next ARGV-element.
   When `getopt' finds a long-named option, it returns 0 if that option's
   `flag' field is nonzero, the value of the option's `val' field
   if the `flag' field is zero.

   The elements of ARGV aren't really const, because we permute them.
   But we pretend they're const in the prototype to be compatible
   with other systems.

   LONGOPTS is a vector of `struct option' terminated by an
   element containing a name which is zero.

   LONGIND returns the index in LONGOPT of the long-named option found.
   It is only valid when a long-named option has been found by the most
   recent call.

   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
   long-named options.  */

int
_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
     int argc;
     char *const *argv;
     const char *optstring;
     const struct option *longopts;
     int *longind;
     int long_only;
{
  optarg = NULL;

  if (optind == 0 || !__getopt_initialized)
    {
      if (optind == 0)
        optind = 1;     /* Don't scan ARGV[0], the program name.  */
      optstring = _getopt_initialize (argc, argv, optstring);
      __getopt_initialized = 1;
    }

  /* Test whether ARGV[optind] points to a non-option argument.
     Either it does not have option syntax, or there is an environment flag
     from the shell indicating it is not an option.  The later information
     is only used when the used in the GNU libc.  */
#ifdef _LIBC
#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'        \
                     || (optind < nonoption_flags_len                         \
                         && __getopt_nonoption_flags[optind] == '1'))
#else
#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
#endif

  if (nextchar == NULL || *nextchar == '\0')
    {
      /* Advance to the next ARGV-element.  */

      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
         moved back by the user (who may also have changed the arguments).  */
      if (last_nonopt > optind)
        last_nonopt = optind;
      if (first_nonopt > optind)
        first_nonopt = optind;

      if (ordering == PERMUTE)
        {
          /* If we have just processed some options following some non-options,
             exchange them so that the options come first.  */

          if (first_nonopt != last_nonopt && last_nonopt != optind)
            exchange ((char **) argv);
          else if (last_nonopt != optind)
            first_nonopt = optind;

          /* Skip any additional non-options
             and extend the range of non-options previously skipped.  */

          while (optind < argc && NONOPTION_P)
            optind++;
          last_nonopt = optind;
        }

      /* The special ARGV-element `--' means premature end of options.
         Skip it like a null option,
         then exchange with previous non-options as if it were an option,
         then skip everything else like a non-option.  */

      if (optind != argc && !strcmp (argv[optind], "--"))
        {
          optind++;

          if (first_nonopt != last_nonopt && last_nonopt != optind)
            exchange ((char **) argv);
          else if (first_nonopt == last_nonopt)
            first_nonopt = optind;
          last_nonopt = argc;

          optind = argc;
        }

      /* If we have done all the ARGV-elements, stop the scan
         and back over any non-options that we skipped and permuted.  */

      if (optind == argc)
        {
          /* Set the next-arg-index to point at the non-options
             that we previously skipped, so the caller will digest them.  */
          if (first_nonopt != last_nonopt)
            optind = first_nonopt;
          return -1;
        }

      /* If we have come to a non-option and did not permute it,
         either stop the scan or describe it to the caller and pass it by.  */

      if (NONOPTION_P)
        {
          if (ordering == REQUIRE_ORDER)
            return -1;
          optarg = argv[optind++];
          return 1;
        }

      /* We have found another option-ARGV-element.
         Skip the initial punctuation.  */

      nextchar = (argv[optind] + 1
                  + (longopts != NULL && argv[optind][1] == '-'));
    }

  /* Decode the current option-ARGV-element.  */

  /* Check whether the ARGV-element is a long option.

     If long_only and the ARGV-element has the form "-f", where f is
     a valid short option, don't consider it an abbreviated form of
     a long option that starts with f.  Otherwise there would be no
     way to give the -f short option.

     On the other hand, if there's a long option "fubar" and
     the ARGV-element is "-fu", do consider that an abbreviation of
     the long option, just like "--fu", and not "-f" with arg "u".

     This distinction seems to be the most useful approach.  */

  if (longopts != NULL
      && (argv[optind][1] == '-'
          || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
    {
      char *nameend;
      const struct option *p;
      const struct option *pfound = NULL;
      int exact = 0;
      int ambig = 0;
      int indfound = -1;
      int option_index;

      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        /* Do nothing.  */ ;

      /* Test all long options for either exact match
         or abbreviated matches.  */
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        if (!strncmp (p->name, nextchar, nameend - nextchar))
          {
            if ((unsigned int) (nameend - nextchar)
                == (unsigned int) strlen (p->name))
              {
                /* Exact match found.  */
                pfound = p;
                indfound = option_index;
                exact = 1;
                break;
              }
            else if (pfound == NULL)
              {
                /* First nonexact match found.  */
                pfound = p;
                indfound = option_index;
              }
            else
              /* Second or later nonexact match found.  */
              ambig = 1;
          }

      if (ambig && !exact)
        {
          if (opterr)
            fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
                     argv[0], argv[optind]);
          nextchar += strlen (nextchar);
          optind++;
          optopt = 0;
          return '?';
        }

      if (pfound != NULL)
        {
          option_index = indfound;
          optind++;
          if (*nameend)
            {
              /* Don't test has_arg with >, because some C compilers don't
                 allow it to be used on enums.  */
              if (pfound->has_arg)
                optarg = nameend + 1;
              else
                {
                  if (opterr)
                  {
                   if (argv[optind - 1][1] == '-')
                    /* --option */
                    fprintf (stderr,
                     _("%s: option `--%s' doesn't allow an argument\n"),
                     argv[0], pfound->name);
                   else
                    /* +option or -option */
                    fprintf (stderr,
                     _("%s: option `%c%s' doesn't allow an argument\n"),
                     argv[0], argv[optind - 1][0], pfound->name);
                  }
                  nextchar += strlen (nextchar);

                  optopt = pfound->val;
                  return '?';
                }
            }
          else if (pfound->has_arg == 1)
            {
              if (optind < argc)
                optarg = argv[optind++];
              else
                {
                  if (opterr)
                    fprintf (stderr,
                           _("%s: option `%s' requires an argument\n"),
                           argv[0], argv[optind - 1]);
                  nextchar += strlen (nextchar);
                  optopt = pfound->val;
                  return optstring[0] == ':' ? ':' : '?';
                }
            }
          nextchar += strlen (nextchar);
          if (longind != NULL)
            *longind = option_index;
          if (pfound->flag)
            {
              *(pfound->flag) = pfound->val;
              return 0;
            }
          return pfound->val;
        }

      /* Can't find it as a long option.  If this is not getopt_long_only,
         or the option starts with '--' or is not a valid short
         option, then it's an error.
         Otherwise interpret it as a short option.  */
      if (!long_only || argv[optind][1] == '-'
          || my_index (optstring, *nextchar) == NULL)
        {
          if (opterr)
            {
              if (argv[optind][1] == '-')
                /* --option */
                fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
                         argv[0], nextchar);
              else
                /* +option or -option */
                fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
                         argv[0], argv[optind][0], nextchar);
            }
          nextchar = (char *) "";
          optind++;
          optopt = 0;
          return '?';
        }
    }

  /* Look at and handle the next short option-character.  */

  {
    char c = *nextchar++;
    char *temp = my_index (optstring, c);

    /* Increment `optind' when we start to process its last character.  */
    if (*nextchar == '\0')
      ++optind;

    if (temp == NULL || c == ':')
      {
        if (opterr)
          {
            if (posixly_correct)
              /* 1003.2 specifies the format of this message.  */
              fprintf (stderr, _("%s: illegal option -- %c\n"),
                       argv[0], c);
            else
              fprintf (stderr, _("%s: invalid option -- %c\n"),
                       argv[0], c);
          }
        optopt = c;
        return '?';
      }
    /* Convenience. Treat POSIX -W foo same as long option --foo */
    if (temp[0] == 'W' && temp[1] == ';')
      {
        char *nameend;
        const struct option *p;
        const struct option *pfound = NULL;
        int exact = 0;
        int ambig = 0;
        int indfound = 0;
        int option_index;

        /* This is an option that requires an argument.  */
        if (*nextchar != '\0')
          {
            optarg = nextchar;
            /* If we end this ARGV-element by taking the rest as an arg,
               we must advance to the next element now.  */
            optind++;
          }
        else if (optind == argc)
          {
            if (opterr)
              {
                /* 1003.2 specifies the format of this message.  */
                fprintf (stderr, _("%s: option requires an argument -- %c\n"),
                         argv[0], c);
              }
            optopt = c;
            if (optstring[0] == ':')
              c = ':';
            else
              c = '?';
            return c;
          }
        else
          /* We already incremented `optind' once;
             increment it again when taking next ARGV-elt as argument.  */
          optarg = argv[optind++];

        /* optarg is now the argument, see if it's in the
           table of longopts.  */

        for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
          /* Do nothing.  */ ;

        /* Test all long options for either exact match
           or abbreviated matches.  */
        for (p = longopts, option_index = 0; p->name; p++, option_index++)
          if (!strncmp (p->name, nextchar, nameend - nextchar))
            {
              if ((unsigned int) (nameend - nextchar) == strlen (p->name))
                {
                  /* Exact match found.  */
                  pfound = p;
                  indfound = option_index;
                  exact = 1;
                  break;
                }
              else if (pfound == NULL)
                {
                  /* First nonexact match found.  */
                  pfound = p;
                  indfound = option_index;
                }
              else
                /* Second or later nonexact match found.  */
                ambig = 1;
            }
        if (ambig && !exact)
          {
            if (opterr)
              fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
                       argv[0], argv[optind]);
            nextchar += strlen (nextchar);
            optind++;
            return '?';
          }
        if (pfound != NULL)
          {
            option_index = indfound;
            if (*nameend)
              {
                /* Don't test has_arg with >, because some C compilers don't
                   allow it to be used on enums.  */
                if (pfound->has_arg)
                  optarg = nameend + 1;
                else
                  {
                    if (opterr)
                      fprintf (stderr, _("\
%s: option `-W %s' doesn't allow an argument\n"),
                               argv[0], pfound->name);

                    nextchar += strlen (nextchar);
                    return '?';
                  }
              }
            else if (pfound->has_arg == 1)
              {
                if (optind < argc)
                  optarg = argv[optind++];
                else
                  {
                    if (opterr)
                      fprintf (stderr,
                               _("%s: option `%s' requires an argument\n"),
                               argv[0], argv[optind - 1]);
                    nextchar += strlen (nextchar);
                    return optstring[0] == ':' ? ':' : '?';
                  }
              }
            nextchar += strlen (nextchar);
            if (longind != NULL)
              *longind = option_index;
            if (pfound->flag)
              {
                *(pfound->flag) = pfound->val;
                return 0;
              }
            return pfound->val;
          }
          nextchar = NULL;
          return 'W';   /* Let the application handle it.   */
      }
    if (temp[1] == ':')
      {
        if (temp[2] == ':')
          {
            /* This is an option that accepts an argument optionally.  */
            if (*nextchar != '\0')
              {
                optarg = nextchar;
                optind++;
              }
            else
              optarg = NULL;
            nextchar = NULL;
          }
        else
          {
            /* This is an option that requires an argument.  */
            if (*nextchar != '\0')
              {
                optarg = nextchar;
                /* If we end this ARGV-element by taking the rest as an arg,
                   we must advance to the next element now.  */
                optind++;
              }
            else if (optind == argc)
              {
                if (opterr)
                  {
                    /* 1003.2 specifies the format of this message.  */
                    fprintf (stderr,
                           _("%s: option requires an argument -- %c\n"),
                           argv[0], c);
                  }
                optopt = c;
                if (optstring[0] == ':')
                  c = ':';
                else
                  c = '?';
              }
            else
              /* We already incremented `optind' once;
                 increment it again when taking next ARGV-elt as argument.  */
              optarg = argv[optind++];
            nextchar = NULL;
          }
      }
    return c;
  }
}

int
getopt (argc, argv, optstring)
     int argc;
     char *const *argv;
     const char *optstring;
{
  return _getopt_internal (argc, argv, optstring,
                           (const struct option *) 0,
                           (int *) 0,
                           0);
}

#endif  /* Not ELIDE_CODE.  */

#ifdef TEST

/* Compile with -DTEST to make an executable for use in testing
   the above definition of `getopt'.  */

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;

      c = getopt (argc, argv, "abc:d:0123456789");
      if (c == -1)
        break;

      switch (c)
        {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          if (digit_optind != 0 && digit_optind != this_option_optind)
            printf ("digits occur in two different argv-elements.\n");
          digit_optind = this_option_optind;
          printf ("option %c\n", c);
          break;

        case 'a':
          printf ("option a\n");
          break;

        case 'b':
          printf ("option b\n");
          break;

        case 'c':
          printf ("option c with value `%s'\n", optarg);
          break;

        case '?':
          break;

        default:
          printf ("?? getopt returned character code 0%o ??\n", c);
        }
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
        printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */

#endif /* HAVE_GETOPT_LONG */



================================================
FILE: src/getopt.h
================================================
/* Declarations for getopt.
   Copyright (C) 1989,90,91,92,93,94,96,97 Free Software Foundation, Inc.

   NOTE: The canonical source of this file is maintained with the GNU C Library.
   Bugs can be reported to bug-glibc@prep.ai.mit.edu.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
   USA.  */

#ifndef _GETOPT_H
#define _GETOPT_H 1

#ifdef  __cplusplus
extern "C" {
#endif

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;

/* Describe the long-named options requested by the application.
   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
   of `struct option' terminated by an element containing a name which is
   zero.

   The field `has_arg' is:
   no_argument          (or 0) if the option does not take an argument,
   required_argument    (or 1) if the option requires an argument,
   optional_argument    (or 2) if the option takes an optional argument.

   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

struct option
{
#if defined (__STDC__) && __STDC__
  const char *name;
#else
  char *name;
#endif
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* Names for the values of the `has_arg' field of `struct option'.  */

#define no_argument             0
#define required_argument       1
#define optional_argument       2

#if defined (__STDC__) && __STDC__
#ifdef __GNU_LIBRARY__
/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int argc, char *const *argv, const char *shortopts);
#else /* not __GNU_LIBRARY__ */
extern int getopt ();
#endif /* __GNU_LIBRARY__ */
extern int getopt_long (int argc, char *const *argv, const char *shortopts,
                        const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
                             const char *shortopts,
                             const struct option *longopts, int *longind);

/* Internal only.  Users should not call this directly.  */
extern int _getopt_internal (int argc, char *const *argv,
                             const char *shortopts,
                             const struct option *longopts, int *longind,
                             int long_only);
#else /* not __STDC__ */
extern int getopt ();
extern int getopt_long ();
extern int getopt_long_only ();

extern int _getopt_internal ();
#endif /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif /* getopt.h */



================================================
FILE: src/getopt1.c
================================================
/* getopt_long and getopt_long_only entry points for GNU getopt.
   Copyright (C) 1987,88,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.

   NOTE: The canonical source of this file is maintained with the GNU C Library.
   Bugs can be reported to bug-glibc@prep.ai.mit.edu.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
   USA.  */


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifndef HAVE_GETOPT_LONG

#include "getopt.h"

#if !defined (__STDC__) || !__STDC__
/* This is a separate conditional since some stdc systems
   reject `defined (const)'.  */
#ifndef const
#define const
#endif
#endif

#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#define GETOPT_INTERFACE_VERSION 2
#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2
#include <gnu-versions.h>
#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
#define ELIDE_CODE
#endif
#endif

#ifndef ELIDE_CODE


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef __GNU_LIBRARY__
#include <stdlib.h>
#endif

#ifndef NULL
#define NULL 0
#endif

int
getopt_long (argc, argv, options, long_options, opt_index)
     int argc;
     char *const *argv;
     const char *options;
     const struct option *long_options;
     int *opt_index;
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
}

/* Like getopt_long, but '-' as well as '--' can indicate a long option.
   If an option that starts with '-' (not '--') doesn't match a long option,
   but does match a short option, it is parsed as a short option
   instead.  */

int
getopt_long_only (argc, argv, options, long_options, opt_index)
     int argc;
     char *const *argv;
     const char *options;
     const struct option *long_options;
     int *opt_index;
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
}


#endif  /* Not ELIDE_CODE.  */

#ifdef TEST

#include <stdio.h>

int
main (argc, argv)
     int argc;
     char **argv;
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;
      int option_index = 0;
      static struct option long_options[] =
      {
        {"add", 1, 0, 0},
        {"append", 0, 0, 0},
        {"delete", 1, 0, 0},
        {"verbose", 0, 0, 0},
        {"create", 0, 0, 0},
        {"file", 1, 0, 0},
        {0, 0, 0, 0}
      };

      c = getopt_long (argc, argv, "abc:d:0123456789",
                       long_options, &option_index);
      if (c == -1)
        break;

      switch (c)
        {
        case 0:
          printf ("option %s", long_options[option_index].name);
          if (optarg)
            printf (" with arg %s", optarg);
          printf ("\n");
          break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          if (digit_optind != 0 && digit_optind != this_option_optind)
            printf ("digits occur in two different argv-elements.\n");
          digit_optind = this_option_optind;
          printf ("option %c\n", c);
          break;

        case 'a':
          printf ("option a\n");
          break;

        case 'b':
          printf ("option b\n");
          break;

        case 'c':
          printf ("option c with value `%s'\n", optarg);
          break;

        case 'd':
          printf ("option d with value `%s'\n", optarg);
          break;

        case '?':
          break;

        default:
          printf ("?? getopt returned character code 0%o ??\n", c);
        }
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
        printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */

#endif /* HAVE_GETOPT_LONG */



================================================
FILE: src/globals.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "ratpoison.h"

#include <sys/types.h>
#include <sys/wait.h>

#include <ctype.h>
#include <errno.h>
#if defined (HAVE_PWD_H) && defined (HAVE_GETPWUID)
# include <pwd.h>
#endif
#include <signal.h>
#include <unistd.h>

/* Several systems seem not to have WAIT_ANY defined, so define it if
   it isn't. */
#ifndef WAIT_ANY
# define WAIT_ANY -1
#endif

/* Some systems don't define the close-on-exec flag in fcntl.h */
#ifndef FD_CLOEXEC
# define FD_CLOEXEC 1
#endif

int alarm_signalled = 0;
int kill_signalled = 0;
int hup_signalled = 0;
int chld_signalled = 0;
int rat_x;
int rat_y;
int rat_visible = 1;            /* rat is visible by default */

char *rp_exec_newwm = NULL;

int rp_font_ascent, rp_font_descent, rp_font_width;

Atom wm_name;
Atom wm_state;
Atom wm_change_state;
Atom wm_protocols;
Atom wm_delete;
Atom wm_take_focus;
Atom wm_colormaps;

Atom rp_command;
Atom rp_command_request;
Atom rp_command_result;
Atom rp_selection;

/* TEXT atoms */
Atom xa_string;
Atom xa_compound_text;
Atom xa_utf8_string;

/* netwm atoms */
Atom _net_wm_pid;
Atom _net_supported;
Atom _net_wm_window_type;
Atom _net_wm_window_type_dialog;
Atom _net_wm_name;

LIST_HEAD (rp_screens);
rp_screen *rp_current_screen;
rp_global_screen rp_glob_screen;

Display *dpy;

int rp_have_xrandr;

rp_group *rp_current_group;
LIST_HEAD (rp_groups);
LIST_HEAD (rp_children);
struct rp_defaults defaults;

int ignore_badwindow = 0;

char **myargv;

struct rp_key prefix_key;

struct modifier_info rp_modifier_info;

/* rudeness levels */
int rp_honour_transient_raise = 1;
int rp_honour_normal_raise = 1;
int rp_honour_transient_map = 1;
int rp_honour_normal_map = 1;

char *rp_error_msg = NULL;

/* Global frame numset */
struct numset *rp_frame_numset;

/* The X11 selection globals */
rp_xselection selection;

static void
x_export_selection (void)
{
  rp_screen *screen;

  list_first(screen, &rp_screens, node);
  if (!screen)
    return;

  /* Hang the selections off screen 0's key window. */
  XSetSelectionOwner (dpy, XA_PRIMARY, screen->key_window, CurrentTime);
  if (XGetSelectionOwner (dpy, XA_PRIMARY) != screen->key_window)
    PRINT_ERROR(("can't get primary selection"));
  XChangeProperty(dpy, screen->root, XA_CUT_BUFFER0, xa_string, 8,
                  PropModeReplace, (unsigned char*)selection.text, selection.len);
}

void
set_nselection (char *txt, int len)
{
  int i;

  /* Update the selection structure */
  free (selection.text);

  /* Copy the string by hand. */
  selection.text = xmalloc (len + 1);
  selection.len = len + 1;
  for (i=0; i<len; i++)
    selection.text[i] = txt[i];
  selection.text[len] = 0;

  x_export_selection();
}

void
set_selection (char *txt)
{
  /* Update the selection structure */
  free (selection.text);
  selection.text = xstrdup (txt);
  selection.len = strlen (txt);

  x_export_selection();
}

static char *
get_cut_buffer (void)
{
  int nbytes;
  char *data;

  PRINT_DEBUG (("trying the cut buffer\n"));

  data = XFetchBytes (dpy, &nbytes);

  if (data)
    {
      struct sbuf *s = sbuf_new (0);
      sbuf_nconcat (s, data, nbytes);
      XFree (data);
      return sbuf_free_struct (s);
    }
  else
    return NULL;
}

/* Lifted the code from rxvt. */
static char *
get_primary_selection(void)
{
  long            nread;
  unsigned long   bytes_after;
  XTextProperty   ct;
  struct sbuf *s = sbuf_new(0);

  for (nread = 0, bytes_after = 1; bytes_after > 0; nread += ct.nitems) {
    if ((XGetWindowProperty (dpy, rp_current_screen->input_window, rp_selection, (nread / 4), 4096,
                             True, AnyPropertyType, &ct.encoding,
                             &ct.format, &ct.nitems, &bytes_after,
                             &ct.value) != Success)) {
      XFree(ct.value);
      sbuf_free(s);
      return NULL;
    }
    if (ct.value == NULL)
      continue;
    /* Accumulate the data. FIXME: ct.value may not be NULL
       terminated. */
    sbuf_nconcat (s, (const char*)ct.value, ct.nitems);
    XFree(ct.value);
  }
  return sbuf_free_struct (s);
}

char *
get_selection (void)
{
  Atom property;
  XEvent ev;
  rp_screen *s = rp_current_screen;
  int loops = 1000;

  /* Just insert our text, if we own the selection. */
  if (selection.text)
    {
      return xstrdup (selection.text);
    }
  else
    {
      /* be a good icccm citizen */
      XDeleteProperty (dpy, s->input_window, rp_selection);
      /* TODO: we shouldn't use CurrentTime here, use the time of the XKeyEvent, should we fake it? */
      XConvertSelection (dpy, XA_PRIMARY, xa_string, rp_selection, s->input_window, CurrentTime);

      /* This seems like a hack. */
      while (!XCheckTypedWindowEvent (dpy, s->input_window, SelectionNotify, &ev))
        {
          if (loops == 0)
            {
              PRINT_ERROR (("selection request timed out\n"));
              return NULL;
            }
          usleep (10000);
          loops--;
        }

      PRINT_DEBUG (("SelectionNotify event\n"));

      property = ev.xselection.property;

      if (property != None)
        return get_primary_selection ();
      else
        return get_cut_buffer ();
    }
}

/* The hook dictionary globals. */

LIST_HEAD (rp_key_hook);
LIST_HEAD (rp_switch_win_hook);
LIST_HEAD (rp_switch_frame_hook);
LIST_HEAD (rp_switch_group_hook);
LIST_HEAD (rp_switch_screen_hook);
LIST_HEAD (rp_quit_hook);
LIST_HEAD (rp_restart_hook);
LIST_HEAD (rp_delete_window_hook);
LIST_HEAD (rp_new_window_hook);
LIST_HEAD (rp_title_changed_hook);

struct rp_hook_db_entry rp_hook_db[]=
  {{"key",              &rp_key_hook},
   {"switchwin",        &rp_switch_win_hook},
   {"switchframe",      &rp_switch_frame_hook},
   {"switchgroup",      &rp_switch_group_hook},
   {"switchscreen",      &rp_switch_screen_hook},
   {"deletewindow",     &rp_delete_window_hook},
   {"quit",             &rp_quit_hook},
   {"restart",          &rp_restart_hook},
   {"newwindow",	&rp_new_window_hook},
   {"titlechanged",	&rp_title_changed_hook},
   {NULL, NULL}};

void
set_rp_window_focus (rp_window *win)
{
  PRINT_DEBUG (("Giving focus to '%s'\n", window_name (win)));
  XSetInputFocus (dpy, win->w,
                  RevertToPointerRoot, CurrentTime);
}

void
set_window_focus (Window window)
{
  PRINT_DEBUG (("Giving focus to %ld\n", window));
  XSetInputFocus (dpy, window,
                  RevertToPointerRoot, CurrentTime);
}


/* Wrapper font functions to support Xft */

void
rp_draw_string (rp_screen *s, Drawable d, int style, int x, int y,
		char *string, int length)
{
  if (length < 0)
    length = strlen (string);

#ifdef USE_XFT_FONT
  if (s->xft_font)
    {
      XftDraw *draw;
      draw = XftDrawCreate (dpy, d, DefaultVisual (dpy, s->screen_num),
                            DefaultColormap (dpy, s->screen_num));
      if (!draw)
	{
	  PRINT_ERROR (("Failed to allocate XftDraw object\n"));
	  return;
	}

      if (utf8_locale)
	{
	  XftDrawStringUtf8 (draw, style == STYLE_NORMAL ? &s->xft_fg_color :
			     &s->xft_bg_color, s->xft_font, x, y,
			     (FcChar8*) string, length);
	}
      else
	{
	  XftDrawString8 (draw, style == STYLE_NORMAL ? &s->xft_fg_color :
			  &s->xft_bg_color, s->xft_font, x, y,
			  (FcChar8*) string, length);
     	}
      XftDrawDestroy (draw);
    }
  else
    PRINT_ERROR (("No Xft font available.\n"));
#else
  XmbDrawString (dpy, d, defaults.font, style == STYLE_NORMAL ? s->normal_gc :
		 s->inverse_gc, x, y, string, length);
#endif
}

int
rp_text_width (rp_screen *s, char *string, int count)
{
  (void) s; /* avoid "unused" warning */
  if (count < 0)
    count = strlen (string);

#ifdef USE_XFT_FONT
  if (s->xft_font)
    {
      XGlyphInfo extents;
      if (utf8_locale)
        XftTextExtentsUtf8 (dpy, s->xft_font, (FcChar8*) string, count, &extents);
      else
        XftTextExtents8 (dpy, s->xft_font, (FcChar8*) string, count, &extents);
      return extents.xOff;
    }
  PRINT_ERROR (("No Xft font available.\n"));
  return 0;
#else
  return XmbTextEscapement (defaults.font, string, count);
#endif
}

/* A case insensitive strncmp. */
int
str_comp (char *s1, char *s2, size_t len)
{
  size_t i;

  for (i = 0; i < len; i++)
    if (toupper ((unsigned char)s1[i]) != toupper ((unsigned char)s2[i]))
      return 0;

  return 1;
}

/* Check for child processes that have quit but haven't been
   acknowledged yet. Update their structure. */
void
check_child_procs (void)
{
  rp_child_info *cur;
  int pid, status;
  while (1)
    {
      pid = waitpid (WAIT_ANY, &status, WNOHANG);
      if (pid <= 0)
        break;

      PRINT_DEBUG(("Child status: %d\n", WEXITSTATUS (status)));

      /* Find the child and update its structure. */
      list_for_each_entry (cur, &rp_children, node)
        {
          if (cur->pid == pid)
            {
              cur->terminated = 1;
              cur->status = WEXITSTATUS (status);
              break;
            }
        }

      chld_signalled = 1;
    }
}

void
chld_handler (int signum UNUSED)
{
  int serrno;

  serrno = errno;
  check_child_procs();
  errno = serrno;
}

void
set_sig_handler (int sig, void (*action)(int))
{
  struct sigaction act;

  memset (&act, 0, sizeof (act));
  act.sa_handler = action;
  sigemptyset (&act.sa_mask);
  if (sigaction (sig, &act, NULL))
    {
      PRINT_ERROR (("Error setting signal handler: %s\n",
                    strerror (errno)));
    }
}

void
set_close_on_exec (int fd)
{
  int flags = fcntl (fd, F_GETFD);
  if (flags >= 0)
    fcntl (fd, F_SETFD, flags | FD_CLOEXEC);
}

void
read_rc_file (FILE *file)
{
  char *line;
  size_t linesize = 256;

  line = xmalloc (linesize);

  while (getline (&line, &linesize, file) != -1)
    {
      line[strcspn (line, "\n")] = '\0';

      PRINT_DEBUG (("rcfile line: %s\n", line));

      if (*line != '\0' && *line != '#')
        {
          cmdret *result;
          result = command (0, line);

          /* Gobble the result. */
          if (result)
            cmdret_free (result);
        }
    }

  free (line);
}

const char *
get_homedir (void)
{
  char *homedir;

  homedir = getenv ("HOME");
  if (homedir != NULL && homedir[0] == '\0')
    homedir = NULL;

#if defined (HAVE_PWD_H) && defined (HAVE_GETPWUID)
  if (homedir == NULL)
    {
      struct passwd *pw;

      pw = getpwuid (getuid ());
      if (pw != NULL)
        homedir = pw->pw_dir;

      if (homedir != NULL && homedir[0] == '\0')
        homedir = NULL;
    }
#endif

  return homedir;
}

void
clean_up (void)
{
  rp_screen *cur;
  struct list_head *iter, *tmp;

  history_save ();

  free_keymaps ();
  free_aliases ();
  free_user_commands ();
  free_bar ();
  free_window_stuff ();
  free_groups ();

  list_for_each_safe_entry (cur, iter, tmp, &rp_screens, node)
    {
      list_del (&cur->node);
      screen_free (cur);
      free (cur);
    }

  screen_free_final ();

  /* Delete the undo histories */
  clear_frame_undos ();

  /* Free the global frame numset shared by all screens. */
  numset_free (rp_frame_numset);

#ifndef USE_XFT_FONT
  XFreeFontSet (dpy, defaults.font);
#endif
  free (defaults.window_fmt);

  XSetInputFocus (dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
  XCloseDisplay (dpy);
}



================================================
FILE: src/globals.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef GLOBALS_H
#define GLOBALS_H

#include "data.h"

/* codes used in the cmdret code in actions.c */
#define RET_SUCCESS 1
#define RET_FAILURE 0

#ifdef USE_XFT_FONT
#include <X11/Xft/Xft.h>

#define FONT_HEIGHT(s) ((s)->xft_font->ascent + (s)->xft_font->descent)
#define FONT_ASCENT(s) ((s)->xft_font->ascent)

#else

#define FONT_HEIGHT(f) (rp_font_ascent + rp_font_descent)
#define FONT_ASCENT(f) (rp_font_ascent)

#endif

#define MAX_FONT_WIDTH(f) (rp_font_width)

#define WIN_EVENTS (StructureNotifyMask | PropertyChangeMask | ColormapChangeMask | FocusChangeMask)
/* EMPTY is used when a frame doesn't contain a window, or a window
   doesn't have a frame. Any time a field refers to the number of a
   window/frame/screen/etc, Use EMPTY to denote a lack there of. */
#define EMPTY -1

/* Possible values for defaults.window_list_style */
#define STYLE_ROW    0
#define STYLE_COLUMN 1

/* Possible values for defaults.win_name */
#define WIN_NAME_TITLE          0
#define WIN_NAME_RES_CLASS      1
#define WIN_NAME_RES_NAME       2

/* Possible directions to traverse the completions list. */
#define COMPLETION_NEXT         0
#define COMPLETION_PREVIOUS     1

/* Error codes for group_delete_group() */
#define GROUP_DELETE_GROUP_OK         0
#define GROUP_DELETE_GROUP_NONEMPTY   1
#define GROUP_DELETE_LAST_GROUP       2

/* Font styles */
#define STYLE_NORMAL  0
#define STYLE_INVERSE 1

#ifdef __GNUC__
#define UNUSED __attribute__ ((unused))
#else
#define UNUSED
#endif

/* The list of groups. */
extern struct list_head rp_groups;

/* Whether or not we support xrandr */
extern int rp_have_xrandr;

extern rp_group *rp_current_group;

/* Each child process is stored in this list. spawn, creates a new
   entry in this list, the SIGCHLD handler sets child.terminated to be
   true and handle_signals in events.c processes each terminated
   process by printing a message saying the process ended and
   displaying it's exit code. */
extern struct list_head rp_children;

extern struct rp_defaults defaults;

/* Cached font info. */
extern int rp_font_ascent, rp_font_descent, rp_font_width;

/* The prefix key also known as the command character under screen. */
extern struct rp_key prefix_key;

/* A list of mapped windows. These windows show up in the window
   list and have a number assigned to them. */
extern struct list_head rp_mapped_window;

/* A list of unmapped windows. These windows do not have a number
   assigned to them and are not visible/active. */
extern struct list_head rp_unmapped_window;

/* The list of screens. */
extern struct list_head rp_screens;
extern rp_screen *rp_current_screen;
extern rp_global_screen rp_glob_screen;

extern XEvent rp_current_event;

extern Display *dpy;
extern Atom rp_command;
extern Atom rp_command_request;
extern Atom rp_command_result;
extern Atom rp_selection;

extern Atom wm_name;
extern Atom wm_state;
extern Atom wm_change_state;
extern Atom wm_protocols;
extern Atom wm_delete;
extern Atom wm_take_focus;
extern Atom wm_colormaps;

/* TEXT atoms */
extern Atom xa_string;
extern Atom xa_compound_text;
extern Atom xa_utf8_string;

/* netwm atoms. */
extern Atom _net_wm_pid;
extern Atom _net_supported;
extern Atom _net_wm_window_type;
extern Atom _net_wm_window_type_dialog;
extern Atom _net_wm_name;

/* mouse properties */
extern int rat_x;
extern int rat_y;
extern int rat_visible;

/* When unmapping or deleting windows, it is sometimes helpful to
   ignore a bad window when attempting to clean the window up. This
   does just that when set to 1 */
extern int ignore_badwindow;

/* Arguments passed to ratpoison. */
extern char **myargv;

/* Keeps track of which mod mask each modifier is under. */
extern struct modifier_info rp_modifier_info;

/* nonzero if an alarm signal was raised. This means ratpoison should
   hide its popup windows. */
extern int alarm_signalled;
extern int kill_signalled;
extern int hup_signalled;
extern int chld_signalled;

/* When set to a string, ratpoison should exec the command. The reason
   this variable is needed and why it is not exec'd in cmd_newwm is
   because if called with ratpoison -c, the rp -c process never
   returns. */
extern char *rp_exec_newwm;

/* rudeness levels */
extern int rp_honour_transient_raise;
extern int rp_honour_normal_raise;
extern int rp_honour_transient_map;
extern int rp_honour_normal_map;

/* Keep track of X11 error messages. */
extern char *rp_error_msg;

/* Number sets for windows. */
extern struct numset *rp_window_numset;

extern struct list_head rp_key_hook;
extern struct list_head rp_switch_win_hook;
extern struct list_head rp_switch_frame_hook;
extern struct list_head rp_switch_group_hook;
extern struct list_head rp_switch_screen_hook;
extern struct list_head rp_delete_window_hook;
extern struct list_head rp_quit_hook;
extern struct list_head rp_restart_hook;
extern struct list_head rp_new_window_hook;
extern struct list_head rp_title_changed_hook;

extern struct rp_hook_db_entry rp_hook_db[];

void set_rp_window_focus (rp_window *win);
void set_window_focus (Window window);

extern struct numset *rp_frame_numset;

/* Selection handling globals */
extern rp_xselection selection;
void set_selection (char *txt);
void set_nselection (char *txt, int len);
char *get_selection (void);

/* Wrapper font functions to support Xft */

void rp_draw_string (rp_screen *s, Drawable d, int style, int x, int y, char *string, int length);
int rp_text_width (rp_screen *s, char *string, int count);

void check_child_procs (void);
void chld_handler (int signum);
void set_sig_handler (int sig, void (*action)(int));
void set_close_on_exec (int fd);
void read_rc_file (FILE *file);
const char *get_homedir (void);
void clean_up (void);

#endif



================================================
FILE: src/group.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "ratpoison.h"

#include <string.h>

static struct numset *group_numset;

static void
set_current_group_1 (rp_group *g)
{
  static int counter = 1;
  rp_current_group = g;
  if (g)
    g->last_access = counter++;
}

void
init_groups(void)
{
  rp_group *g;

  group_numset = numset_new();
  INIT_LIST_HEAD (&rp_groups);

  /* Create the first group in the list (We always need at least
     one). */
  g = group_new (numset_request (group_numset), DEFAULT_GROUP_NAME);
  set_current_group_1 (g);
  list_add_tail (&g->node, &rp_groups);
}

void
free_groups(void)
{
  rp_group *cur;
  struct list_head *iter, *tmp;

  list_for_each_safe_entry (cur, iter, tmp, &rp_groups, node)
    {
      group_free (cur);
    }
}

struct numset *
group_get_numset(void)
{
  return group_numset;
}

/* get the group list and store it in buffer delimiting each window
   with delim. mark_start and mark_end will be filled with the text
   positions for the start and end of the current window. */
void
get_group_list (char *delim, struct sbuf *buffer,
                int *mark_start, int *mark_end)
{
  rp_group *cur, *last;

  if (buffer == NULL) return;

  sbuf_clear (buffer);

  last = group_last_group ();

  /* Generate the string. */
  list_for_each_entry (cur, &rp_groups, node)
    {
      char *fmt;
      char separator;

      if (cur == rp_current_group)
        *mark_start = strlen (sbuf_get (buffer));

      if(cur == rp_current_group)
        separator = '*';
      else if(cur == last)
        separator = '+';
      else
        separator = '-';

      /* A hack, pad the group with a space at the beginning and end
         if there is no delimiter. */
      if (!delim)
        sbuf_concat (buffer, " ");

      fmt = xsprintf ("%d%c%s", cur->number, separator, cur->name);
      sbuf_concat (buffer, fmt);
      free (fmt);

      /* A hack, pad the group with a space at the beginning and end
         if there is no delimiter. */
      if (!delim)
        sbuf_concat (buffer, " ");

      /* Only put the delimiter between the group, and not after the the last
         group. */
      if (delim && cur->node.next != &rp_groups)
        sbuf_concat (buffer, delim);

      if (cur == rp_current_group)
        *mark_end = strlen (sbuf_get (buffer));
    }
}

rp_group *
group_new (int number, char *name)
{
  rp_group *g;

  g = xmalloc (sizeof (rp_group));

  if (name)
    g->name = xstrdup (name);
  else
    g->name = NULL;
  g->last_access = 0;
  g->number = number;
  g->numset = numset_new();
  INIT_LIST_HEAD (&g->unmapped_windows);
  INIT_LIST_HEAD (&g->mapped_windows);

  return g;
}

void
group_free (rp_group *g)
{
  free (g->name);
  numset_free (g->numset);
  numset_release (group_numset, g->number);
  free (g);
}

rp_group *
group_add_new_group (char *name)
{
  rp_group *g;
  rp_group *cur;

  g = group_new (numset_request (group_numset), name);

  list_for_each_entry (cur, &rp_groups, node)
    {
      if (cur->number > g->number)
        {
          list_add_tail (&g->node, &cur->node);
          return g;
        }
    }

  list_add_tail (&g->node, &rp_groups);

  return g;
}

void
group_resort_group (rp_group *g)
{
  rp_group *cur;
  struct list_head *last = &rp_groups;

  list_del (&g->node);
  list_for_each_entry (cur, &rp_groups, node)
    {
      if (cur->number > g->number)
        {
          list_add (&g->node, last);
          return;
        }
      last = &cur->node;
    }
  list_add (&g->node, last);
}

void
group_rename (rp_group *g, char *name)
{
  free (g->name);
  g->name = xstrdup (name);
}

rp_group *
group_next_group (void)
{
  return list_next_entry (rp_current_group, &rp_groups, node);
}

rp_group *
group_prev_group (void)
{
  return list_prev_entry (rp_current_group, &rp_groups, node);
}

rp_group *
group_last_group (void)
{
  int last_access = 0;
  rp_group *most_recent = NULL;
  rp_group *cur;

  list_for_each_entry (cur, &rp_groups, node)
    {
      if (cur != rp_current_group && cur->last_access > last_access) {
        most_recent = cur;
	last_access = cur->last_access;
      }
    }
  return most_recent;
}

rp_group *
groups_find_group_by_name (char *s, int exact_match)
{
  rp_group *cur;

  if (!exact_match)
    {
      list_for_each_entry (cur, &rp_groups, node)
        {
          if (cur->name && str_comp (s, cur->name, strlen (s)))
            return cur;
        }
    }
  else
    {
      list_for_each_entry (cur, &rp_groups, node)
        {
          if (cur->name && !strcmp (cur->name, s))
            return cur;
        }
    }

  return NULL;
}

rp_group *
groups_find_group_by_number (int n)
{
  rp_group *cur;

  list_for_each_entry (cur, &rp_groups, node)
    {
      if (cur->number == n)
        return cur;
    }

  return NULL;
}

/* Return the first group that contains the window. */
rp_group *
groups_find_group_by_window (rp_window *win)
{
  rp_group *cur;
  rp_window_elem *elem;

  list_for_each_entry (cur, &rp_groups, node)
    {
      elem = group_find_window (&cur->mapped_windows, win);
      if (elem)
        return cur;
    }

  return NULL;
}


/* Return the first group that is g. */
rp_group *
groups_find_group_by_group (rp_group *g)
{
  rp_group *cur;

  list_for_each_entry (cur, &rp_groups, node)
    {
      if (cur == g)
        return cur;
    }

  return NULL;
}

rp_window_elem *
group_find_window (struct list_head *list, rp_window *win)
{
  rp_window_elem *cur;

  list_for_each_entry (cur, list, node)
    {
      if (cur->win == win)
        return cur;
    }

  return NULL;
}

rp_window_elem *
group_find_window_by_number (rp_group *g, int num)
{
  rp_window_elem *cur;

  list_for_each_entry (cur, &g->mapped_windows, node)
    {
      if (cur->number == num)
        return cur;
    }

  return NULL;

}


/* Insert a window_elem into the correct spot in the group's window
   list to preserve window number ordering. */
static void
group_insert_window (struct list_head *h, rp_window_elem *w)
{
  rp_window_elem *cur;

  list_for_each_entry (cur, h, node)
    {
      if (cur->number > w->number)
        {
          list_add_tail (&w->node, &cur->node);
          return;
        }
    }

  list_add_tail(&w->node, h);
}

static int
group_in_list (struct list_head *h, rp_window_elem *w)
{
  rp_window_elem *cur;

  list_for_each_entry (cur, h, node)
    {
      if (cur == w)
        return 1;
    }

  return 0;
}

/* If a window_elem's number has changed then the list has to be
   resorted. */
void
group_resort_window (rp_group *g, rp_window_elem *w)
{
  /* Only a mapped window can be resorted. */
  if (!group_in_list (&g->mapped_windows, w))
    {
      PRINT_DEBUG (("Attempting to restort an unmapped window!\n"));
      return;
    }

  list_del (&w->node);
  group_insert_window (&g->mapped_windows, w);
}

void
group_add_window (rp_group *g, rp_window *w)
{
  rp_window_elem *we;

  /* Create our container structure for the window. */
  we = xmalloc (sizeof (rp_window_elem));
  we->win = w;
  we->number = -1;

  /* Finally, add it to our list. */
  list_add_tail (&we->node, &g->unmapped_windows);
}

void
group_map_window (rp_group *g, rp_window *win)
{
  rp_window_elem *we;

  we = group_find_window (&g->unmapped_windows, win);

  if (we)
    {
      we->number = numset_request (g->numset);
      list_del (&we->node);
      group_insert_window (&g->mapped_windows, we);
    }
}

void
groups_map_window (rp_window *win)
{
  rp_group *cur;

  list_for_each_entry (cur, &rp_groups, node)
    {
      group_map_window (cur, win);
    }
}

void
group_unmap_window (rp_group *g, rp_window *win)
{
  rp_window_elem *we;

  we = group_find_window (&g->mapped_windows, win);

  if (we)
    {
      numset_release (g->numset, we->number);
      list_move_tail (&we->node, &g->unmapped_windows);
    }
}

void
groups_unmap_window (rp_window *win)
{
  rp_group *cur;

  list_for_each_entry (cur, &rp_groups, node)
    {
      group_unmap_window (cur, win);
    }
}

void
group_del_window (rp_group *g, rp_window *win)
{
  rp_window_elem *cur;
  struct list_head *iter, *tmp;

  /* The assumption is that a window is unmapped before it's deleted. */
  list_for_each_safe_entry (cur, iter, tmp, &g->unmapped_windows, node)
    {
      if (cur->win == win)
        {
          list_del (&cur->node);
          free (cur);
        }
    }

  /* Make sure the window isn't in the list of mapped windows. This
     would mean there is a bug. */
#ifdef DEBUG
  list_for_each_entry (cur, &g->mapped_windows, node)
    {
      if (cur->win == win)
        PRINT_DEBUG (("This window wasn't removed from the mapped window list.\n"));
    }
#endif
}

/* Remove the window from any groups in resides in. */
void
groups_del_window (rp_window *win)
{
  rp_group *cur;

  list_for_each_entry (cur, &rp_groups, node)
    {
      group_del_window (cur, win);
    }
}

rp_window *
group_last_window (rp_group *g, rp_screen *s)
{
  int last_access = 0;
  rp_window_elem *most_recent = NULL;
  rp_window_elem *cur;

  list_for_each_entry (cur, &g->mapped_windows, node)
    {
      if (cur->win->last_access >= last_access
          && cur->win != current_window()
          && !find_windows_frame (cur->win)
          && (cur->win->scr == s || rp_have_xrandr))
        {
          most_recent = cur;
          last_access = cur->win->last_access;
        }
    }

  if (most_recent)
    return most_recent->win;

  return NULL;
}

rp_window *
group_next_window (rp_group *g, rp_window *win)
{
  rp_window_elem *cur, *we;

  /* If there is no window, then get the last accessed one. */
  if (win == NULL)
    return group_last_window (g, rp_current_screen);

  /* If we can't find the window, then it's in a different group, so
     get the last accessed one in this group. */
  we = group_find_window (&g->mapped_windows, win);
  if (we == NULL)
    return group_last_window (g, win->scr);

  /* The window is in this group, so find the next one in the list
     that isn't already displayed. */
  for (cur = list_next_entry (we, &g->mapped_windows, node);
       cur != we;
       cur = list_next_entry (cur, &g->mapped_windows, node))
    {
      if (!find_windows_frame (cur->win) && (cur->win->scr == win->scr || rp_have_xrandr))
        {
          return cur->win;
        }
    }

  return NULL;
}

rp_window *
group_prev_window (rp_group *g, rp_window *win)
{
  rp_window_elem *cur, *we;

  /* If there is no window, then get the last accessed one. */
  if (win == NULL)
    return group_last_window (g, rp_current_screen);

  /* If we can't find the window, then it's in a different group, so
     get the last accessed one in this group. */
  we = group_find_window (&g->mapped_windows, win);
  if (we == NULL)
    return group_last_window (g, win->scr);

  /* The window is in this group, so find the previous one in the list
     that isn't already displayed. */
  for (cur = list_prev_entry (we, &g->mapped_windows, node);
       cur != we;
       cur = list_prev_entry (cur, &g->mapped_windows, node))
    {
      if (!find_windows_frame (cur->win) && (cur->win->scr == win->scr || rp_have_xrandr))
        {
          return cur->win;
        }
    }

  return NULL;

}

void
group_move_window (rp_group *to, rp_window *win)
{
  rp_group *cur, *from = NULL;
  rp_window_elem *we = NULL;

  /* Find the group that the window belongs to. FIXME: If the window
     exists in multiple groups, then we're going to find the first
     group with this window in it. */
  list_for_each_entry (cur, &rp_groups, node)
    {
      we = group_find_window (&cur->mapped_windows, win);
      if (we)
        {
          from = cur;
          break;
        }
    }

  if (we == NULL || from == NULL)
    {
      PRINT_DEBUG (("Unable to find window in mapped window lists.\n"));
      return;
    }

  /* Manually remove the window from one group...*/
  numset_release (from->numset, we->number);
  list_del (&we->node);

  /* and shove it into the other one. */
  we->number = numset_request (to->numset);
  group_insert_window (&to->mapped_windows, we);
}

void
groups_merge (rp_group *from, rp_group *to)
{
  rp_window_elem *cur;
  struct list_head *iter, *tmp;

  /* Merging a group with itself makes no sense. */
  if (from == to)
    return;

  /* Move the unmapped windows. */
  list_for_each_safe_entry (cur, iter, tmp, &from->unmapped_windows, node)
    {
      list_del (&cur->node);
      list_add_tail (&cur->node, &to->unmapped_windows);
    }

  /* Move the mapped windows. */
  list_for_each_safe_entry (cur, iter, tmp, &from->mapped_windows, node)
    {
      numset_release (from->numset, cur->number);
      list_del (&cur->node);

      cur->number = numset_request (to->numset);
      group_insert_window (&to->mapped_windows, cur);
    }
}

void
set_current_group (rp_group *g)
{
  if (rp_current_group == g || g == NULL)
    return;

  set_current_group_1 (g);

  /* Call the switch group hook. */
  hook_run (&rp_switch_group_hook);
}

int
group_delete_group (rp_group *g)
{
  if (list_empty (&(g->mapped_windows))
      && list_empty (&(g->unmapped_windows)))
    {
      /* don't delete the last group */
      if (list_size (&rp_groups) == 1)
        return GROUP_DELETE_LAST_GROUP;

      /* we can safely delete the group */
      if (g == rp_current_group)
        {
          rp_group *next = group_last_group ();
          set_current_group (next ? next : group_next_group ());
        }

      list_del (&(g->node));
      group_free (g);
      return GROUP_DELETE_GROUP_OK;
    }
  else
    {
      return GROUP_DELETE_GROUP_NONEMPTY;
    }
}

/* Used by :cother / :iother  */
rp_window *
group_last_window_by_class (rp_group *g, char *class)
{
  int last_access = 0;
  rp_window_elem *most_recent = NULL;
  rp_window_elem *cur;
  rp_screen *s = rp_current_screen;

  list_for_each_entry (cur, &g->mapped_windows, node)
    {
      if (cur->win->last_access >= last_access
          && cur->win != current_window()
          && !find_windows_frame (cur->win)
          && (cur->win->scr == s || rp_have_xrandr)
          && strcmp(class, cur->win->res_class))
        {
          most_recent = cur;
          last_access = cur->win->last_access;
        }
    }

  if (most_recent)
    return most_recent->win;

  return NULL;
}

/* Used by :cother / :iother  */
rp_window *
group_last_window_by_class_complement (rp_group *g, char *class)
{
  int last_access = 0;
  rp_window_elem *most_recent = NULL;
  rp_window_elem *cur;
  rp_screen *s = rp_current_screen;

  list_for_each_entry (cur, &g->mapped_windows, node)
    {
      if (cur->win->last_access >= last_access
          && cur->win != current_window()
          && !find_windows_frame (cur->win)
          && (cur->win->scr == s || rp_have_xrandr)
          && !strcmp(class, cur->win->res_class))
        {
          most_recent = cur;
          last_access = cur->win->last_access;
        }
    }

  if (most_recent)
    return most_recent->win;

  return NULL;
}



================================================
FILE: src/group.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef GROUP_H
#define GROUP_H

void init_groups (void);
void free_groups (void);

void group_add_window (rp_group *g, rp_window *w);
void group_resort_window (rp_group *g, rp_window_elem *w);
void group_free (rp_group *g);
rp_group *group_new (int number, char *name);
int group_delete_group (rp_group *g);

void group_del_window (rp_group *g, rp_window *win);
void groups_del_window (rp_window *win);

void group_map_window (rp_group *g, rp_window *win);
void groups_map_window (rp_window *win);

void group_unmap_window (rp_group *g, rp_window *win);
void groups_unmap_window (rp_window *win);

struct numset *group_get_numset (void);
void get_group_list (char *delim, struct sbuf *buffer, int *mark_start,
                int *mark_end);

rp_window *group_prev_window (rp_group *g, rp_window *win);
rp_window *group_next_window (rp_group *g, rp_window *win);
rp_group *groups_find_group_by_name (char *s, int exact_match);
rp_group *groups_find_group_by_number (int n);
rp_group *groups_find_group_by_window (rp_window *win);
rp_group *groups_find_group_by_group (rp_group *g);

rp_window *group_last_window (rp_group *g, rp_screen *screen);

rp_group *group_prev_group (void);
rp_group *group_next_group (void);
rp_group *group_last_group (void);

void group_resort_group (rp_group *g);

rp_group *group_add_new_group (char *name);
void group_rename (rp_group *g, char *name);

rp_window_elem *group_find_window (struct list_head *list, rp_window *win);
rp_window_elem *group_find_window_by_number (rp_group *g, int num);

void group_move_window (rp_group *to, rp_window *win);
void groups_merge (rp_group *from, rp_group *to);

void set_current_group (rp_group *g);

rp_window *group_last_window_by_class (rp_group *g, char *class);
rp_window *group_last_window_by_class_complement (rp_group *g, char *class);
#endif



================================================
FILE: src/history.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <limits.h>

#include "ratpoison.h"

#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif

#ifdef HAVE_HISTORY
#include "readline/history.h"
#endif

static char *
get_history_filename (void)
{
  const char *homedir;
  char *filename;

  homedir = get_homedir ();

  if (homedir)
    {
      struct sbuf *buf;

      buf = sbuf_new (0);
      sbuf_printf (buf, "%s/%s", homedir, HISTORY_FILE);
      filename = sbuf_free_struct (buf);
    }
  else
    {
      filename = xstrdup (HISTORY_FILE);
    }

  return filename;
}

static const char *
extract_shell_part (const char *p)
{
  if (strncmp(p, "exec", 4) &&
      strncmp(p, "verbexec", 8))
    return NULL;
  while (*p && !isspace ((unsigned char)*p))
    p++;
  while (*p &&  isspace ((unsigned char)*p))
    p++;
  if (*p)
    return p;
  return NULL;
}

struct history_item {
	struct list_head node;
	char *line;
};

static struct history {
	struct list_head head, *current;
	size_t count;
} histories[hist_COUNT];

#ifndef HAVE_GETLINE
ssize_t
getline (char **lineptr, size_t *n, FILE *f)
{
  size_t ofs;

  if (*lineptr == NULL) {
    *lineptr = malloc (4096);
    if (*lineptr == NULL)
      return -1;
    *n = 4096;
  }
  ofs = 0;
  do {
    (*lineptr)[ofs] = '\0';
    if (!fgets (*lineptr, (*n) - ofs, f)) {
      /* do not tread unterminated last lines as errors,
       * (it's still a malformed text file and noone should
       *  have created it) */
      return ofs?(ssize_t)ofs:-1;
    }
    ofs += strlen ((*lineptr) + ofs);
    if (ofs >= *n)
      /* should never happen... */
      return -1;
    if (ofs > 0 && (*lineptr)[ofs-1] == '\n')
      return ofs;
    if (ofs + 1 == *n) {
      void *tmp;
      if (*n >= INT_MAX - 4096)
	return -1;
      tmp = realloc (*lineptr, *n + 4096);
      if (tmp == NULL)
        return -1;
      *lineptr = tmp;
      *n += 4096;
    }
  } while(1);
}
#endif

static void
history_add_upto (int history_id, const char *item, size_t max)
{
  struct history *h = histories + history_id;
  struct history_item *i;

  if (item == NULL || *item == '\0' || isspace((unsigned char)*item))
    return;

  list_last (i, &histories[history_id].head, node);
  if (i && !strcmp (i->line, item))
    return;

  if (history_id == hist_COMMAND) {
    const char *p = extract_shell_part (item);
    if (p)
      history_add_upto (hist_SHELLCMD, p, max);
  }

  if (defaults.history_compaction && max != INT_MAX) {
    struct list_head *l;

    for (l = h->head.prev ; l && l != &h->head ; l = l->prev) {
      if (!strcmp (list_entry(l, struct history_item, node)->line, item)) {
	list_del (l);
	list_add_tail (l, &h->head);
	return;
      }
    }
  }

  while (h->count >= max) {
	  list_first (i, &h->head, node);
	  if (!i) {
		  h->count = 0;
		  break;
	  }
	  list_del (&i->node);
	  free (i->line);
	  free (i);
	  h->count--;
  }

  if( max == 0 )
	  return;

  i = xmalloc (sizeof (*i));
  i->line = xstrdup (item);

  list_add_tail (&i->node, &h->head);
  h->count++;
}

void
history_add (int history_id, const char *item)
{
  history_add_upto (history_id, item, defaults.history_size);
}

void
history_load (void)
{
  char *filename;
  FILE *f;
  char *line = NULL;
  size_t s = 0;
  ssize_t linelen;
  int id;

  for (id = hist_NONE ; id < hist_COUNT ; id++ ) {
    INIT_LIST_HEAD (&histories[id].head);
    histories[id].current = &histories[id].head;
    histories[id].count = 0;
  }

  filename = get_history_filename ();
  if (!filename)
    return;

  f = fopen (filename, "r");
  if (!f) {
    PRINT_DEBUG (("ratpoison: could not read %s - %s\n", filename, strerror (errno)));
    free (filename);
    return;
  }

  while ((linelen = getline (&line, &s, f)) >= 0) {
    while (linelen > 0 && (line[linelen-1] == '\n' || line[linelen-1] == '\r')) {
      line[--linelen] = '\0';
    }
    if (linelen == 0)
      continue;
    /* defaults.history_size might be only set later */
    history_add_upto (hist_COMMAND, line, INT_MAX);
  }
  free (line);
  if (ferror (f)) {
    PRINT_DEBUG (("ratpoison: error reading %s - %s\n", filename, strerror (errno)));
    fclose(f);
    free (filename);
    return;
  }
  if (fclose (f))
    PRINT_DEBUG (("ratpoison: error reading %s - %s\n", filename, strerror (errno)));
  free (filename);
}

void
history_save (void)
{
  char *filename;
  FILE *f;
  struct history_item *item;

  if (!defaults.history_size)
    return;

  filename = get_history_filename ();
  if (!filename)
    return;

  f = fopen (filename, "w");
  if (!f) {
    PRINT_DEBUG (("ratpoison: could not write %s - %s\n", filename, strerror (errno)));
    free (filename);
    return;
  }

  if (fchmod (fileno (f), 0600) == -1)
    PRINT_ERROR (("ratpoison: could not change mode to 0600 on %s - %s\n",
                  filename, strerror (errno)));

  list_for_each_entry(item, &histories[hist_COMMAND].head, node) {
    fputs(item->line, f);
    putc('\n', f);
  }

  if (ferror (f)) {
    PRINT_DEBUG (("ratpoison: error writing %s - %s\n", filename, strerror (errno)));
    fclose(f);
    free (filename);
    return;
  }
  if (fclose (f))
    PRINT_DEBUG (("ratpoison: error writing %s - %s\n", filename, strerror (errno)));
  free (filename);
}

void
history_reset (void)
{
  int id;

  for (id = hist_NONE ; id < hist_COUNT ; id++ )
    	histories[id].current = &histories[id].head;
}

const char *
history_previous (int history_id)
{
  if (history_id == hist_NONE)
    return NULL;
  /* return NULL, if list empty or already at first */
  if (histories[history_id].current == histories[history_id].head.next)
    return NULL;
  histories[history_id].current = histories[history_id].current->prev;
  return list_entry(histories[history_id].current, struct history_item, node)->line;
}

const char *
history_next (int history_id)
{
  if (history_id == hist_NONE)
    return NULL;
  /* return NULL, if list empty or already behind last */
  if (histories[history_id].current == &histories[history_id].head)
    return NULL;
  histories[history_id].current = histories[history_id].current->next;
  if (histories[history_id].current == &histories[history_id].head)
    return NULL;
  return list_entry(histories[history_id].current, struct history_item, node)->line;
}

int
history_expand_line (int history_id UNUSED, char *string, char **output)
{
#ifdef HAVE_HISTORY
  struct history_item *item;

  if (strchr (string, '!')) {
    clear_history ();
    list_for_each_entry(item, &histories[history_id].head, node) {
      add_history (item->line);
    }
    using_history ();
    return history_expand (string, output);
  }
#endif
  *output = xstrdup(string);
  return 0;
}



================================================
FILE: src/history.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_HISTORY_H
#define _RATPOISON_HISTORY_H 1

enum { hist_NONE=0, hist_COMMAND, hist_SHELLCMD,
	hist_SELECT, hist_KEYMAP, hist_KEY,
	hist_WINDOW, hist_GRAVITY, hist_GROUP,
	hist_HOOK, hist_VARIABLE, hist_PROMPT,
	hist_OTHER,
	/* must be last, do not use, for length only: */
	hist_COUNT};

#ifndef HAVE_GETLINE
ssize_t getline (char **lineptr, size_t *n, FILE *f);
#endif

void  history_load (void);
void  history_save (void);
void  history_reset (void);
void  history_add (int, const char *item);
const char *history_next (int);
const char *history_previous (int);
int   history_expand_line (int, char *string, char **output);

#endif /* ! _RATPOISON_HISTORY_H */



================================================
FILE: src/hook.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

/* A hook is simply a list of strings that get passed to command() in
   sequence. */

#include "ratpoison.h"

#include <string.h>

void
hook_add (struct list_head *hook, struct sbuf *s)
{
  struct sbuf *cur;

  /* Check if it's in the list already. */
  list_for_each_entry (cur, hook, node)
    {
      if (!strcmp (sbuf_get (cur), sbuf_get (s)))
        {
          sbuf_free (s);
          return;
        }
    }

  /* It's not in the list, so add it. */
  list_add_tail (&s->node, hook);
}

void
hook_remove (struct list_head *hook, struct sbuf *s)
{
  struct list_head *tmp, *iter;
  struct sbuf *cur;

  /* If it's in the list, delete it. */
  list_for_each_safe_entry (cur, iter, tmp, hook, node)
    {
      if (!strcmp (sbuf_get (cur), sbuf_get (s)))
        {
          list_del (&cur->node);
          sbuf_free (cur);
        }
    }
}

void
hook_run (struct list_head *hook)
{
  struct sbuf *cur;
  cmdret *result;

  list_for_each_entry (cur, hook, node)
    {
      result = command (1, sbuf_get (cur));
      if (result)
        {
          if (result->output)
            message (result->output);
          cmdret_free (result);
        }
    }
}

struct list_head *
hook_lookup (char *s)
{
  struct rp_hook_db_entry *entry;

  for (entry = rp_hook_db; entry->name; entry++)
    {
      if (!strcmp (s, entry->name))
        {
          return entry->hook;
        }
    }

  return NULL;
}



================================================
FILE: src/hook.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef HOOKS_H
#define HOOKS_H

void hook_run (struct list_head *hook);
void hook_remove (struct list_head *hook, struct sbuf *s);
void hook_add (struct list_head *hook, struct sbuf *s);
struct list_head *hook_lookup (char *s);

#endif



================================================
FILE: src/input.c
================================================
/* Read keyboard input from the user.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#include <X11/Xutil.h>

#include "ratpoison.h"

#ifdef HAVE_X11_XKBLIB_H
#include <X11/XKBlib.h>
#endif

/* Convert an X11 modifier mask to the rp modifier mask equivalent, as
   best it can (the X server may not have a hyper key defined, for
   instance). */
unsigned int
x11_mask_to_rp_mask (unsigned int mask)
{
  unsigned int result = 0;

  PRINT_DEBUG (("x11 mask = %x\n", mask));

  result |= mask & ShiftMask ? RP_SHIFT_MASK:0;
  result |= mask & ControlMask ? RP_CONTROL_MASK:0;
  result |= mask & rp_modifier_info.meta_mod_mask ? RP_META_MASK:0;
  result |= mask & rp_modifier_info.alt_mod_mask ? RP_ALT_MASK:0;
  result |= mask & rp_modifier_info.hyper_mod_mask ? RP_HYPER_MASK:0;
  result |= mask & rp_modifier_info.super_mod_mask ? RP_SUPER_MASK:0;

  PRINT_DEBUG (("rp mask = %x\n", mask));

  return result;
}

/* Convert an rp modifier mask to the x11 modifier mask equivalent, as
   best it can (the X server may not have a hyper key defined, for
   instance). */
unsigned int
rp_mask_to_x11_mask (unsigned int mask)
{
  unsigned int result = 0;

  PRINT_DEBUG (("rp mask = %x\n", mask));

  result |= mask & RP_SHIFT_MASK ? ShiftMask:0;
  result |= mask & RP_CONTROL_MASK ? ControlMask:0;
  result |= mask & RP_META_MASK ? rp_modifier_info.meta_mod_mask:0;
  result |= mask & RP_ALT_MASK ? rp_modifier_info.alt_mod_mask:0;
  result |= mask & RP_HYPER_MASK ? rp_modifier_info.hyper_mod_mask:0;
  result |= mask & RP_SUPER_MASK ? rp_modifier_info.super_mod_mask:0;

  PRINT_DEBUG (("x11 mask = %x\n", result));

  return result;
}

static Bool use_xkb;

void
init_xkb (void)
{
#if defined (WANT_XKB) && defined (HAVE_X11_XKBLIB_H) && defined (HAVE_XKBKEYCODETOKEYSYM)
  int error, event, major, minor, opcode;

  major = XkbMajorVersion;
  minor = XkbMajorVersion;

  use_xkb = XkbLibraryVersion (&major, &minor);
  if (!use_xkb)
    {
      PRINT_ERROR (("Not using XKB, compile and load time version mismatch:"));
      PRINT_ERROR ((" (%d, %d) vs. (%d, %d)\n", XkbMajorVersion,
                    XkbMajorVersion, major, minor));
      return;
    }

  use_xkb = XkbQueryExtension (dpy, &opcode, &event, &error, &major, &minor);
  if (!use_xkb)
    PRINT_DEBUG (("Not using XKB, XkbQueryExtension failed\n"));
#else
  PRINT_DEBUG (("Built with no XKB support."));
  use_xkb = False;
#endif
}

KeySym
keycode_to_keysym(Display *dpy, KeyCode kc, int group, int level)
{
  /*
   * XKeycodeToKeysym has been deprecated upstream, however we still use
   * it since XKB may not be available at build time or and not
   * functional at runtime. The problems in XKeycodeToKeysym don't seem
   * to matter in the ratpoison case anyway.
   * https://bugs.freedesktop.org/show_bug.cgi?id=5349
   */
#if defined (WANT_XKB) && defined (HAVE_X11_XKBLIB_H) && defined (HAVE_XKBKEYCODETOKEYSYM)
  if (use_xkb)
    return XkbKeycodeToKeysym (dpy, kc, group, level);
#endif
  (void) group;
  return XKeycodeToKeysym (dpy, kc, level);
}

/* Figure out what keysyms are attached to what modifiers */
void
update_modifier_map (void)
{
  unsigned int modmasks[] =
    { Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask };
  int row, col; /* The row and column in the modifier table.  */
  int found_alt_or_meta;
  XModifierKeymap *mods;
  int min_code, max_code;
  int syms_per_code;
  KeySym *syms;

  rp_modifier_info.meta_mod_mask = 0;
  rp_modifier_info.alt_mod_mask = 0;
  rp_modifier_info.super_mod_mask = 0;
  rp_modifier_info.hyper_mod_mask = 0;
  rp_modifier_info.num_lock_mask = 0;
  rp_modifier_info.scroll_lock_mask = 0;

  XDisplayKeycodes (dpy, &min_code, &max_code);
  syms = XGetKeyboardMapping (dpy,
			      min_code, max_code - min_code + 1,
			      &syms_per_code);
  mods = XGetModifierMapping (dpy);

  for (row=3; row < 8; row++)
    {
      found_alt_or_meta = 0;
      for (col=0; col < mods->max_keypermod; col++)
        {
          KeyCode code = mods->modifiermap[(row * mods->max_keypermod) + col];

          PRINT_DEBUG (("row: %d col: %d code: %d\n", row, col, code));

          if (code == 0) continue;

          /* Are any of this keycode's keysyms a meta key?  */
          {
            int code_col;

            for (code_col = 0; code_col < syms_per_code; code_col++)
              {
                int sym = syms[((code - min_code) * syms_per_code) + code_col];

                switch (sym)
                  {
                  case XK_Meta_L:
                  case XK_Meta_R:
                    found_alt_or_meta = 1;
                    rp_modifier_info.meta_mod_mask |= modmasks[row - 3];
                    PRINT_DEBUG (("Found Meta on %d\n",
                                  rp_modifier_info.meta_mod_mask));
                    break;

                  case XK_Alt_L:
                  case XK_Alt_R:
                    found_alt_or_meta = 1;
                    rp_modifier_info.alt_mod_mask |= modmasks[row - 3];
                    PRINT_DEBUG (("Found Alt on %d\n",
                                  rp_modifier_info.alt_mod_mask));
                    break;

                  case XK_Super_L:
                  case XK_Super_R:
                    if (!found_alt_or_meta)
                      {
                        rp_modifier_info.super_mod_mask |= modmasks[row - 3];
                        PRINT_DEBUG (("Found Super on %d\n",
                                      rp_modifier_info.super_mod_mask));
                      }
                    code_col = syms_per_code;
                    col = mods->max_keypermod;
                    break;

                  case XK_Hyper_L:
                  case XK_Hyper_R:
                    if (!found_alt_or_meta)
                      {
                        rp_modifier_info.hyper_mod_mask |= modmasks[row - 3];
                        PRINT_DEBUG (("Found Hyper on %d\n",
                                      rp_modifier_info.hyper_mod_mask));
                      }
                    code_col = syms_per_code;
                    col = mods->max_keypermod;

                    break;

                  case XK_Num_Lock:
                    rp_modifier_info.num_lock_mask |= modmasks[row - 3];
                    PRINT_DEBUG (("Found NumLock on %d\n",
                                  rp_modifier_info.num_lock_mask));
                    break;

                  case XK_Scroll_Lock:
                    rp_modifier_info.scroll_lock_mask |= modmasks[row - 3];
                    PRINT_DEBUG (("Found ScrollLock on %d\n",
                                  rp_modifier_info.scroll_lock_mask));
                    break;
                  default:
                    break;
                  }
              }
          }
        }
    }

  /* Stolen from Emacs 21.0.90 - xterm.c */
  /* If we couldn't find any meta keys, accept any alt keys as meta keys.  */
  if (! rp_modifier_info.meta_mod_mask)
    {
      rp_modifier_info.meta_mod_mask = rp_modifier_info.alt_mod_mask;
      rp_modifier_info.alt_mod_mask = 0;
    }

  /* If some keys are both alt and meta,
     make them just meta, not alt.  */
  if (rp_modifier_info.alt_mod_mask & rp_modifier_info.meta_mod_mask)
    {
      rp_modifier_info.alt_mod_mask &= ~rp_modifier_info.meta_mod_mask;
    }

  XFree ((char *) syms);
  XFreeModifiermap (mods);
}

/* we need a keycode + modifier to generate the proper keysym (such as
   @). Return 1 if successful, 0 otherwise. This function can fail if a
   keysym doesn't map to a keycode. */
static int
keysym_to_keycode_mod (KeySym keysym, KeyCode *code, unsigned int *mod)
{
  KeySym lower, upper;

  *mod = 0;
  *code = XKeysymToKeycode (dpy, keysym);
  lower = keycode_to_keysym (dpy, *code, 0, 0);
  upper = keycode_to_keysym (dpy, *code, 0, 1);
  /* If you need to press shift to get the keysym, add the shift
     mask. */
  if (upper == keysym && lower != keysym)
    *mod = ShiftMask;

  return *code != 0;
}

/* Grab the key while ignoring annoying modifier keys including
   caps lock, num lock, and scroll lock. */
void
grab_key (KeySym keysym, unsigned int modifiers, Window grab_window)
{
  unsigned int mod_list[8];
  int i;
  KeyCode keycode;
  unsigned int mod;

  /* Convert to a modifier mask that X Windows will understand. */
  modifiers = rp_mask_to_x11_mask (modifiers);
  if (!keysym_to_keycode_mod (keysym, &keycode, &mod))
    return;
  PRINT_DEBUG (("keycode_mod: %ld %d %d\n", keysym, keycode, mod));
  modifiers |= mod;

  /* Create a list of all possible combinations of ignored
     modifiers. Assumes there are only 3 ignored modifiers. */
  mod_list[0] = 0;
  mod_list[1] = LockMask;
  mod_list[2] = rp_modifier_info.num_lock_mask;
  mod_list[3] = mod_list[1] | mod_list[2];
  mod_list[4] = rp_modifier_info.scroll_lock_mask;
  mod_list[5] = mod_list[1] | mod_list[4];
  mod_list[6] = mod_list[2] | mod_list[4];
  mod_list[7] = mod_list[1] | mod_list[2] | mod_list[4];

  /* Grab every combination of ignored modifiers. */
  for (i=0; i<8; i++)
    {
      XGrabKey(dpy, keycode, modifiers | mod_list[i],
               grab_window, True, GrabModeAsync, GrabModeAsync);
    }
}


/* Return the name of the keysym. caller must free returned pointer */
char *
keysym_to_string (KeySym keysym, unsigned int modifier)
{
  struct sbuf *name;
  char *tmp;

  name = sbuf_new (0);

  if (modifier & RP_SHIFT_MASK) sbuf_concat (name, "S-");
  if (modifier & RP_CONTROL_MASK) sbuf_concat (name, "C-");
  if (modifier & RP_META_MASK) sbuf_concat (name, "M-");
  if (modifier & RP_ALT_MASK) sbuf_concat (name, "A-");
  if (modifier & RP_HYPER_MASK) sbuf_concat (name, "H-");
  if (modifier & RP_SUPER_MASK) sbuf_concat (name, "s-");

  /* On solaris machines (perhaps other machines as well) this call
     can return NULL. In this case use the "NULL" string. */
  tmp = XKeysymToString (keysym);
  if (tmp == NULL)
    tmp = "NULL";

  sbuf_concat (name, tmp);

  return sbuf_free_struct (name);
}

/* Cooks a keycode + modifier into a keysym + modifier. This should be
   used anytime meaningful key information is to be extracted from a
   KeyPress or KeyRelease event.

   returns the number of bytes in keysym_name. If you are not
   interested in the keysym name pass in NULL for keysym_name and 0
   for len. */
int
cook_keycode (XKeyEvent *ev, KeySym *keysym, unsigned int *mod, char *keysym_name, int len, int ignore_bad_mods)
{
  int nbytes;
  int shift = 0;
  KeySym lower, upper;

  if (ignore_bad_mods)
    {
      ev->state &= ~(LockMask
                     | rp_modifier_info.num_lock_mask
                     | rp_modifier_info.scroll_lock_mask);
    }

  if (len > 0) len--;
  nbytes =  XLookupString (ev, keysym_name, len, keysym, NULL);

  /* Null terminate the string (not all X servers do it for us). */
  if (keysym_name) {
    keysym_name[nbytes] = '\0';
  }

  /* Find out if XLookupString gobbled the shift modifier */
  if (ev->state & ShiftMask)
    {
      lower = keycode_to_keysym (dpy, ev->keycode, 0, 0);
      upper = keycode_to_keysym (dpy, ev->keycode, 0, 1);
      /* If the keysym isn't affected by the shift key, then keep the
         shift modifier. */
      if (lower == upper)
        shift = ShiftMask;
    }

  *mod = ev->state;
  *mod &= (rp_modifier_info.meta_mod_mask
           | rp_modifier_info.alt_mod_mask
           | rp_modifier_info.hyper_mod_mask
           | rp_modifier_info.super_mod_mask
           | ControlMask
           | shift);

  return nbytes;
}

/* Wait for a key and discard it. */
void
read_any_key (void)
{
  char buffer[513];
  unsigned int mod;
  KeySym c;

  read_single_key (&c, &mod, buffer, sizeof (buffer));
}

/* The same as read_key, but handle focusing the key_window and reverting focus. */
int
read_single_key (KeySym *keysym, unsigned int *modifiers, char *keysym_name, int len)
{
  Window focus;
  int revert;
  int nbytes;

  XGetInputFocus (dpy, &focus, &revert);
  set_window_focus (rp_current_screen->key_window);
  nbytes = read_key (keysym, modifiers, keysym_name, len);
  set_window_focus (focus);

  return nbytes;
}

int
read_key (KeySym *keysym, unsigned int *modifiers, char *keysym_name, int len)
{
  XEvent ev;
  int nbytes;

  /* Read a key from the keyboard. */
  do
    {
      XMaskEvent (dpy, KeyPressMask|KeyRelease, &ev);
      *modifiers = ev.xkey.state;
      nbytes = cook_keycode (&ev.xkey, keysym, modifiers, keysym_name, len, 0);
    } while (IsModifierKey (*keysym) || ev.xkey.type == KeyRelease);

  return nbytes;
}

static void
update_input_window (rp_screen *s, rp_input_line *line)
{
  int prompt_width, input_width, total_width;
  int char_len = 0, height;
  GC lgc;
  XGCValues gcv;

  prompt_width = rp_text_width (s, line->prompt, -1);
  input_width  = rp_text_width (s, line->buffer, line->length);
  total_width = defaults.bar_x_padding * 2 + prompt_width + input_width + MAX_FONT_WIDTH (defaults.font);
  height = (FONT_HEIGHT (s) + defaults.bar_y_padding * 2);

  if (isu8start (line->buffer[line->position]))
    do
      char_len++;
    while (isu8cont (line->buffer[line->position + char_len]));
  else
    char_len = 1;

  if (total_width < defaults.input_window_size + prompt_width)
    {
      total_width = defaults.input_window_size + prompt_width;
    }

  XMoveResizeWindow (dpy, s->input_window,
                     bar_x (s, total_width), bar_y (s, height), total_width,
                     (FONT_HEIGHT (s) + defaults.bar_y_padding * 2));

  XClearWindow (dpy, s->input_window);
  XSync (dpy, False);

  rp_draw_string (s, s->input_window, STYLE_NORMAL,
                  defaults.bar_x_padding,
                  defaults.bar_y_padding + FONT_ASCENT(s),
                  line->prompt, 
                  -1);

  rp_draw_string (s, s->input_window, STYLE_NORMAL, 
                  defaults.bar_x_padding + prompt_width,
                  defaults.bar_y_padding + FONT_ASCENT(s),
                  line->buffer, 
                  line->length);

  gcv.function = GXxor;
  gcv.foreground = rp_glob_screen.fg_color ^ rp_glob_screen.bg_color;
  lgc = XCreateGC (dpy, s->input_window, GCFunction | GCForeground, &gcv);

  /* Draw a cheap-o cursor - MkIII */
  XFillRectangle (dpy, s->input_window, lgc,
		  defaults.bar_x_padding + prompt_width +
		  rp_text_width (s, line->buffer, line->position),
                  defaults.bar_y_padding,
		  rp_text_width (s, &line->buffer[line->position], char_len),
                  FONT_HEIGHT (s));

  XFlush (dpy);
  XFreeGC (dpy, lgc);
}

void
ring_bell (void)
{
#ifdef VISUAL_BELL
  GC lgc;
  XGCValues gcv;
  XWindowAttributes attr;
  rp_screen *s = rp_current_screen;

  XGetWindowAttributes (dpy, s->input_window, &attr);

  gcv.function = GXxor;
  gcv.foreground = rp_glob_screen.fg_color ^ rp_glob_screen.bg_color;
  lgc = XCreateGC (dpy, s->input_window, GCFunction | GCForeground, &gcv);

  XFillRectangle (dpy, s->input_window, lgc, 0, 0, attr.width, attr.height);
  XFlush (dpy);

  usleep (15000);

  XFillRectangle (dpy, s->input_window, lgc, 0, 0, attr.width, attr.height);
  XFlush (dpy);
  XFreeGC (dpy, lgc);
#else
  XBell (dpy, 0);
#endif
}

char *
get_input (char *prompt, int history_id, completion_fn fn)
{
  return get_more_input (prompt, "", history_id, BASIC, fn);
}

char *
get_more_input (char *prompt, char *preinput, int history_id,
                enum completion_styles style, completion_fn compl_fn)
{
  /* Emacs 21 uses a 513 byte string to store the keysym name. */
  char keysym_buf[513];
  rp_screen *s = rp_current_screen;
  KeySym ch;
  unsigned int modifier;
  rp_input_line *line;
  char *final_input;
  edit_status status;
  Window focus;
  int revert, done = 0;

  history_reset();

  /* Create our line structure */
  line = input_line_new (prompt, preinput, history_id, style, compl_fn);

  /* We don't want to draw overtop of the program bar. */
  hide_bar (s);

  /* Switch to the default colormap. */
  if (current_window())
    XUninstallColormap (dpy, current_window()->colormap);
  XInstallColormap (dpy, s->def_cmap);

  XMapWindow (dpy, s->input_window);
  XRaiseWindow (dpy, s->input_window);
  XClearWindow (dpy, s->input_window);
  /* Switch focus to our input window to read the next key events. */
  XGetInputFocus (dpy, &focus, &revert);
  set_window_focus (s->input_window);
  XSync (dpy, False);

  update_input_window (s, line);

  while (!done)
    {
      read_key (&ch, &modifier, keysym_buf, sizeof (keysym_buf));
      modifier = x11_mask_to_rp_mask (modifier);
      PRINT_DEBUG (("ch = %ld, modifier = %d, keysym_buf = %s",
                    ch, modifier, keysym_buf));
      status = execute_edit_action (line, ch, modifier, keysym_buf);

      switch (status)
        {
        case EDIT_COMPLETE:
        case EDIT_DELETE:
        case EDIT_INSERT:
        case EDIT_MOVE:
          /* If the text changed (and we didn't just complete
             something) then set the virgin bit. */
          if (status != EDIT_COMPLETE)
            line->compl->virgin = 1;
          /* In all cases, we need to redisplay the input string. */
          update_input_window (s, line);
          break;
        case EDIT_NO_OP:
          ring_bell ();
          break;
        case EDIT_ABORT:
          final_input = NULL;
          done = 1;
          break;
        case EDIT_DONE:
          final_input = xstrdup (line->buffer);
          done = 1;
          break;
        default:
          PRINT_ERROR (("Unhandled status %d; this is a *BUG*\n", status));
          exit (EXIT_FAILURE);
        }
    }

  /* Clean up our line structure */
  input_line_free (line);

  /* Revert focus. */
  set_window_focus (focus);
  XUnmapWindow (dpy, s->input_window);

  /* Possibly restore colormap. */
  if (current_window())
    {
      XUninstallColormap (dpy, s->def_cmap);
      XInstallColormap (dpy, current_window()->colormap);
    }

  return final_input;
}



================================================
FILE: src/input.h
================================================
/* Function prototypes.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_INPUT_H
#define _RATPOISON_INPUT_H 1

char *keysym_to_string (KeySym keysym, unsigned int modifier);
int cook_keycode (XKeyEvent *ev, KeySym *keysym, unsigned int *mod, char *keysym_name, int len, int ignore_bad_mods);
char *get_input (char *prompt, int history_id, completion_fn fn);
char *get_more_input (char *prompt, char *preinput, int history_id, enum completion_styles style, completion_fn fn);
void read_any_key (void);
int read_single_key (KeySym *keysym, unsigned int *modifiers, char *keysym_name, int len);
int read_key (KeySym *keysym, unsigned int *modifiers, char *keysym_name, int len);
unsigned int x11_mask_to_rp_mask (unsigned int mask);
unsigned int rp_mask_to_x11_mask (unsigned int mask);
void update_modifier_map (void);
void grab_key (KeySym keysym, unsigned int modifiers, Window grab_window);

void ring_bell (void);

void init_xkb (void);

#endif /* ! _RATPOISON_INPUT_H */



================================================
FILE: src/linkedlist.c
================================================
/* This file was taken from the Linux kernel and is
 * Copyright (C) 2003 Linus Torvalds
 *
 * Modified by Shawn Betts. Portions created by Shawn Betts are
 * Copyright (C) 2003, 2004 Shawn Betts
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "linkedlist.h"

/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
void
__list_add(struct list_head *new,
           struct list_head *prev,
           struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
void
list_add(struct list_head *new, struct list_head *head)
{
  __list_add(new, head, head->next);
}

/**
 * list_add_tail - add a new entry
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
void
list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add(new, head->prev, head);
}

/*
 * Delete a list entry by making the prev/next entries
 * point to each other.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
void
__list_del(struct list_head * prev, struct list_head * next)
{
  next->prev = prev;
  prev->next = next;
}

/**
 * list_del - deletes entry from list.
 * @entry: the element to delete from the list.
 * Note: list_empty on entry does not return true after this, the entry is
 * in an undefined state.
 */
void
list_del(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
}

/**
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
void
list_del_init(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
  INIT_LIST_HEAD(entry);
}

/**
 * list_move - delete from one list and add as another's head
 * @list: the entry to move
 * @head: the head that will precede our entry
 */
void
list_move(struct list_head *list, struct list_head *head)
{
  __list_del(list->prev, list->next);
  list_add(list, head);
}

/**
 * list_move_tail - delete from one list and add as another's tail
 * @list: the entry to move
 * @head: the head that will follow our entry
 */
void
list_move_tail(struct list_head *list,
               struct list_head *head)
{
  __list_del(list->prev, list->next);
  list_add_tail(list, head);
}

/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
int
list_empty(struct list_head *head)
{
  return head->next == head;
}

void
__list_splice(struct list_head *list,
              struct list_head *head)
{
  struct list_head *first = list->next;
  struct list_head *last = list->prev;
  struct list_head *at = head->next;

  first->prev = head;
  head->next = first;

  last->next = at;
  at->prev = last;
}

/**
 * list_splice - join two lists
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 */
void
list_splice(struct list_head *list, struct list_head *head)
{
  if (!list_empty(list))
    __list_splice(list, head);
}

/**
 * list_splice_init - join two lists and reinitialise the emptied list.
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 *
 * The list at @list is reinitialised
 */
void
list_splice_init(struct list_head *list,
                 struct list_head *head)
{
  if (!list_empty(list)) {
    __list_splice(list, head);
    INIT_LIST_HEAD(list);
  }
}

int
list_size (struct list_head *list)
{
  struct list_head *cur;

  int i = 0;
  list_for_each (cur, list)
    i++;

  return i;
}

#define MAX_LIST_LENGTH_BITS 20
#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))

/*
 * Returns a list organized in an intermediate format suited
 * to chaining of merge() calls: null-terminated, no reserved or
 * sentinel head node, "prev" links not maintained.
 */
static struct list_head *
merge(void *priv,
      int (*cmp)(void *priv, struct list_head *a,
                 struct list_head *b),
      struct list_head *a, struct list_head *b)
{
	struct list_head head, *tail = &head;

	while (a && b) {
		/* if equal, take 'a' -- important for sort stability */
		if ((*cmp) (priv, a, b) <= 0) {
			tail->next = a;
			a = a->next;
		} else {
			tail->next = b;
			b = b->next;
		}
		tail = tail->next;
	}
	tail->next = a?:b;
	return head.next;
}

/*
 * Combine final list merge with restoration of standard doubly-linked
 * list structure.  This approach duplicates code from merge(), but
 * runs faster than the tidier alternatives of either a separate final
 * prev-link restoration pass, or maintaining the prev links
 * throughout.
 */
static void
merge_and_restore_back_links(void *priv,
                             int (*cmp)(void *priv, struct list_head *a,
					struct list_head *b),
                             struct list_head *head,
                             struct list_head *a, struct list_head *b)
{
	struct list_head *tail = head;
	unsigned int count = 0;

	while (a && b) {
		/* if equal, take 'a' -- important for sort stability */
		if ((*cmp) (priv, a, b) <= 0) {
			tail->next = a;
			a->prev = tail;
			a = a->next;
		} else {
			tail->next = b;
			b->prev = tail;
			b = b->next;
		}
		tail = tail->next;
	}
	tail->next = a ? : b;

	do {
		/*
		 * In worst cases this loop may run many iterations.
		 * Continue callbacks to the client even though no
		 * element comparison is needed, so the client's cmp()
		 * routine can invoke cond_resched() periodically.
		 */
		if (!(++count))
			(*cmp) (priv, tail->next, tail->next);

		tail->next->prev = tail;
		tail = tail->next;
	} while (tail->next);

	tail->next = head;
	head->prev = tail;
}

/**
 * list_sort - sort a list
 * @priv: private data, opaque to list_sort(), passed to @cmp
 * @head: the list to sort
 * @cmp: the elements comparison function
 *
 * This function implements "merge sort", which has O(nlog(n))
 * complexity.
 *
 * The comparison function @cmp must return a negative value if @a
 * should sort before @b, and a positive value if @a should sort after
 * @b. If @a and @b are equivalent, and their original relative
 * ordering is to be preserved, @cmp must return 0.
 */
void
list_sort(void *priv, struct list_head *head,
          int (*cmp)(void *priv, struct list_head *a,
                     struct list_head *b))
{
	struct list_head *part[MAX_LIST_LENGTH_BITS+1]; /* sorted partial lists
						-- last slot is a sentinel */
	int lev;  /* index into part[] */
	int max_lev = 0;
	struct list_head *list;

	if (list_empty (head))
		return;

	memset(part, 0, sizeof(part));

	head->prev->next = NULL;
	list = head->next;

	while (list) {
		struct list_head *cur = list;
		list = list->next;
		cur->next = NULL;

		for (lev = 0; part[lev]; lev++) {
			cur = merge (priv, cmp, part[lev], cur);
			part[lev] = NULL;
		}
		if (lev > max_lev) {
			if (lev >= ARRAY_SIZE(part)-1) {
				lev--;
			}
			max_lev = lev;
		}
		part[lev] = cur;
	}

	for (lev = 0; lev < max_lev; lev++)
		if (part[lev])
			list = merge (priv, cmp, part[lev], list);

	merge_and_restore_back_links (priv, cmp, head, part[max_lev], list);
}



================================================
FILE: src/linkedlist.h
================================================
/* This file was taken from the Linux kernel and is
 * Copyright (C) 2003 Linus Torvalds
 *
 * Modified by Shawn Betts. Portions created by Shawn Betts are
 * Copyright (C) 2003, 2004 Shawn Betts
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_LINKLIST_H
#define _RATPOISON_LINKLIST_H

#include <string.h>

/*
 * Simple doubly linked list implementation.
 *
 * Some of the internal functions ("__xxx") are useful when
 * manipulating whole lists rather than single entries, as
 * sometimes we already know the next/prev entries and we can
 * generate better code by using them directly rather than
 * using the generic single-entry routines.
 */

struct list_head {
        struct list_head *next, *prev;
};

#define LIST_HEAD_INIT(name) { &(name), &(name) }

#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

#define INIT_LIST_HEAD(ptr) do { \
        (ptr)->next = (ptr); (ptr)->prev = (ptr); \
} while (0)

/* Prototypes of C functions. */
int list_size (struct list_head *list);
void list_splice_init(struct list_head *list,
                      struct list_head *head);

void list_splice_init(struct list_head *list,
                      struct list_head *head);

void list_splice(struct list_head *list, struct list_head *head);

void __list_splice(struct list_head *list,
                   struct list_head *head);

int list_empty(struct list_head *head);

void list_move_tail(struct list_head *list,
                    struct list_head *head);

void list_move(struct list_head *list, struct list_head *head);

void list_del_init(struct list_head *entry);
void list_del(struct list_head *entry);
void __list_del(struct list_head * prev, struct list_head * next);
void list_add_tail(struct list_head *new, struct list_head *head);
void list_add(struct list_head *new, struct list_head *head);
void __list_add(struct list_head *new,
                struct list_head *prev,
                struct list_head *next);

#ifdef HAVE___BUILTIN_PREFETCH
#define prefetch(x) __builtin_prefetch(x)
#else
#define prefetch(x) ((void)(x))
#endif

/* Return the last element in the list. */
#define list_last(last, head, member)                           \
{                                                               \
  last = list_entry((head)->prev, typeof(*last), member);       \
  if (&last->member == (head))                                  \
    last = NULL;                                                \
}


/**
 * container_of - cast a member of a structure out to the containing structure
 *
 * @ptr:        the pointer to the member.
 * @type:       the type of the container struct this is embedded in.
 * @member:     the name of the member within the struct.
 *
 */
#define container_of(ptr, type, member) ({                      \
        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})

/**
 * list_entry - get the struct for this entry
 * @ptr:        the &struct list_head pointer.
 * @type:       the type of the struct this is embedded in.
 * @member:     the name of the list_struct within the struct.
 */
#define list_entry(ptr, type, member) \
        container_of(ptr, type, member)


/**
 * __list_for_each      -       iterate over a list
 * @pos:        the &struct list_head to use as a loop counter.
 * @head:       the head for your list.
 *
 * This variant differs from list_for_each() in that it's the
 * simplest possible list iteration code, no prefetching is done.
 * Use this for code that knows the list to be very short (empty
 * or 1 entry) most of the time.
 */
#define list_for_each(pos, head) \
        for (pos = (head)->next; pos != (head); pos = pos->next)

/**
 * list_for_each_prev   -       iterate over a list backwards
 * @pos:        the &struct list_head to use as a loop counter.
 * @head:       the head for your list.
 */
#define list_for_each_prev(pos, head) \
        for (pos = (head)->prev, prefetch(pos->prev); pos != (head); \
        pos = pos->prev, prefetch(pos->prev))

/**
 * list_for_each_safe   -       iterate over a list safe against removal of list entry
 * @pos:        the &struct list_head to use as a loop counter.
 * @n:          another &struct list_head to use as temporary storage
 * @head:       the head for your list.
 */
#define list_for_each_safe(pos, n, head) \
        for (pos = (head)->next, n = pos->next; pos != (head); \
                pos = n, n = pos->next)

#define list_for_each_safe_entry(item, pos, n, head, member) \
        for (pos = (head)->next,  \
             item = list_entry(pos, typeof(*item), member), \
             n = pos->next  \
                     ; \
             pos != (head) \
                     ; \
             pos = n,  \
             item = list_entry(pos, typeof(*item), member), \
             n = pos->next) \

/**
 * list_for_each_entry  -       iterate over list of given type
 * @pos:        the type * to use as a loop counter.
 * @head:       the head for your list.
 * @member:     the name of the list_struct within the struct.
 */
#define list_for_each_entry(pos, head, member)                          \
        for (pos = list_entry((head)->next, typeof(*pos), member),      \
                     prefetch(pos->member.next);                        \
             &pos->member != (head);                                    \
             pos = list_entry(pos->member.next, typeof(*pos), member),  \
                     prefetch(pos->member.next))

#define list_for_each_entry_safe(pos, n, head, member)                  \
        for (pos = list_entry((head)->next, typeof(*pos), member),      \
                n = list_entry(pos->member.next, typeof(*pos), member); \
             &pos->member != (head);                                    \
             pos = n,                                                   \
                n = list_entry(pos->member.next, typeof(*pos), member))

#define list_direction_entry(pos, head, member, direction) \
({ \
        typeof(pos) ret = NULL;  \
        struct list_head *a_head = head;  \
        if (pos->member.direction == a_head) { \
                        ret = list_entry(a_head->direction,  \
                                         typeof(*pos), member); \
        } else { \
                ret = list_entry(pos->member.direction,  \
                                 typeof(*pos), member); \
        } \
        ret; \
})

#define list_next_entry(pos, head, member) \
        list_direction_entry(pos, head, member, next)

#define list_prev_entry(pos, head, member) \
        list_direction_entry(pos, head, member, prev)

#define list_for_each_entry_prev(pos, head, member)                     \
        for (pos = list_entry((head)->prev, typeof(*pos), member),      \
                     prefetch(pos->member.prev);                        \
             &pos->member != (head);                                    \
             pos = list_entry(pos->member.prev, typeof(*pos), member),  \
                     prefetch(pos->member.prev))

#endif


/* Return the first element in the list. */
#define list_first(first, head, member)                         \
{                                                               \
  first = list_entry((head)->next, typeof(*first), member);     \
  if (&first->member == (head))                                 \
    first = NULL;                                               \
}

void list_sort(void *priv, struct list_head *head,
               int (*cmp)(void *priv, struct list_head *a,
                          struct list_head *b));



================================================
FILE: src/main.c
================================================
/* Ratpoison.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/Xproto.h>
#include <X11/cursorfont.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <sys/wait.h>
#include <ctype.h>

#include "ratpoison.h"

/* Command line options */
static struct option ratpoison_longopts[] =
  { {"help",            no_argument,            0,      'h'},
    {"interactive",     no_argument,            0,      'i'},
    {"version", no_argument,            0,      'v'},
    {"command", required_argument,      0,      'c'},
    {"display", required_argument,      0,      'd'},
    {"file",            required_argument,      0,      'f'},
    {0,         0,                      0,      0} };

static char ratpoison_opts[] = "hvic:d:s:f:";

static void
sighandler (int signum UNUSED)
{
  kill_signalled++;
}

static void
hup_handler (int signum UNUSED)
{
  hup_signalled++;
}

static void
alrm_handler (int signum UNUSED)
{
  alarm_signalled++;
}

static int
handler (Display *d, XErrorEvent *e)
{
  char error_msg[100];

  if (e->request_code == X_ChangeWindowAttributes && e->error_code == BadAccess)
    {
      fprintf(stderr, "ratpoison: There can be only ONE.\n");
      exit(EXIT_FAILURE);
    }

#ifdef IGNORE_BADWINDOW
  return 0;
#else
  if (ignore_badwindow && e->error_code == BadWindow) return 0;
#endif

  XGetErrorText (d, e->error_code, error_msg, sizeof (error_msg));
  fprintf (stderr, "ratpoison: ERROR: %s!\n", error_msg);

  /* If there is already an error to report, replace it with this new
     one. */
  free (rp_error_msg);
  rp_error_msg = xstrdup (error_msg);

  return 0;
}

static void
print_version (void)
{
  printf ("%s %s\n", PACKAGE, VERSION);
  printf ("Copyright (C) 2000-2008 Shawn Betts\n\n");

  exit (EXIT_SUCCESS);
}

static void
print_help (void)
{
  printf ("Help for %s %s\n\n", PACKAGE, VERSION);
  printf ("-h, --help            Display this help screen\n");
  printf ("-v, --version         Display the version\n");
  printf ("-d, --display <dpy>   Set the X display to use\n");
  printf ("-c, --command <cmd>   Send ratpoison a colon-command\n");
  printf ("-i, --interactive     Execute commands in interactive mode\n");
  printf ("-f, --file <file>     Specify an alternative configuration file\n\n");

  printf ("Report bugs to %s\n\n", PACKAGE_BUGREPORT);

  exit (EXIT_SUCCESS);
}

static int
read_startup_files (const char *alt_rcfile)
{
  FILE *fileptr = NULL;

  if (alt_rcfile)
    {
      if ((fileptr = fopen (alt_rcfile, "r")) == NULL)
        {
          PRINT_ERROR (("ratpoison: could not open %s (%s)\n", alt_rcfile,
                        strerror (errno)));
          return -1;
        }
    }
  else
    {
      const char *homedir;
      char *filename;

      /* first check $HOME/.ratpoisonrc */
      homedir = get_homedir ();
      if (!homedir)
        PRINT_ERROR (("ratpoison: no home directory!?\n"));
      else
        {
          filename = xsprintf ("%s/.ratpoisonrc", homedir);
          fileptr = fopen (filename, "r");
          if (fileptr == NULL && errno != ENOENT)
            PRINT_ERROR (("ratpoison: could not open %s (%s)\n",
                          filename, strerror (errno)));
          free (filename);
        }

      if (fileptr == NULL)
        {
          /* couldn't open $HOME/.ratpoisonrc, fall back on system config */
          filename = xsprintf ("%s/ratpoisonrc", SYSCONFDIR);

          fileptr = fopen (filename, "r");
          if (fileptr == NULL && errno != ENOENT)
            PRINT_ERROR (("ratpoison: could not open %s (%s)\n",
                          filename, strerror (errno)));
          free (filename);
        }
    }

  if (fileptr != NULL)
    {
      set_close_on_exec (fileno (fileptr));
      read_rc_file (fileptr);
      fclose (fileptr);
    }
  return 0;
}

/* Odd that we spend so much code on making sure the silly welcome
   message is correct. Oh well... */
static void
show_welcome_message (void)
{
  rp_action *help_action;
  char *prefix, *help;
  rp_keymap *map;

  prefix = keysym_to_string (prefix_key.sym, prefix_key.state);

  map = find_keymap (ROOT_KEYMAP);

  /* Find the help key binding. */
  help_action = find_keybinding_by_action ("help " ROOT_KEYMAP, map);
  if (help_action)
    help = keysym_to_string (help_action->key, help_action->state);
  else
    help = NULL;


  if (help)
    {
      /* A little kludge to use ? instead of `question' for the help
         key. */
      if (!strcmp (help, "question"))
        marked_message_printf (0, 0, MESSAGE_WELCOME, prefix, "?");
      else
        marked_message_printf (0, 0, MESSAGE_WELCOME, prefix, help);

      free (help);
    }
  else
    {
      marked_message_printf (0, 0, MESSAGE_WELCOME, prefix, ":help");
    }

  free (prefix);
}

static void
init_defaults (void)
{
  defaults.top_kmap = xstrdup(TOP_KEYMAP);

  defaults.win_gravity     = NorthWestGravity;
  defaults.trans_gravity   = CenterGravity;
  defaults.maxsize_gravity = CenterGravity;

  defaults.input_window_size   = 200;
  defaults.window_border_width = 1;
  defaults.only_border         = 1;
  defaults.bar_x_padding       = 4;
  defaults.bar_y_padding       = 0;
  defaults.bar_location        = NorthEastGravity;
  defaults.bar_timeout         = 5;
  defaults.bar_border_width    = 1;
  defaults.bar_in_padding      = 0;

  defaults.frame_indicator_timeout = 1;
  defaults.frame_resize_unit = 10;

  defaults.padding_left   = 0;
  defaults.padding_right  = 0;
  defaults.padding_top    = 0;
  defaults.padding_bottom = 0;

#ifdef USE_XFT_FONT
  defaults.font_string = xstrdup (DEFAULT_XFT_FONT);
#else
  /* Attempt to load a font */
  defaults.font = load_query_font_set (dpy, DEFAULT_FONT);
  if (defaults.font == NULL)
    {
      PRINT_ERROR (("ratpoison: Cannot load font %s.\n", DEFAULT_FONT));
      defaults.font = load_query_font_set (dpy, BACKUP_FONT);
      if (defaults.font == NULL)
        {
          PRINT_ERROR (("ratpoison: Cannot load backup font %s . You lose.\n", BACKUP_FONT));
          exit (EXIT_FAILURE);
        }
    }

  defaults.font_string = xstrdup (DEFAULT_FONT);
  set_extents_of_fontset (defaults.font);
#endif

  defaults.fgcolor_string = xstrdup ("black");
  defaults.bgcolor_string = xstrdup ("white");
  defaults.fwcolor_string = xstrdup ("black");
  defaults.bwcolor_string = xstrdup ("black");

  defaults.wait_for_key_cursor = 1;

  defaults.window_fmt = xstrdup ("%n%s%t");
  defaults.info_fmt = xstrdup ("(%H, %W) %n(%t)");
  defaults.frame_fmt = xstrdup ("Current Frame");

  defaults.win_name = WIN_NAME_TITLE;
  defaults.startup_message = 1;
  defaults.warp = 0;
  defaults.window_list_style = STYLE_COLUMN;

  defaults.history_size = 20;
  defaults.history_compaction = True;
  defaults.history_expansion = False;
  defaults.frame_selectors = xstrdup ("");
  defaults.maxundos = 20;
}

int
main (int argc, char *argv[])
{
  int c;
  char **cmd = NULL;
  int cmd_count = 0;
  char *display = NULL;
  unsigned char interactive = 0;
  char *alt_rcfile = NULL;

  setlocale (LC_CTYPE, "");
  utf8_check_locale();

  if (XSupportsLocale ())
    {
      if (!XSetLocaleModifiers (""))
	PRINT_ERROR (("Couldn't set X locale modifiers.\n"));
    }
  else
    PRINT_ERROR (("X doesn't seem to support your locale.\n"));

  /* Parse the arguments */
  myargv = argv;
  while (1)
    {
      c = getopt_long (argc, argv, ratpoison_opts, ratpoison_longopts, NULL);
      if (c == -1) break;

      switch (c)
        {
        case 'h':
          print_help ();
          break;
        case 'v':
          print_version ();
          break;
        case 'c':
          cmd = xrealloc (cmd, sizeof (char *) * (cmd_count + 1));
          cmd[cmd_count++] = xstrdup (optarg);
          break;
        case 'd':
          display = optarg;
          break;
        case 'i':
          interactive = 1;
          break;
        case 'f':
          alt_rcfile = optarg;
          break;

        default:
          exit (EXIT_FAILURE);
        }
    }

  /* Report extra unparsed arguments. */
  if (optind < argc)
    {
      fprintf (stderr, "Error: junk arguments: ");
      while (optind < argc)
        fprintf (stderr, "%s ", argv[optind++]);
      fputc ('\n', stderr);
      exit (EXIT_FAILURE);
    }

  if (!(dpy = XOpenDisplay (display)))
    {
      fprintf (stderr, "Can't open display\n");
      exit (EXIT_FAILURE);
    }

  set_close_on_exec (ConnectionNumber (dpy));

  /* Set ratpoison specific Atoms. */
  rp_command = XInternAtom (dpy, "RP_COMMAND", False);
  rp_command_request = XInternAtom (dpy, "RP_COMMAND_REQUEST", False);
  rp_command_result = XInternAtom (dpy, "RP_COMMAND_RESULT", False);
  rp_selection = XInternAtom (dpy, "RP_SELECTION", False);

  /* TEXT atoms */
  xa_string = XA_STRING;
  xa_compound_text = XInternAtom(dpy, "COMPOUND_TEXT", False);
  xa_utf8_string = XInternAtom(dpy, "UTF8_STRING", False);

  if (cmd_count > 0)
    {
      int j, exit_status = EXIT_SUCCESS;

      for (j = 0; j < cmd_count; j++)
        {
          if (!send_command (interactive, (unsigned char *)cmd[j]))
	    exit_status = EXIT_FAILURE;
          free (cmd[j]);
        }

      free (cmd);
      XCloseDisplay (dpy);
      return exit_status;
    }

  /* Set our Atoms */
  wm_name =  XInternAtom(dpy, "WM_NAME", False);
  wm_state = XInternAtom(dpy, "WM_STATE", False);
  wm_change_state = XInternAtom(dpy, "WM_CHANGE_STATE", False);
  wm_protocols = XInternAtom(dpy, "WM_PROTOCOLS", False);
  wm_delete = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
  wm_take_focus = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
  wm_colormaps = XInternAtom(dpy, "WM_COLORMAP_WINDOWS", False);

  /* netwm atoms */
  _net_wm_pid = XInternAtom(dpy, "_NET_WM_PID", False);
  PRINT_DEBUG (("_NET_WM_PID = %ld\n", _net_wm_pid));
  _net_supported = XInternAtom(dpy, "_NET_SUPPORTED", False);
  PRINT_DEBUG (("_NET_SUPPORTED = %ld\n", _net_supported));
  _net_wm_window_type = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
  _net_wm_window_type_dialog = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
  _net_wm_name = XInternAtom(dpy, "_NET_WM_NAME", False);

  /* Setup signal handlers. */
  XSetErrorHandler(handler);
  set_sig_handler (SIGALRM, alrm_handler);
  set_sig_handler (SIGTERM, sighandler);
  set_sig_handler (SIGINT, sighandler);
  set_sig_handler (SIGHUP, hup_handler);
  set_sig_handler (SIGCHLD, chld_handler);

  /* Add RATPOISON to the environment */
  putenv (xsprintf ("RATPOISON=%s", argv[0]));

  /* Setup ratpoison's internal structures */
  init_defaults ();
  init_xkb ();
  init_groups ();
  init_window_stuff ();
  init_xrandr ();
  init_screens ();

  init_frame_lists ();
  update_modifier_map ();
  init_user_commands();
  initialize_default_keybindings ();
  history_load ();

  scanwins ();

  if (read_startup_files (alt_rcfile) == -1)
    return EXIT_FAILURE;

  /* Indicate to the user that ratpoison has booted. */
  if (defaults.startup_message)
    show_welcome_message();

  /* If no window has focus, give the key_window focus. */
  if (current_window() == NULL)
    set_window_focus (rp_current_screen->key_window);

  listen_for_events ();

  return EXIT_SUCCESS;
}

void
set_extents_of_fontset (XFontSet font)
{
  XFontSetExtents *extent;
  extent = XExtentsOfFontSet(font);
  rp_font_ascent = extent->max_logical_extent.height * 9 / 10;
  rp_font_descent = extent->max_logical_extent.height / 5;
  rp_font_width = extent->max_logical_extent.width;
}

XFontSet load_query_font_set (Display *disp, const char *fontset_name)
{
  XFontSet fontset;
  int  missing_charset_count;
  char **missing_charset_list;
  char *def_string;

  fontset = XCreateFontSet(disp, fontset_name,
                           &missing_charset_list, &missing_charset_count,
                           &def_string);
  if (missing_charset_count) {
    PRINT_DEBUG (("Missing charsets in FontSet(%s) creation.\n", fontset_name));
    XFreeStringList(missing_charset_list);
  }
  return fontset;
}



================================================
FILE: src/Makefile.am
================================================
## Process this file with automake to produce Makefile.in
## Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
##
## This file is part of ratpoison.
##
## ratpoison is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## ratpoison is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

bin_PROGRAMS		= ratpoison
MAINTAINERCLEANFILES = Makefile.in config.h.in

AM_CPPFLAGS=-DSYSCONFDIR='"$(sysconfdir)"' ${X_CFLAGS} ${XFT_CFLAGS}
ratpoison_LDADD=${XFT_LIBS} ${X_LIBS} ${X_EXTRA_LIBS} ${HISTORY_LIBS}

ratpoison_SOURCES	= actions.c		\
			actions.h		\
			bar.c			\
			bar.h			\
			completions.c		\
			completions.h		\
			communications.c	\
			communications.h	\
			conf.h			\
			data.h			\
			editor.c		\
			editor.h		\
			events.c		\
			events.h		\
			format.c		\
			format.h		\
			frame.c			\
			frame.h			\
			getopt.c		\
			getopt.h		\
			getopt1.c		\
			globals.h		\
			globals.c		\
			group.h			\
			group.c			\
			history.h		\
			history.c		\
			hook.c			\
			hook.h			\
			input.c			\
			input.h			\
			linkedlist.h		\
			linkedlist.c		\
			main.c			\
			manage.c		\
			manage.h		\
			messages.h		\
			number.c		\
			number.h		\
			ratpoison.h		\
			sbuf.c			\
			sbuf.h			\
			screen.h		\
			screen.c		\
			split.c			\
			split.h			\
			utf8.c			\
			utf8.h			\
			util.c			\
			util.h			\
			window.c		\
			window.h		\
			xrandr.c 		\
			xrandr.h

TESTS =			test-sbuf-utf8-nconcat
check_PROGRAMS =	test-sbuf-utf8-nconcat

test_sbuf_utf8_nconcat_SOURCES = 		\
			test-sbuf-utf8-nconcat.c \
			sbuf.c			\
			sbuf.h			\
			utf8.c			\
			utf8.h			\
			util.c			\
			util.h



================================================
FILE: src/manage.c
================================================
/* Manage windows, such as Mapping them and making sure the proper key
 * Grabs have been put in place.
 *
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/keysymdef.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ratpoison.h"

static char **unmanaged_window_list = NULL;
static int num_unmanaged_windows = 0;

void
clear_unmanaged_list (void)
{
  if (unmanaged_window_list)
    {
      int i;

      for (i = 0; i < num_unmanaged_windows; i++)
        free(unmanaged_window_list[i]);

      free(unmanaged_window_list);

      unmanaged_window_list = NULL;
    }
  num_unmanaged_windows = 0;
}

char *
list_unmanaged_windows (void)
{
  char *tmp = NULL;

  if (unmanaged_window_list)
    {
      struct sbuf *buf;
      int i;

      buf = sbuf_new (0);

      for (i = 0; i < num_unmanaged_windows; i++)
        {
          sbuf_concat (buf, unmanaged_window_list[i]);
          sbuf_concat (buf, "\n");
        }
      sbuf_chop (buf);
      tmp = sbuf_free_struct (buf);
    }
  return tmp;
}

void
add_unmanaged_window (char *name)
{
  char **tmp;

  if (!name) return;

  tmp = xmalloc((num_unmanaged_windows + 1) * sizeof(char *));

  if (unmanaged_window_list)
    {
      memcpy(tmp, unmanaged_window_list, num_unmanaged_windows * sizeof(char *));
      free(unmanaged_window_list);
    }

  tmp[num_unmanaged_windows] = xstrdup(name);
  num_unmanaged_windows++;

  unmanaged_window_list = tmp;
}

void
grab_top_level_keys (Window w)
{
#ifdef HIDE_MOUSE
  XGrabKey(dpy, AnyKey, AnyModifier, w, True,
           GrabModeAsync, GrabModeAsync);
#else
  rp_keymap *map = find_keymap (defaults.top_kmap);
  int i;

  if (map == NULL)
    {
      PRINT_ERROR (("Unable to find %s level keymap\n", defaults.top_kmap));
      return;
    }

  PRINT_DEBUG(("grabbing top level key\n"));
  for (i=0; i<map->actions_last; i++)
    {
      PRINT_DEBUG(("%d\n", i));
      grab_key (map->actions[i].key, map->actions[i].state, w);
    }
#endif
}

void
ungrab_top_level_keys (Window w)
{
  XUngrabKey(dpy, AnyKey, AnyModifier, w);
}

void
ungrab_keys_all_wins (void)
{
  rp_window *cur;

  /* Remove the grab on the current prefix key */
  list_for_each_entry (cur, &rp_mapped_window, node)
    {
      ungrab_top_level_keys (cur->w);
    }
}

void
grab_keys_all_wins (void)
{
  rp_window *cur;

  /* Remove the grab on the current prefix key */
  list_for_each_entry (cur, &rp_mapped_window, node)
    {
      grab_top_level_keys (cur->w);
    }
}

void
update_normal_hints (rp_window *win)
{
  long supplied;

  XGetWMNormalHints (dpy, win->w, win->hints, &supplied);

  /* Print debugging output for window hints. */
#ifdef DEBUG
  if (win->hints->flags & PMinSize)
    PRINT_DEBUG (("minx: %d miny: %d\n", win->hints->min_width, win->hints->min_height));

  if (win->hints->flags & PMaxSize)
    PRINT_DEBUG (("maxx: %d maxy: %d\n", win->hints->max_width, win->hints->max_height));

  if (win->hints->flags & PResizeInc)
    PRINT_DEBUG (("incx: %d incy: %d\n", win->hints->width_inc, win->hints->height_inc));

#endif
}


static char *
get_wmname (Window w)
{
  char *name = NULL;
  XTextProperty text_prop;
  int ret = None, n;
  char** cl;

  /* If current encoding is UTF-8, try to use the window's _NET_WM_NAME ewmh
     property */
  if (utf8_locale)
    {
      Atom type = None;
      unsigned long nitems, bytes_after;
      int format;
      unsigned char *val = NULL;

      ret = XGetWindowProperty (dpy, w, _net_wm_name, 0, 40, False,
				xa_utf8_string, &type, &format, &nitems,
				&bytes_after, &val);
      /* We have a valid UTF-8 string */
      if (ret == Success && type == xa_utf8_string
	  && format == 8 && nitems > 0)
	{
	  name = xstrdup ((char *)val);
	  XFree (val);
          PRINT_DEBUG (("Fetching window name using _NET_WM_NAME succeeded\n"));
	  PRINT_DEBUG (("WM_NAME: %s\n", name));
	  return name;
	}
      /* Something went wrong for whatever reason */
      if (ret == Success && val)
	XFree (val);
      PRINT_DEBUG (("Could not fetch window name using _NET_WM_NAME\n"));
    }

  if (XGetWMName (dpy, w, &text_prop) == 0)
    {
      PRINT_DEBUG (("XGetWMName failed\n"));
      return NULL;
    }

  PRINT_DEBUG (("WM_NAME encoding: "));
  if (text_prop.encoding == xa_string)
    PRINT_DEBUG  (("STRING\n"));
  else if (text_prop.encoding == xa_compound_text)
    PRINT_DEBUG (("COMPOUND_TEXT\n"));
  else if (text_prop.encoding == xa_utf8_string)
    PRINT_DEBUG (("UTF8_STRING\n"));
  else
    PRINT_DEBUG (("unknown (%d)\n", (int) text_prop.encoding));

#ifdef X_HAVE_UTF8_STRING
  /* It seems that most applications supporting UTF8_STRING and
     _NET_WM_NAME don't bother making their WM_NAME available as
     UTF8_STRING (but only as either STRING or COMPOUND_TEXT).
     Let's try anyway.  */
  if (utf8_locale && text_prop.encoding == xa_utf8_string)
    {
      ret = Xutf8TextPropertyToTextList (dpy, &text_prop, &cl, &n);
      PRINT_DEBUG (("Xutf8TextPropertyToTextList: %s\n",
		    ret == Success ? "success" : "error"));
    }
  else
#endif
    {
      /* XmbTextPropertyToTextList should be fine for all cases,
	 even UTF8_STRING encoded WM_NAME */
      ret = XmbTextPropertyToTextList (dpy, &text_prop, &cl, &n);
      PRINT_DEBUG (("XmbTextPropertyToTextList: %s\n",
		    ret == Success ? "success" : "error"));
    }

  if (ret == Success && cl && n > 0)
    {
      name = xstrdup (cl[0]);
      XFreeStringList (cl);
    }
  else if (text_prop.value)
    {
      /* Convertion failed, try to get the raw string */
      name = xstrdup ((char *) text_prop.value);
      XFree (text_prop.value);
    }

  if (name == NULL) {
    PRINT_DEBUG (("I can't get the WMName.\n"));
  } else {
    PRINT_DEBUG (("WM_NAME: '%s'\n", name));
  }

  return name;
}

static XClassHint *
get_class_hints (Window w)
{
  XClassHint *class;

  class = XAllocClassHint();

  if (class == NULL)
    {
      PRINT_ERROR (("Not enough memory for WM_CLASS structure.\n"));
      exit (EXIT_FAILURE);
    }

  XGetClassHint (dpy, w, class);

  return class;
}

/* Reget the WM_NAME property for the window and update its
   name. Return 1 if the name changed. */
int
update_window_name (rp_window *win)
{
  char *newstr;
  int changed = 0;
  XClassHint *class;

  newstr = get_wmname (win->w);
  if (newstr != NULL)
    {
      changed = changed || win->wm_name == NULL || strcmp (newstr, win->wm_name);
      free (win->wm_name);
      win->wm_name = newstr;
    }

  class = get_class_hints (win->w);

  if (class->res_class != NULL
      && (win->res_class == NULL || strcmp (class->res_class, win->res_class)))
    {
      changed = 1;
      free (win->res_class);
      win->res_class = xstrdup(class->res_class);
    }

  if (class->res_name != NULL
      && (win->res_name == NULL || strcmp (class->res_name, win->res_name)))
    {
      changed = 1;
      free (win->res_name);
      win->res_name = xstrdup(class->res_name);
    }

  XFree (class->res_name);
  XFree (class->res_class);
  XFree (class);
  return changed;
}

/* This function is used to determine if the window should be treated
   as a transient. */
int
window_is_transient (rp_window *win)
{
  return win->transient
#ifdef ASPECT_WINDOWS_ARE_TRANSIENTS
 || win->hints->flags & PAspect
#endif
#ifdef MAXSIZE_WINDOWS_ARE_TRANSIENTS
|| (win->hints->flags & PMaxSize
    && (win->hints->max_width < win->scr->width
        || win->hints->max_height < win->scr->height))
#endif
    ;
}

static Atom
get_net_wm_window_type (rp_window *win)
{
  Atom type, window_type = None;
  int format;
  unsigned long nitems;
  unsigned long bytes_left;
  unsigned char *data;

  if (win == NULL)
    return None;

  if (XGetWindowProperty (dpy, win->w, _net_wm_window_type, 0, 1L,
                          False, XA_ATOM, &type, &format,
                          &nitems, &bytes_left,
                          &data) == Success && nitems > 0)
    {
      window_type = *(Atom *)data;
      XFree (data);
      PRINT_DEBUG(("hey ya %ld %ld\n", window_type, _net_wm_window_type_dialog));
    }

  return window_type;
}


void
update_window_information (rp_window *win)
{
  XWindowAttributes attr;

  update_window_name (win);

  /* Get the WM Hints */
  update_normal_hints (win);

  /* Get the colormap */
  XGetWindowAttributes (dpy, win->w, &attr);
  win->colormap = attr.colormap;
  win->x = attr.x;
  win->y = attr.y;
  win->width = attr.width;
  win->height = attr.height;
  win->border = attr.border_width;

  /* Transient status */
  win->transient = XGetTransientForHint (dpy, win->w, &win->transient_for);

  if (get_net_wm_window_type(win) == _net_wm_window_type_dialog)
    win->transient = 1;

  update_window_gravity (win);
}

void
unmanage (rp_window *w)
{
  list_del (&w->node);
  groups_del_window (w);

  free_window (w);

#ifdef AUTO_CLOSE
  if (rp_mapped_window.next == &rp_mapped_window
      && rp_mapped_window.prev == &rp_mapped_window)
    {
      /* If the mapped window list is empty then we have run out of
         managed windows, so kill ratpoison. */

      /* FIXME: The unmapped window list may also have to be checked
         in the case that the only mapped window in unmapped and
         shortly after another window is mapped most likely by the
         same app. */

      kill_signalled = 1;
    }
#endif
}

/* When starting up scan existing windows and start managing them. */
void
scanwins (void)
{
  rp_window *win;
  XWindowAttributes attr;
  unsigned int i, nwins;
  Window dw1, dw2, *wins;

  XQueryTree(dpy, rp_glob_screen.root, &dw1, &dw2, &wins, &nwins);
  PRINT_DEBUG (("windows: %d\n", nwins));

  for (i = 0; i < nwins; i++)
    {
      rp_screen *screen;

      XGetWindowAttributes(dpy, wins[i], &attr);
      if (is_rp_window (wins[i])
          || attr.override_redirect == True
          || unmanaged_window (wins[i])) continue;


      screen = find_screen_by_attr (attr);
      if (!screen)
          list_first (screen, &rp_screens, node);

      win = add_to_window_list (screen, wins[i]);

      PRINT_DEBUG (("map_state: %s\n",
                    attr.map_state == IsViewable ? "IsViewable":
                    attr.map_state == IsUnviewable ? "IsUnviewable" : "IsUnmapped"));
      PRINT_DEBUG (("state: %s\n",
                    get_state(win) == IconicState ? "Iconic":
                    get_state(win) == NormalState ? "Normal" : "Other"));

      /* Collect mapped and iconized windows. */
      if (attr.map_state == IsViewable
          || (attr.map_state == IsUnmapped
              && get_state (win) == IconicState))
        map_window (win);
    }

  XFree(wins);
}

int
unmanaged_window (Window w)
{
  char *wname;
  int i;

  if (!unmanaged_window_list)
    return 0;

  wname = get_wmname (w);
  if (!wname)
    return 0;

  for (i = 0; i < num_unmanaged_windows; i++)
    {
      if (!strcmp (unmanaged_window_list[i], wname))
        {
          free (wname);
          return 1;
        }
    }

  free (wname);
  return 0;
}

/* Set the state of the window. */
void
set_state (rp_window *win, int state)
{
  long data[2];

  win->state = state;

  data[0] = (long)win->state;
  data[1] = (long)None;

  XChangeProperty (dpy, win->w, wm_state, wm_state, 32,
                   PropModeReplace, (unsigned char *)data, 2);
}

/* Get the WM state of the window. */
long
get_state (rp_window *win)
{
  long state = WithdrawnState;
  Atom type;
  int format;
  unsigned long nitems;
  unsigned long bytes_left;
  unsigned char *data;

  if (win == NULL)
    return state;

  if (XGetWindowProperty (dpy, win->w, wm_state, 0L, 2L,
                          False, wm_state, &type, &format,
                          &nitems, &bytes_left,
                          &data) == Success && nitems > 0)
    {
      state = *(long *)data;
      XFree (data);
    }

  return state;
}

static void
move_window (rp_window *win)
{
  rp_frame *frame;

  if (win->frame_number == EMPTY)
    return;

  frame = win_get_frame (win);

  /* X coord. */
  switch (win->gravity)
    {
    case NorthWestGravity:
    case WestGravity:
    case SouthWestGravity:
      win->x = frame->x;
      break;
    case NorthGravity:
    case CenterGravity:
    case SouthGravity:
      win->x = frame->x + (frame->width - win->border * 2) / 2 - win->width / 2;
      break;
    case NorthEastGravity:
    case EastGravity:
    case SouthEastGravity:
      win->x = frame->x + frame->width - win->width - win->border;
      break;
    }

  /* Y coord. */
  switch (win->gravity)
    {
    case NorthEastGravity:
    case NorthGravity:
    case NorthWestGravity:
      win->y = frame->y;
      break;
    case EastGravity:
    case CenterGravity:
    case WestGravity:
      win->y = frame->y + (frame->height - win->border * 2) / 2 - win->height / 2;
      break;
    case SouthEastGravity:
    case SouthGravity:
    case SouthWestGravity:
      win->y = frame->y + frame->height - win->height - win->border;
      break;
    }
}

/* Set a transient window's x,y,width,height fields to maximize the
   window. */
static void
maximize_transient (rp_window *win)
{
  rp_frame *frame;
  int maxx, maxy;

  frame = win_get_frame (win);

  /* We can't maximize a window if it has no frame. */
  if (frame == NULL)
    return;

  /* Set the window's border */
  win->border = defaults.window_border_width;

  /* Always use the window's current width and height for
     transients. */
  maxx = win->width;
  maxy = win->height;

  /* Fit the window inside its frame (if it has one) */
  if (frame)
    {
      PRINT_DEBUG (("frame width=%d height=%d\n",
                   frame->width, frame->height));

      if (maxx + win->border * 2 > frame->width) maxx = frame->width - win->border * 2;
      if (maxy + win->border * 2 > frame->height) maxy = frame->height - win->border * 2;
    }

  /* Make sure we maximize to the nearest Resize Increment specified
     by the window */
  if (win->hints->flags & PResizeInc)
    {
      int amount;
      int delta;

      /* Avoid a divide by zero if width/height_inc is 0. */
      if (win->hints->width_inc)
        {
          amount = maxx - win->width;
          delta = amount % win->hints->width_inc;
          amount -= delta;
          if (amount < 0 && delta) amount -= win->hints->width_inc;
          maxx = amount + win->width;
        }

      if (win->hints->height_inc)
        {
          amount = maxy - win->height;
          delta = amount % win->hints->height_inc;
          amount -= delta;
          if (amount < 0 && delta) amount -= win->hints->height_inc;
          maxy = amount + win->height;
        }
    }

  PRINT_DEBUG (("maxsize: %d %d\n", maxx, maxy));

  win->width = maxx;
  win->height = maxy;
}

/* set a good standard window's x,y,width,height fields to maximize
   the window. */
static void
maximize_normal (rp_window *win)
{
  rp_frame *frame;
  int maxx, maxy;

  frame = win_get_frame (win);

  /* We can't maximize a window if it has no frame. */
  if (frame == NULL)
    return;

  /* Set the window's border */
  if (defaults.only_border == 0 && num_frames(win->scr) <= 1){
    win->border = 0;
  } else {
    win->border = defaults.window_border_width;
  }


  /* Honour the window's maximum size */
  if (win->hints->flags & PMaxSize)
    {
      maxx = win->hints->max_width;
      maxy = win->hints->max_height;
    }
  else
    {
      maxx = frame->width - win->border * 2;
      maxy = frame->height - win->border * 2;
    }

  /* Honour the window's aspect ratio. */
  PRINT_DEBUG (("aspect: %ld\n", win->hints->flags & PAspect));
  if (win->hints->flags & PAspect)
    {
      float ratio = (float)maxx / maxy;
      float min_ratio = (float)win->hints->min_aspect.x / win->hints->min_aspect.y;
      float max_ratio = (float)win->hints->max_aspect.x / win->hints->max_aspect.y;
      PRINT_DEBUG (("ratio=%f min_ratio=%f max_ratio=%f\n",
                    ratio,min_ratio,max_ratio));
      if (ratio < min_ratio)
        {
          maxy = (int) (maxx / min_ratio);
        }
      else if (ratio > max_ratio)
        {
          maxx = (int) (maxy * max_ratio);
        }
    }

  /* Fit the window inside its frame (if it has one) */
  if (frame)
    {
      PRINT_DEBUG (("frame width=%d height=%d\n",
                   frame->width, frame->height));

      if (maxx > frame->width) maxx = frame->width - win->border * 2;
      if (maxy > frame->height) maxy = frame->height - win->border * 2;
    }

  /* Make sure we maximize to the nearest Resize Increment specified
     by the window */
  if (win->hints->flags & PResizeInc)
    {
      int amount;
      int delta;

      if (win->hints->width_inc)
        {
          amount = maxx - win->width;
          delta = amount % win->hints->width_inc;
          if (amount < 0 && delta) amount -= win->hints->width_inc;
          amount -= delta;
          maxx = amount + win->width;
        }

      if (win->hints->height_inc)
        {
          amount = maxy - win->height;
          delta = amount % win->hints->height_inc;
          if (amount < 0 && delta) amount -= win->hints->height_inc;
          amount -= delta;
          maxy = amount + win->height;
        }
    }

  PRINT_DEBUG (("maxsize: %d %d\n", maxx, maxy));

  win->width = maxx;
  win->height = maxy;
}

/* Maximize the current window if data = 0, otherwise assume it is a
   pointer to a window that should be maximized */
void
maximize (rp_window *win)
{
  if (!win) win = current_window();
  if (!win) return;

  /* Handle maximizing transient windows differently. */
  if (win->transient)
    maximize_transient (win);
  else
    maximize_normal (win);

  /* Reposition the window. */
  move_window (win);

  PRINT_DEBUG (("Resizing window '%s' to x:%d y:%d w:%d h:%d\n", window_name (win),
               win->x, win->y, win->width, win->height));


  /* Actually do the maximizing. */
  XMoveResizeWindow (dpy, win->w, win->scr->left + win->x, win->scr->top + win->y, win->width, win->height);
  XSetWindowBorderWidth (dpy, win->w, win->border);

  XSync (dpy, False);
}

/* Maximize the current window but don't treat transient windows
   differently. */
void
force_maximize (rp_window *win)
{
  if (!win) win = current_window();
  if (!win) return;

  maximize_normal(win);

  /* Reposition the window. */
  move_window (win);

  /* This little dance is to force a maximize event. If the window is
     already "maximized" X11 will optimize away the event since to
     geometry changes were made. This initial resize solves the
     problem. */
  if (win->hints->flags & PResizeInc)
    {
      XMoveResizeWindow (dpy, win->w, win->scr->left + win->x, win->scr->top + win->y,
                         win->width + win->hints->width_inc,
                         win->height + win->hints->height_inc);
    }
  else
    {
      XResizeWindow (dpy, win->w, win->width + 1, win->height + 1);
    }

  XSync (dpy, False);

  /* Resize the window to its proper maximum size. */
  XMoveResizeWindow (dpy, win->w, win->scr->left + win->x, win->scr->top + win->y, win->width, win->height);
  XSetWindowBorderWidth (dpy, win->w, win->border);

  XSync (dpy, False);
}

/* map the unmapped window win */
void
map_window (rp_window *win)
{
  PRINT_DEBUG (("Mapping the unmapped window %s\n", window_name (win)));

  /* Fill in the necessary data about the window */
  update_window_information (win);
  win->number = numset_request (rp_window_numset);
  grab_top_level_keys (win->w);

  /* Put win in the mapped window list */
  list_del (&win->node);
  insert_into_list (win, &rp_mapped_window);

  /* Update all groups. */
  groups_map_window (win);

  /* The window has never been accessed since it was brought back from
     the Withdrawn state. */
  win->last_access = 0;

  /* It is now considered iconic and set_active_window can handle the rest. */
  set_state (win, IconicState);

  /* Depending on the rudeness level, actually map the window. */
  if ((rp_honour_transient_map && win->transient)
      || (rp_honour_normal_map && !win->transient))
    set_active_window (win);
  else
    show_rudeness_msg (win, 0);

  hook_run (&rp_new_window_hook);
}

void
hide_window (rp_window *win)
{
  if (win == NULL) return;

  /* An unmapped window is not inside a frame. */
  win->frame_number = EMPTY;

  /* Ignore the unmap_notify event. */
  XSelectInput(dpy, win->w, WIN_EVENTS&~(StructureNotifyMask));
  XUnmapWindow (dpy, win->w);
  XSelectInput (dpy, win->w, WIN_EVENTS);
  /* Ensure that the window doesn't have the focused border
     color. This is needed by remove_frame and possibly others. */
  XSetWindowBorder (dpy, win->w, rp_glob_screen.bw_color);
  set_state (win, IconicState);
}

void
unhide_window (rp_window *win)
{
  if (win == NULL) return;

  /* Always raise the window. */
  XRaiseWindow (dpy, win->w);

  if (win->state != IconicState) return;

  XMapWindow (dpy, win->w);
  set_state (win, NormalState);
}

void
unhide_all_windows (void)
{
  struct list_head *tmp, *iter;
  rp_window *win;

  list_for_each_safe_entry (win, iter, tmp, &rp_mapped_window, node)
    unhide_window (win);
}

void
withdraw_window (rp_window *win)
{
  if (win == NULL) return;

  PRINT_DEBUG (("withdraw_window on '%s'\n", window_name (win)));

  /* Give back the window number. the window will get another one,
     if it is remapped. */
  if (win->number == -1)
    PRINT_ERROR(("Attempting to withdraw '%s' with number -1!\n", window_name(win)));

  numset_release (rp_window_numset, win->number);
  win->number = -1;

  list_move_tail(&win->node, &rp_unmapped_window);

  /* Update the groups. */
  groups_unmap_window (win);

  ignore_badwindow++;

  XRemoveFromSaveSet (dpy, win->w);
  set_state (win, WithdrawnState);
  XSync (dpy, False);

  ignore_badwindow--;

  /* Call our hook */
  hook_run (&rp_delete_window_hook);
}

/* Hide all other mapped windows except for win in win's frame. */
void
hide_others (rp_window *win)
{
  rp_frame *frame;
  rp_window *cur;

  if (win == NULL) return;
  frame = find_windows_frame (win);
  if (frame == NULL) return;

  list_for_each_entry (cur, &rp_mapped_window, node)
    {
      if (find_windows_frame (cur)
          || cur->state != NormalState
          || cur->frame_number != frame->number)
        continue;

      hide_window (cur);
    }
}

/* Hide any window displayed on the given screen */
void
hide_screen_windows (rp_screen *s)
{
    rp_frame *cur_frame;
    rp_window *cur_win;

  list_for_each_entry (cur_frame, &s->frames, node)
    {
      cur_win = find_window_number (cur_frame->win_number);
      hide_window (cur_win);
    }
}



================================================
FILE: src/manage.h
================================================
/* manage.h
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_MANAGE_H
#define _RATPOISON_MANAGE_H 1

#include "data.h"

void clear_unmanaged_list (void);
char *list_unmanaged_windows (void);
void add_unmanaged_window (char *name);
int unmanaged_window (Window w);
void scanwins (void);
void unmanage (rp_window *w);
int update_window_name (rp_window *win);
void update_normal_hints (rp_window *win);
void rename_current_window (void);
void set_state (rp_window *win, int state);
long get_state (rp_window *win);

int window_is_transient (rp_window *win);
void update_window_information (rp_window *win);
void map_window (rp_window *win);

void maximize (rp_window *win);
void force_maximize (rp_window *win);

void grab_top_level_keys (Window w);
void ungrab_top_level_keys (Window w);
void ungrab_keys_all_wins (void);
void grab_keys_all_wins (void);

void hide_window (rp_window *win);
void unhide_window (rp_window *win);
void unhide_all_windows (void);
void withdraw_window (rp_window *win);
void hide_others (rp_window *win);
void hide_screen_windows (rp_screen *s);

#endif /* ! _RATPOISION_MANAGE_H */



================================================
FILE: src/messages.h
================================================
/* Ratpoison messages.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_MESSAGES_H
#define _RATPOISON_MESSAGES_H 1

#define MESSAGE_NO_OTHER_WINDOW "No other window"
#define MESSAGE_NO_OTHER_FRAME          "No other frame"
#define MESSAGE_NO_MANAGED_WINDOWS      "No managed windows"
#define MESSAGE_UNKNOWN_COMMAND "unknown command '%s'"
#define MESSAGE_WINDOW_INFORMATION      "This is window %d (%s)"

#define MESSAGE_RAISE_TRANSIENT "Raise request from transient window %d (%s)"
#define MESSAGE_RAISE_WINDOW            "Raise request from window %d (%s)"
#define MESSAGE_RAISE_TRANSIENT_GROUP   "Raise request from transient window %d (%s) in group %s"
#define MESSAGE_RAISE_WINDOW_GROUP      "Raise request from window %d (%s) in group %s"
#define MESSAGE_MAP_TRANSIENT           "New transient window %d (%s)"
#define MESSAGE_MAP_WINDOW              "New window %d (%s)"
#define MESSAGE_MAP_TRANSIENT_GROUP     "New transient window %d (%s) in group %s"
#define MESSAGE_MAP_WINDOW_GROUP        "New window %d (%s) in group %s"

#define MESSAGE_PROMPT_SWITCH_TO_WINDOW "Switch to window: "
#define MESSAGE_PROMPT_NEW_WINDOW_NAME  "Set window's title to: "
#define MESSAGE_PROMPT_SHELL_COMMAND    "/bin/sh -c "
#define MESSAGE_PROMPT_COMMAND          ":"
#define MESSAGE_PROMPT_SWITCH_WM        "Switch to wm: "
#define MESSAGE_PROMPT_XTERM_COMMAND    MESSAGE_PROMPT_SHELL_COMMAND TERM_PROG " -e "
#define MESSAGE_PROMPT_SWITCH_TO_GROUP  "Switch to group: "
#define MESSAGE_PROMPT_SELECT_VAR  "Variable: "
#define MESSAGE_PROMPT_VAR_VALUE  "Value: "

#define MESSAGE_WELCOME "Welcome to ratpoison! Hit `%s %s' for help."

#define EMPTY_FRAME_MESSAGE "Current Frame"

#endif /* ! _RATPOISON_MESSAGES_H */



================================================
FILE: src/number.c
================================================
/* handles the handing out of and uniqueness of window numbers.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <stdlib.h>
#include <stdio.h>

#include "ratpoison.h"

/* Keep track of a set of numbers. For frames and windows. */
struct numset
{
  /* A list of the numbers taken. */
  int *numbers_taken;

/* the number of numbers currently stored in the numbers_taken
   array. */
  int num_taken;

/* the size of the numbers_taken array. */
  int max_taken;
};

/* Initialize a numset structure. */
static void
numset_init (struct numset *ns)
{
  ns->max_taken = 10;
  ns->num_taken = 0;

  ns->numbers_taken = xmalloc (ns->max_taken * sizeof (int));
}

static int
numset_num_is_taken (struct numset *ns, int n)
{
  int i;

  for (i=0; i<ns->num_taken; i++)
    {
      if (ns->numbers_taken[i] == n) return 1;
    }
  return 0;
}

/* returns index into numbers_taken that can be used. */
static int
numset_find_empty_cell (struct numset *ns)
{
  int i;

  for (i=0; i<ns->num_taken; i++)
    {
      if (ns->numbers_taken[i] == -1) return i;
    }

  /* no vacant ones, so grow the array. */
  if (ns->num_taken >= ns->max_taken)
    {
      ns->max_taken *= 2;
      ns->numbers_taken = xrealloc (ns->numbers_taken, sizeof (int) * ns->max_taken);
    }
  ns->num_taken++;

  return ns->num_taken-1;
}

int
numset_add_num (struct numset *ns, int n)
{
  int ec;

  PRINT_DEBUG(("ns=%p add_num %d\n", ns, n));

  if (numset_num_is_taken (ns, n))
    return 0; /* failed. */
  /* numset_find_empty_cell calls realloc on numbers_taken. So store
     the ret val in ec then use ec as an index into the array. */
  ec = numset_find_empty_cell(ns);
  ns->numbers_taken[ec] = n;
  return 1; /* success! */
}

/* returns a unique number that can be used as the window number in
   the program bar. */
int
numset_request (struct numset *ns)
{
  int i;

  /* look for a unique number, and add it to the list of taken
     numbers. */
  i = 0;
  while (!numset_add_num (ns, i)) i++;

  PRINT_DEBUG(("ns=%p request got %d\n", ns, i));

  return i;
}

/* When a window is destroyed, it gives back its window number with
   this function. */
void
numset_release (struct numset *ns, int n)
{
  int i;

  PRINT_DEBUG(("ns=%p release %d\n", ns, n));

  if (n < 0)
    PRINT_ERROR(("ns=%p Attempt to release %d!\n", ns, n));

  for (i=0; i<ns->num_taken; i++)
    {
      if (ns->numbers_taken[i] == n)
        {
          ns->numbers_taken[i] = -1;
          return;
        }
    }
}

/* Create a new numset and return a pointer to it. */
struct numset *
numset_new (void)
{
  struct numset *ns;

  ns = xmalloc (sizeof (struct numset));
  numset_init (ns);
  return ns;
}

/* Free a numset structure and it's internal data. */
void
numset_free (struct numset *ns)
{
  free (ns->numbers_taken);
  free (ns);
}



================================================
FILE: src/number.h
================================================
/* Function prototypes.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_NUMBER_H
#define _RATPOISON_NUMBER_H 1

struct numset;

struct numset *numset_new (void);
void numset_free (struct numset *ns);
void numset_release (struct numset *ns, int n);
int numset_request (struct numset *ns);
int numset_add_num (struct numset *ns, int n);

#endif /* ! _RATPOISON_NUMBER_H */



================================================
FILE: src/ratpoison.h
================================================
/* Standard header for ratpoison.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_H
#define _RATPOISON_H 1

#include "config.h"

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xlocale.h>
#include <fcntl.h>

#if defined(__BASE_FILE__)
#define RP_FILE_NAME __BASE_FILE__
#else
#define RP_FILE_NAME __FILE__
#endif

/* Helper macro for error and debug reporting. */
#define PRINT_LINE(type) printf (PACKAGE ":%s:%d: %s: ",RP_FILE_NAME,  __LINE__, #type)

/* Error and debug reporting macros. */
#define PRINT_ERROR(fmt)                        \
do {                                            \
  PRINT_LINE (error);                           \
  printf fmt;                                   \
  fflush (stdout);                              \
} while (0)

#define PRINT_WARNING(fmt)                      \
do {                                            \
  PRINT_LINE (warning);                         \
  printf fmt;                                   \
  fflush (stdout);                              \
} while (0)

#ifdef DEBUG
#define PRINT_DEBUG(fmt)                        \
do {                                            \
  PRINT_LINE (debug);                           \
  printf fmt;                                   \
  fflush (stdout);                              \
} while (0)
#else
#define PRINT_DEBUG(fmt) do {} while (0)
#endif /* DEBUG */

#include "conf.h"

#include "data.h"
#include "globals.h"
#include "manage.h"
#include "window.h"
#include "bar.h"
#include "events.h"
#include "number.h"
#include "input.h"
#include "messages.h"
#include "communications.h"
#include "sbuf.h"
#include "split.h"
#include "frame.h"
#include "screen.h"
#include "group.h"
#include "editor.h"
#include "history.h"
#include "completions.h"
#include "hook.h"
#include "xrandr.h"
#include "format.h"
#include "utf8.h"
#include "util.h"

void set_extents_of_fontset (XFontSet font);
XFontSet load_query_font_set (Display *disp, const char *fontset_name);

#endif /* ! _RATPOISON_H */



================================================
FILE: src/sbuf.c
================================================
/* Functions for handling string buffers.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <string.h>

#include "ratpoison.h"
#include "sbuf.h"

struct sbuf *
sbuf_new (size_t initsz)
{
  struct sbuf *b = xmalloc (sizeof (struct sbuf));

  if (initsz < 1)
    initsz = 1;

  b->data = xmalloc (initsz);
  b->maxsz = initsz;

  b->data[0] = '\0';
  b->len = 0;

  return b;
}

void
sbuf_free (struct sbuf *b)
{
  if (b != NULL)
    {
      free (b->data);
      free (b);
    }
}

/* Free the structure but return the string. */
char *
sbuf_free_struct (struct sbuf *b)
{
  if (b != NULL)
    {
      char *tmp;
      tmp = b->data;
      free (b);
      return tmp;
    }

  return NULL;
}

char *
sbuf_nconcat (struct sbuf *b, const char *str, int len)
{
  size_t minsz = b->len + len + 1;

  if (b->maxsz < minsz)
    {
      b->data = xrealloc (b->data, minsz);
      b->maxsz = minsz;
    }

  memcpy (b->data + b->len, str, minsz - b->len - 1);
  b->len = minsz - 1;
  *(b->data + b->len) = 0;

  return b->data;
}


char *
sbuf_concat (struct sbuf *b, const char *str)
{
  return sbuf_nconcat (b, str, strlen (str));
}

char *
sbuf_copy (struct sbuf *b, const char *str)
{
  b->len = 0;
  return sbuf_concat (b, str);
}

char *
sbuf_clear (struct sbuf *b)
{
  b->len = 0;
  b->data[0] = '\0';
  return b->data;
}

char *
sbuf_get (struct sbuf *b)
{
  return b->data;
}

char *
sbuf_printf (struct sbuf *b, char *fmt, ...)
{
  va_list ap;

  free (b->data);

  va_start (ap, fmt);
  b->data = xvsprintf (fmt, ap);
  va_end (ap);

  b->len = strlen (b->data);
  b->maxsz = b->len + 1;

  return b->data;
}

char *
sbuf_printf_concat (struct sbuf *b, char *fmt, ...)
{
  char *buffer;
  va_list ap;

  va_start (ap, fmt);
  buffer = xvsprintf (fmt, ap);
  va_end (ap);

  sbuf_concat (b, buffer);
  free (buffer);

  return b->data;
}

/* if width >= 0 then limit the width of s to width chars. */
char *
sbuf_utf8_nconcat (struct sbuf *b, const char *s, int width)
{
  if (width >= 0)
    {
      int len, nchars;

      len = nchars = 0;
      while (s[len] != '\0' && nchars < width)
        {
          if (isu8start (s[len]))
            do
              len++;
            while (isu8cont (s[len]));
          else
            len++;
          nchars++;
        }
      sbuf_printf_concat (b, "%.*s", len, s);
    }
  else
    sbuf_concat (b, s);

  return b->data;
}

void
sbuf_chop (struct sbuf *b)
{
  if (b->len)
    {
      b->data[--(b->len)] = '\0';
    }
}



================================================
FILE: src/sbuf.h
================================================
/* Function prototypes for handling string buffers.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_SBUF_H
#define _RATPOISON_SBUF_H 1

#include <stdlib.h>

struct sbuf
{
  char *data;
  size_t len;
  size_t maxsz;

  /* sbuf can exist in a list. */
  struct list_head node;
};

struct sbuf *sbuf_new (size_t initsz);
void sbuf_free (struct sbuf *b);
char *sbuf_free_struct (struct sbuf *b);
char *sbuf_concat (struct sbuf *b, const char *str);
char *sbuf_nconcat (struct sbuf *b, const char *str, int len);
char *sbuf_utf8_nconcat (struct sbuf *b, const char *s, int width);
char *sbuf_copy (struct sbuf *b, const char *str);
char *sbuf_clear (struct sbuf *b);
char *sbuf_get (struct sbuf *b);
char *sbuf_printf (struct sbuf *b, char *fmt, ...);
char *sbuf_printf_concat (struct sbuf *b, char *fmt, ...);
void  sbuf_chop (struct sbuf *b);

#endif /* ! _RATPOISON_SBUF_H */



================================================
FILE: src/screen.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 * Copyright (C) 2016 Mathieu OTHACEHE <m.othacehe@gmail.com>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "ratpoison.h"
#include <string.h>
#include <X11/cursorfont.h>

static void init_screen (rp_screen *s);

int
screen_width (rp_screen *s)
{
  return s->width - defaults.padding_right - defaults.padding_left;
}

int
screen_height (rp_screen *s)
{
  return s->height - defaults.padding_bottom - defaults.padding_top;
}

int
screen_left (rp_screen *s)
{
  return s->left + defaults.padding_left;
}

int
screen_right (rp_screen *s)
{
  return screen_left (s) + screen_width (s);
}

int
screen_top (rp_screen *s)
{
  return s->top + defaults.padding_top;
}

int
screen_bottom (rp_screen *s)
{
  return screen_top (s) + screen_height (s);
}

/* Returns a pointer to a list of frames. */
struct list_head *
screen_copy_frameset (rp_screen *s)
{
  struct list_head *head;
  rp_frame *cur;

  /* Init our new list. */
  head = xmalloc (sizeof (struct list_head));
  INIT_LIST_HEAD (head);

  /* Copy each frame to our new list. */
  list_for_each_entry (cur, &s->frames, node)
    {
      list_add_tail (&(frame_copy (cur))->node, head);
    }

  return head;
}

/* Set head as the frameset, deleting the existing one. */
void
screen_restore_frameset (rp_screen *s, struct list_head *head)
{
  frameset_free (&s->frames);
  INIT_LIST_HEAD (&s->frames);

  /* Hook in our new frameset. */
  list_splice (head, &s->frames);
}


/* Given a screen, free the frames' numbers from the numset. */
void
screen_free_nums (rp_screen *s)
{
  rp_frame *cur;

  list_for_each_entry (cur, &s->frames, node)
    {
      numset_release (s->frames_numset, cur->number);
    }
}

/* Given a list of frames, free them, but don't remove their numbers
   from the numset. */
void
frameset_free (struct list_head *head)
{
  rp_frame *frame;
  struct list_head *iter, *tmp;

  list_for_each_safe_entry (frame, iter, tmp, head, node)
    {
      /* FIXME: what if frames has memory inside its struct
         that needs to be freed? */
      free (frame);
    }
}

rp_frame *
screen_get_frame (rp_screen *s, int frame_num)
{
  rp_frame *cur;

  list_for_each_entry (cur, &s->frames, node)
    {
      if (cur->number == frame_num)
        return cur;
    }

  return NULL;
}

rp_frame *
screen_find_frame_by_frame (rp_screen *s, rp_frame *f)
{
  rp_frame *cur;

  list_for_each_entry (cur, &s->frames, node)
    {
      PRINT_DEBUG (("cur=%p f=%p\n", cur, f));
      if (cur == f)
        return cur;
    }

  return NULL;
}

/* Given a root window, return the rp_screen struct */
rp_screen *
find_screen (Window w)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (cur->root == w)
        return cur;
    }

  return NULL;
}

/* Given a window attr, return the rp_screen struct */
rp_screen *
find_screen_by_attr (XWindowAttributes attr)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (attr.x >= cur->left &&
          attr.x <= cur->left + cur->width &&
          attr.y >= cur->top &&
          attr.y <= cur->top + cur->height)
        return cur;
    }

  return NULL;
}

/* Return 1 if w is a root window of any of the screens. */
int
is_a_root_window (unsigned int w)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (cur->root == w)
        return 1;
    }

  return 0;
}

rp_screen *
screen_number (int number)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (cur->number == number)
        return cur;
    }

  return NULL;
}

static int
screen_cmp (void *priv UNUSED, struct list_head *a, struct list_head *b)
{
  rp_screen *sc_a = container_of (a, typeof(*sc_a), node);
  rp_screen *sc_b = container_of (b, typeof(*sc_b), node);

  if (sc_a->left < sc_b->left)
    return -1;
  if (sc_a->left > sc_b->left)
    return 1;

  if (sc_a->top > sc_b->top)
    return -1;
  if (sc_a->top < sc_b->top)
    return 1;

  return 0;
}

void
screen_sort (void)
{
  return list_sort (NULL, &rp_screens, screen_cmp);
}

static void
screen_set_numbers (void)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      cur->number = numset_request (rp_glob_screen.numset);
    }
}

static void
screen_select_primary (void)
{
  rp_screen *cur;

  /* By default, take the first screen as current screen */
  list_first(cur, &rp_screens, node);
  if (!rp_current_screen)
    rp_current_screen = cur;

  if (!rp_have_xrandr)
    return;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (xrandr_is_primary(cur)) {
        rp_current_screen = cur;
        PRINT_DEBUG(("Xrandr primary screen %d detected\n",
                     rp_current_screen->number));
        break;
      }
    }
}

static void
init_global_screen (rp_global_screen *s)
{
  int screen_num;

  screen_num = DefaultScreen (dpy);
  s->root = RootWindow (dpy, screen_num);

  s->numset = numset_new ();
  s->fg_color = BlackPixel (dpy, screen_num);
  s->bg_color = WhitePixel (dpy, screen_num);
  s->fw_color = BlackPixel (dpy, screen_num);
  s->bw_color = BlackPixel (dpy, screen_num);
}

void
init_screens (void)
{
  int i;
  int screen_count = 0;
  int *rr_outputs = NULL;
  rp_screen *screen;

  /* Get the number of screens */
  if (rp_have_xrandr)
    screen_count = xrandr_query_screen (&rr_outputs);
  else
    screen_count = ScreenCount (dpy);

  /* Create our global frame numset */
  rp_frame_numset = numset_new();

  init_global_screen (&rp_glob_screen);

  for (i = 0; i < screen_count; i++)
    {
      screen = xmalloc (sizeof(*screen));
      list_add (&screen->node, &rp_screens);

      if (rp_have_xrandr)
        xrandr_fill_screen (rr_outputs[i], screen);
      else
        xrandr_fill_screen (i, screen);

      init_screen (screen);
    }

  screen_sort ();
  screen_set_numbers ();
  screen_select_primary ();

  free (rr_outputs);
}

static void
init_rat_cursor (rp_screen *s)
{
  s->rat = XCreateFontCursor (dpy, XC_icon);
}

static void
init_screen (rp_screen *s)
{
  XGCValues gcv;
  struct sbuf *buf;
  char *colon;
  int screen_num;

  screen_num = DefaultScreen (dpy);

  if (!rp_have_xrandr)
    {
      s->left = 0;
      s->top = 0;
      s->width = DisplayWidth (dpy, screen_num);
      s->height = DisplayHeight (dpy, screen_num);
    }

  /* Select on some events on the root window, if this fails, then
     there is already a WM running and the X Error handler will catch
     it, terminating ratpoison. */
  XSelectInput (dpy, RootWindow (dpy, screen_num),
                PropertyChangeMask | ColormapChangeMask
                | SubstructureRedirectMask | SubstructureNotifyMask
                | StructureNotifyMask);
  XSync (dpy, False);

  /* Set the numset for the frames to our global numset. */
  s->frames_numset = rp_frame_numset;

  s->scratch_buffer = NULL;

  /* Build the display string for each screen */
  buf = sbuf_new (0);
  sbuf_printf (buf, "DISPLAY=%s", DisplayString (dpy));
  colon = strrchr (sbuf_get (buf), ':');
  if (colon)
    {
      char *dot;

      dot = strrchr (sbuf_get (buf), '.');
      if (!dot || dot < colon)
        {
          /* no dot was found or it belongs to fqdn - append screen_num
             to the end */
          sbuf_printf_concat (buf, ".%d", screen_num);
        }
    }
  s->display_string = sbuf_free_struct (buf);

  PRINT_DEBUG (("display string: %s\n", s->display_string));

  s->root = RootWindow (dpy, screen_num);
  s->screen_num = screen_num;
  s->def_cmap = DefaultColormap (dpy, screen_num);

  init_rat_cursor (s);

  /* Setup the GC for drawing the font. */
  gcv.foreground = rp_glob_screen.fg_color;
  gcv.background = rp_glob_screen.bg_color;
  gcv.function = GXcopy;
  gcv.line_width = 1;
  gcv.subwindow_mode = IncludeInferiors;
  s->normal_gc = XCreateGC(dpy, s->root,
                           GCForeground | GCBackground | GCFunction
                           | GCLineWidth | GCSubwindowMode,
                           &gcv);
  gcv.foreground = rp_glob_screen.bg_color;
  gcv.background = rp_glob_screen.fg_color;
  s->inverse_gc = XCreateGC(dpy, s->root,
                            GCForeground | GCBackground | GCFunction
                            | GCLineWidth | GCSubwindowMode,
                            &gcv);

  /* Create the program bar window. */
  s->bar_is_raised = 0;
  s->bar_window = XCreateSimpleWindow (dpy, s->root, 0, 0, 1, 1,
                                       defaults.bar_border_width,
                                       rp_glob_screen.fg_color, rp_glob_screen.bg_color);

  /* Setup the window that will receive all keystrokes once the prefix
     key has been pressed. */
  s->key_window = XCreateSimpleWindow (dpy, s->root, 0, 0, 1, 1, 0,
                                       WhitePixel (dpy, screen_num),
                                       BlackPixel (dpy, screen_num));
  XSelectInput (dpy, s->key_window, KeyPressMask | KeyReleaseMask);

  /* Create the input window. */
  s->input_window = XCreateSimpleWindow (dpy, s->root, 0, 0, 1, 1,
                                         defaults.bar_border_width,
                                         rp_glob_screen.fg_color, rp_glob_screen.bg_color);
  XSelectInput (dpy, s->input_window, KeyPressMask | KeyReleaseMask);

  /* Create the frame indicator window */
  s->frame_window = XCreateSimpleWindow (dpy, s->root, 1, 1, 1, 1, defaults.bar_border_width,
                                         rp_glob_screen.fg_color, rp_glob_screen.bg_color);

  /* Create the help window */
  s->help_window = XCreateSimpleWindow (dpy, s->root, s->left, s->top, s->width,
                                        s->height, 0, rp_glob_screen.fg_color, rp_glob_screen.bg_color);
  XSelectInput (dpy, s->help_window, KeyPressMask);

  activate_screen(s);

  XSync (dpy, 0);

#ifdef USE_XFT_FONT
  {
    s->xft_font = XftFontOpenName (dpy, screen_num, DEFAULT_XFT_FONT);
    if (!s->xft_font)
      {
        PRINT_ERROR(("Failed to open font\n"));
      }
    else
      {
        if (!XftColorAllocName (dpy, DefaultVisual (dpy, screen_num),
                                DefaultColormap (dpy, screen_num),
                                defaults.fgcolor_string, &s->xft_fg_color))
          {
            PRINT_ERROR(("Failed to allocate font fg color\n"));
            XftFontClose (dpy, s->xft_font);
            s->xft_font = NULL;
          }
        if (!XftColorAllocName (dpy, DefaultVisual (dpy, screen_num),
                                DefaultColormap (dpy, screen_num),
                                defaults.bgcolor_string, &s->xft_bg_color))
          {
            PRINT_ERROR(("Failed to allocate font fg color\n"));
            XftFontClose (dpy, s->xft_font);
            s->xft_font = NULL;
          }
      }
  }
#endif
}

void
activate_screen (rp_screen *s)
{
  /* Add netwm support. FIXME: I think this is busted. */
  XChangeProperty (dpy, RootWindow (dpy, s->screen_num),
                   _net_supported, XA_ATOM, 32, PropModeReplace,
                   (unsigned char*)&_net_wm_pid, 1);

  /* set window manager name */
  XChangeProperty (dpy, RootWindow (dpy, s->screen_num),
                   _net_wm_name, xa_utf8_string, 8, PropModeReplace,
                   (unsigned char*)"ratpoison", 9);
  XMapWindow (dpy, s->key_window);
}

void
deactivate_screen (rp_screen *s)
{
  /* Unmap its key window */
  XUnmapWindow (dpy, s->key_window);

  /* delete everything so noone sees them while we are not there */
  XDeleteProperty (dpy, RootWindow (dpy, s->screen_num),
                   _net_supported);
  XDeleteProperty (dpy, RootWindow (dpy, s->screen_num),
                   _net_wm_name);
}

static int
is_rp_window_for_given_screen (Window w, rp_screen *s)
{
  if (w != s->key_window &&
      w != s->bar_window &&
      w != s->input_window &&
      w != s->frame_window &&
      w != s->help_window)
    return 0;
  return 1;
}

int
is_rp_window (Window w)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (is_rp_window_for_given_screen (w, cur))
        return 1;
    }

  return 0;
}

char *
screen_dump (rp_screen *screen)
{
  char *tmp;
  struct sbuf *s;

  s = sbuf_new (0);
  if (rp_have_xrandr)
    sbuf_printf(s, "%s ", screen->xrandr.name);

  sbuf_printf_concat (s, "%d %d %d %d %d %d",
                      screen->number,
                      screen->left,
                      screen->top,
                      screen->width,
                      screen->height,
                      (rp_current_screen == screen)?1:0 /* is current? */
                      );

  /* Extract the string and return it, and don't forget to free s. */
  tmp = sbuf_get (s);
  free (s);
  return tmp;
}

int
screen_count (void)
{
  return list_size (&rp_screens);
}

rp_screen *
screen_next (void)
{
  return list_next_entry (rp_current_screen, &rp_screens, node);
}

rp_screen *
screen_prev (void)
{
  return list_prev_entry (rp_current_screen, &rp_screens, node);
}

static void
screen_remove_current (void)
{
  rp_screen *new_screen;
  rp_frame *new_frame;
  rp_window *cur_win;
  int cur_frame;

  cur_win = current_window ();
  new_screen = screen_next ();

  cur_frame = new_screen->current_frame;
  new_frame = screen_get_frame (new_screen, cur_frame);

  set_active_frame (new_frame, 1);

  hide_window (cur_win);
}

void
screen_update (rp_screen *s, int left, int top, int width, int height)
{
  rp_frame *f;
  int oldwidth, oldheight;

  PRINT_DEBUG (("screen_update (left=%d, top=%d, width=%d, height=%d)\n",
                left, top, width, height));

  if (s->width  == width  &&
      s->height == height &&
      s->left   == left   &&
      s->top    == top)
    /* nothing to do */
    return;

  oldwidth = s->width;
  oldheight = s->height;

  s->left = left;
  s->top = top;
  s->width = width;
  s->height = height;

  XMoveResizeWindow (dpy, s->help_window, s->left, s->top, s->width, s->height);

  list_for_each_entry (f, &s->frames, node)
    {
      f->x = (f->x*width)/oldwidth;
      f->width = (f->width*width)/oldwidth;
      f->y = (f->y*height)/oldheight;
      f->height = (f->height*height)/oldheight;
      maximize_all_windows_in_frame (f);
    }
}

rp_screen *
screen_add (int rr_output)
{
  rp_screen *screen;

  screen = xmalloc (sizeof(*screen));
  list_add (&screen->node, &rp_screens);

  screen->number = numset_request (rp_glob_screen.numset);

  xrandr_fill_screen (rr_output, screen);
  init_screen (screen);
  init_frame_list (screen);

  if (screen_count () == 1)
    {
      rp_current_screen = screen;
      change_windows_screen (NULL, rp_current_screen);
      set_window_focus (rp_current_screen->key_window);
    }

  return screen;
}

void
screen_del (rp_screen *s)
{
  if (s == rp_current_screen)
    {
      if (screen_count () == 1)
        {
          hide_screen_windows (s);
          rp_current_screen = NULL;
        }
      else
        {
          /*
           * The deleted screen cannot be the current screen anymore,
           * focus the next one.
           */
          screen_remove_current ();
        }
    }
  else
    {
      hide_screen_windows (s);
    }

  /* Affect window's screen backpointer to the new current screen */
  change_windows_screen (s, rp_current_screen);

  numset_release (rp_glob_screen.numset, s->number);

  screen_free (s);

  list_del (&s->node);
  free (s);
}

void
screen_free (rp_screen *s)
{
  rp_frame *frame;
  struct list_head *iter, *tmp;

  list_for_each_safe_entry (frame, iter, tmp, &s->frames, node)
    {
      frame_free (s, frame);
    }

  deactivate_screen(s);

  XDestroyWindow (dpy, s->bar_window);
  XDestroyWindow (dpy, s->key_window);
  XDestroyWindow (dpy, s->input_window);
  XDestroyWindow (dpy, s->frame_window);
  XDestroyWindow (dpy, s->help_window);

#ifdef USE_XFT_FONT
  if (s->xft_font)
    {
      XftColorFree (dpy, DefaultVisual (dpy, s->screen_num),
                    DefaultColormap (dpy, s->screen_num), &s->xft_fg_color);
      XftColorFree (dpy, DefaultVisual (dpy, s->screen_num),
                    DefaultColormap (dpy, s->screen_num), &s->xft_bg_color);
      XftFontClose (dpy, s->xft_font);
    }
#endif

  XFreeCursor (dpy, s->rat);
  XFreeColormap (dpy, s->def_cmap);
  XFreeGC (dpy, s->normal_gc);
  XFreeGC (dpy, s->inverse_gc);

  free (s->display_string);
  free (s->xrandr.name);
}

void
screen_free_final (void)
{
  /* Relinquish our hold on the root window. */
  XSelectInput(dpy, RootWindow (dpy, DefaultScreen (dpy)), 0);

  numset_free (rp_glob_screen.numset);
}



================================================
FILE: src/screen.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef SCREEN_H
#define SCREEN_H

int screen_bottom (rp_screen *s);
int screen_top (rp_screen *s);
int screen_right (rp_screen *s);
int screen_left (rp_screen *s);
int screen_height (rp_screen *s);
int screen_width (rp_screen *s);

struct list_head *screen_copy_frameset (rp_screen *s);
void screen_restore_frameset (rp_screen *s, struct list_head *head);
void screen_free_nums (rp_screen *s);
void frameset_free (struct list_head *head);
rp_frame *screen_get_frame (rp_screen *s, int frame_num);
rp_frame *screen_find_frame_by_frame (rp_screen *s, rp_frame *f);

rp_screen *find_screen (Window w);
rp_screen *find_screen_by_attr (XWindowAttributes w);

void init_screens (void);
void activate_screen (rp_screen *s);
void deactivate_screen (rp_screen *s);

int is_rp_window (Window w);
int is_a_root_window (unsigned int w);

char *screen_dump (rp_screen *screen);

void screen_update (rp_screen *s, int left, int top, int width, int height);

int screen_count (void);

rp_screen *screen_next(void);
rp_screen *screen_prev(void);

rp_screen *screen_number (int number);

void screen_sort(void);

rp_screen *screen_add(int rr_output);
void screen_del(rp_screen *s);
void screen_free (rp_screen *s);
void screen_free_final(void);

#endif



================================================
FILE: src/split.c
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 *
 *
 * Functions for handling window splitting and tiling.
 */

#include <unistd.h>
#include <string.h>

#include "ratpoison.h"

#define VERTICALLY 0
#define HORIZONTALLY 1

static void
update_last_access (rp_frame *frame)
{
  static int counter = 0;

  frame->last_access = counter;
  counter++;
}

rp_frame *
current_frame (void)
{
  rp_screen *s = rp_current_screen;
  return screen_get_frame (s, s->current_frame);
}

void
cleanup_frame (rp_frame *frame)
{
  rp_window *win;
  rp_screen *screen;
  screen = frames_screen(frame);

  win = find_window_other (screen);
  if (win == NULL)
    {
      set_frames_window (frame, NULL);
      return;
    }

  set_frames_window (frame, win);

  maximize (win);
  unhide_window (win);


  if (!window_is_transient (win))
    hide_others (win);
}

rp_window *
set_frames_window (rp_frame *frame, rp_window *win)
{
  int last_win;

  last_win = frame->win_number;
  if (win)
    {
      frame->win_number = win->number;
      win->frame_number = frame->number;

      /* We need to make sure that win and frame are on the same screen,
       * since with Xrandr, windows can move from one screen to another.
       */
      win->scr = frames_screen(frame);
    }
  else
    {
      frame->win_number = EMPTY;
    }

  return find_window_number (last_win);
}

rp_screen *
frames_screen (rp_frame *frame)
{
  rp_frame *cur_frame;
  rp_screen *cur_screen;

  list_for_each_entry (cur_screen, &rp_screens, node)
    {
      list_for_each_entry (cur_frame, &cur_screen->frames, node)
        {
          if (frame == cur_frame)
            return cur_screen;
        }
    }

  /* This SHOULD be impossible to get to. FIXME: It'll crash higher up if we
     return NULL. */
  return NULL;
}

void
maximize_all_windows_in_frame (rp_frame *frame)
{
  rp_window *win;

  list_for_each_entry (win, &rp_mapped_window, node)
    {
      if (win->frame_number == frame->number)
        {
          maximize (win);
        }
    }
}

/* Make the frame occupy the entire screen */
static void
maximize_frame (rp_frame *frame)
{
  rp_screen *s = frames_screen (frame);

  frame->x = defaults.padding_left;
  frame->y = defaults.padding_top;

  frame->width = screen_width (s);
  frame->height = screen_height (s);
}

/* Create a full screen frame */
static void
create_initial_frame (rp_screen *screen)
{
  rp_frame *frame;

  frame = frame_new (screen);
  screen->current_frame = frame->number;
  list_add_tail (&frame->node, &screen->frames);

  update_last_access (frame);

  maximize_frame (frame);
  set_frames_window (frame, NULL);
}

void
init_frame_lists (void)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      init_frame_list (cur);
    }
}

void
init_frame_list (rp_screen *screen)
{
  INIT_LIST_HEAD (&screen->frames);

  create_initial_frame(screen);
}

rp_frame *
find_last_frame (void)
{
  rp_frame *cur_frame, *last = NULL;
  rp_screen *cur_screen;
  int last_access = -1;

  list_for_each_entry (cur_screen, &rp_screens, node)
    {
      list_for_each_entry (cur_frame, &cur_screen->frames, node)
        {
          if (cur_frame->number != rp_current_screen->current_frame &&
              cur_frame->last_access > last_access)
            {
              last_access = cur_frame->last_access;
              last = cur_frame;
            }
        }
    }

  return last;
}

/* Return the frame that contains the window. */
rp_frame *
find_windows_frame (rp_window *win)
{
  rp_screen *s;
  rp_frame *cur;

  s = win->scr;

  list_for_each_entry (cur, &s->frames, node)
    {
      if (cur->win_number == win->number) return cur;
    }

  return NULL;
}

int
num_frames (rp_screen *s)
{
  return list_size (&s->frames);
}

rp_frame *
find_frame_next (rp_frame *frame)
{
  if (frame == NULL) return NULL;
  return list_next_entry (frame, &frames_screen (frame)->frames, node);
}

rp_frame *
find_frame_prev (rp_frame *frame)
{
  if (frame == NULL) return NULL;
  return list_prev_entry (frame, &frames_screen (frame)->frames, node);
}

rp_window *
current_window (void)
{
  return find_window_number (current_frame()->win_number);
}

static int
window_fits_in_frame (rp_window *win, rp_frame *frame)
{
  /* If the window has minimum size hints, make sure they are smaller
     than the frame. */
  if (win->hints->flags & PMinSize)
    {
      if (win->hints->min_width > frame->width
          ||
          win->hints->min_height > frame->height)
        {
          return 0;
        }
    }

  return 1;
}

/* Search the list of mapped windows for a window that will fit in the
   specified frame. */
rp_window *
find_window_for_frame (rp_frame *frame)
{
  rp_screen *s = frames_screen (frame);
  int last_access = 0;
  rp_window_elem *most_recent = NULL;
  rp_window_elem *cur;

  list_for_each_entry (cur, &rp_current_group->mapped_windows, node)
    {
      if ((cur->win->scr == s || rp_have_xrandr)
          && cur->win != current_window()
          && !find_windows_frame (cur->win)
          && cur->win->last_access >= last_access
          && window_fits_in_frame (cur->win, frame)
          && cur->win->frame_number == EMPTY)
        {
          most_recent = cur;
          last_access = cur->win->last_access;
        }
    }

  if (most_recent)
    return most_recent->win;

  return NULL;
}

/* Splits the frame in 2. if way is 0 then split vertically otherwise
   split it horizontally. */
static void
split_frame (rp_frame *frame, int way, int pixels)
{
  rp_screen *s;
  rp_window *win;
  rp_frame *new_frame;

  s = frames_screen (frame);

  /* Make our new frame. */
  new_frame = frame_new (s);

  /* Add the frame to the frameset. */
  list_add (&new_frame->node, &current_frame()->node);

  set_frames_window (new_frame, NULL);

  if (way == HORIZONTALLY)
    {
      new_frame->x = frame->x;
      new_frame->y = frame->y + pixels;
      new_frame->width = frame->width;
      new_frame->height = frame->height - pixels;

      frame->height = pixels;
    }
  else
    {
      new_frame->x = frame->x + pixels;
      new_frame->y = frame->y;
      new_frame->width = frame->width - pixels;
      new_frame->height = frame->height;

      frame->width = pixels;
    }

  win = find_window_for_frame (new_frame);
  if (win)
    {
      PRINT_DEBUG (("Found a window for the frame!\n"));

      set_frames_window (new_frame, win);

      maximize (win);
      unhide_window (win);
      XRaiseWindow (dpy, win->w);
    }
  else
    {
      PRINT_DEBUG (("No window fits the frame.\n"));

      set_frames_window (new_frame, NULL);
    }

  /* resize the existing frame */
  if (frame->win_number != EMPTY)
    {
      maximize_all_windows_in_frame (frame);
      XRaiseWindow (dpy, find_window_number (frame->win_number)->w);
    }

  update_bar (s);
  show_frame_indicator(0);
}

/* Splits the window vertically leaving the original with 'pixels'
   pixels . */
void
v_split_frame (rp_frame *frame, int pixels)
{
  split_frame (frame, VERTICALLY, pixels);
}

/* Splits the frame horizontally leaving the original with 'pixels'
   pixels . */
void
h_split_frame (rp_frame *frame, int pixels)
{
  split_frame (frame, HORIZONTALLY, pixels);
}

void
remove_all_splits (void)
{
  struct list_head *tmp, *iter;
  rp_screen *s = rp_current_screen;
  rp_frame *frame;
  rp_window *win;

  /* Hide all the windows not in the current frame. */
  list_for_each_entry (win, &rp_mapped_window, node)
    {
      if (win->frame_number != s->current_frame && win->scr == s)
        hide_window (win);
    }

  /* Delete all the frames except the current one. */
  list_for_each_safe_entry (frame, iter, tmp, &s->frames, node)
    {
      if (frame->number != s->current_frame)
        {
          list_del (&frame->node);
          frame_free (s, frame);
        }
    }

  /* Maximize the frame and the windows in the frame. */
  maximize_frame (current_frame());
  maximize_all_windows_in_frame (current_frame());
}

/* Shrink the size of the frame to fit it's current window. */
void
resize_shrink_to_window (rp_frame *frame)
{
  rp_window *win;

  if (frame->win_number == EMPTY) return;

  win = find_window_number (frame->win_number);

  resize_frame_horizontally (frame, win->width + win->border*2 - frame->width);
  resize_frame_vertically (frame, win->height + win->border*2 - frame->height);
}

/* resize_frame is a generic frame resizer that can resize vertically,
   horizontally, to the right, to the left, etc. It all depends on the
   functions passed to it. Returns -1 if the resize failed, 0 for
   success. */
static int
resize_frame (rp_frame *frame, rp_frame *pusher, int diff,
              int (*c1)(rp_frame *), int (c2)(rp_frame *),
              int (*c3)(rp_frame *), int (c4)(rp_frame *),
              void (*resize1)(rp_frame *, int),
              void (*resize2)(rp_frame *, int),
              int (*resize3)(rp_frame *, rp_frame *, int))
{
  rp_screen *s = frames_screen (frame);
  rp_frame *cur;

  /* Loop through the frames and determine which ones are affected by
     resizing frame. */
  list_for_each_entry (cur, &s->frames, node)
    {
      if (cur == frame || cur == pusher) continue;
      /* If cur is touching frame along the axis that is being
         moved then this frame is affected by the resize. */
      if ((*c1)(cur) == (*c3)(frame))
        {
          /* If the frame can't get any smaller, then fail. */
          if (diff > 0
              && abs ((*c3)(cur) - (*c1)(cur)) - diff <= defaults.window_border_width * 2)
            return -1;
          /* Test for this circumstance:
             --+
             | |+-+
             |f||c|
             | |+-+
             --+

             In this case, resizing cur will not affect any other
             frames, so just do the resize.
          */
          if (((*c2)(cur) >= (*c2)(frame))
              && (*c4)(cur) <= (*c4)(frame))
            {
              (*resize2)(cur, -diff);
              maximize_all_windows_in_frame (cur);
            }
          /* Otherwise, cur's corners are either strictly outside
             frame's corners, or one of them is inside and the other
             isn't. In either of these cases, resizing cur will affect
             other adjacent frames, so find them and resize them first
             (recursive step) and then resize cur. */
          else if (((*c2)(cur) < (*c2)(frame)
                    && (*c4)(cur) > (*c4)(frame))
                   || ((*c2)(cur) >= (*c2)(frame)
                       && (*c2)(cur) < (*c4)(frame))
                   || ((*c4)(cur) > (*c2)(frame)
                       && (*c4)(cur) <= (*c4)(frame)))
            {
              /* Attempt to resize cur. */
              if (resize3 (cur, frame, -diff) == -1)
                return -1;
            }
        }
    }

  /* Finally, resize the frame and the windows inside. */
  (*resize1) (frame, diff);
  maximize_all_windows_in_frame (frame);

  return 0;
}

static int resize_frame_bottom (rp_frame *frame, rp_frame *pusher, int diff);
static int resize_frame_top (rp_frame *frame, rp_frame *pusher, int diff);
static int resize_frame_left (rp_frame *frame, rp_frame *pusher, int diff);
static int resize_frame_right (rp_frame *frame, rp_frame *pusher, int diff);

/* Resize frame by moving it's right side. */
static int
resize_frame_right (rp_frame *frame, rp_frame *pusher, int diff)
{
  return resize_frame (frame, pusher, diff,
                       frame_left, frame_top, frame_right, frame_bottom,
                       frame_resize_right, frame_resize_left, resize_frame_left);
}

/* Resize frame by moving it's left side. */
static int
resize_frame_left (rp_frame *frame, rp_frame *pusher, int diff)
{
  return resize_frame (frame, pusher, diff,
                       frame_right, frame_top, frame_left, frame_bottom,
                       frame_resize_left, frame_resize_right, resize_frame_right);
}

/* Resize frame by moving it's top side. */
static int
resize_frame_top (rp_frame *frame, rp_frame *pusher, int diff)
{
  return resize_frame (frame, pusher, diff,
                       frame_bottom, frame_left, frame_top, frame_right,
                       frame_resize_up, frame_resize_down, resize_frame_bottom);
}

/* Resize frame by moving it's bottom side. */
static int
resize_frame_bottom (rp_frame *frame, rp_frame *pusher, int diff)
{
  return resize_frame (frame, pusher, diff,
                       frame_top, frame_left, frame_bottom, frame_right,
                       frame_resize_down, frame_resize_up, resize_frame_top);
}

/* Resize frame diff pixels by expanding it to the right. If the frame
   is against the right side of the screen, expand it to the left. */
void
resize_frame_horizontally (rp_frame *frame, int diff)
{
  int (*resize_fn)(rp_frame *, rp_frame*, int);
  struct list_head *l;
  rp_screen *s = frames_screen (frame);

  if (num_frames (s) < 2 || diff == 0)
    return;

  if (frame_width (frame) + diff <= defaults.window_border_width * 2)
    return;

  /* Find out which resize function to use. */
  if (frame_right (frame) < screen_right (s))
    {
      resize_fn = resize_frame_right;
    }
  else if (frame_left (frame) > screen_left (s))
    {
      resize_fn = resize_frame_left;
    }
  else
    {
      return;
    }

  /* Copy the frameset. If the resize fails, then we restore the
     original one. */
  l = screen_copy_frameset (s);

  if ((*resize_fn) (frame, NULL, diff) == -1)
    {
      screen_restore_frameset (s, l);
    }
  else
    {
      frameset_free (l);
    }

  /* It's our responsibility to free this. */
  free (l);
}

/* Resize frame diff pixels by expanding it down. If the frame is
   against the bottom of the screen, expand it up. */
void
resize_frame_vertically (rp_frame *frame, int diff)
{
  int (*resize_fn)(rp_frame *, rp_frame*, int);
  struct list_head *l;
  rp_screen *s = frames_screen (frame);

  if (num_frames (s) < 2 || diff == 0)
    return;

  if (frame_height (frame) + diff <= defaults.window_border_width * 2)
    return;

  /* Find out which resize function to use. */
  if (frame_bottom (frame) < screen_bottom (s))
    {
      resize_fn = resize_frame_bottom;
    }
  else if (frame_top (frame) > screen_top (s))
    {
      resize_fn = resize_frame_top;
    }
  else
    {
      return;
    }

  /* Copy the frameset. If the resize fails, then we restore the
     original one. */
  l = screen_copy_frameset (s);

  if ((*resize_fn) (frame, NULL, diff) == -1)
    {
      screen_restore_frameset (s, l);
    }
  else
    {
      frameset_free (l);
    }

  /* It's our responsibility to free this. */
  free (l);
}

static int
frame_is_below (rp_frame *src, rp_frame *frame)
{
  if (frame->y > src->y) return 1;
  return 0;
}

static int
frame_is_above (rp_frame *src, rp_frame *frame)
{
  if (frame->y < src->y) return 1;
  return 0;
}

static int
frame_is_left (rp_frame *src, rp_frame *frame)
{
  if (frame->x < src->x) return 1;
  return 0;
}

static int
frame_is_right (rp_frame *src, rp_frame *frame)
{
  if (frame->x > src->x) return 1;
  return 0;
}

static int
total_frame_area (rp_screen *s)
{
  int area = 0;
  rp_frame *cur;

  list_for_each_entry (cur, &s->frames, node)
    {
      area += cur->width * cur->height;
    }

  return area;
}

/* Return 1 if frames f1 and f2 overlap */
static int
frames_overlap (rp_frame *f1, rp_frame *f2)
{
  if (f1->x >= f2->x + f2->width
      || f1->y >= f2->y + f2->height
      || f2->x >= f1->x + f1->width
      || f2->y >= f1->y + f1->height)
    {
      return 0;
    }
  return 1;
}

/* Return 1 if w's frame overlaps any other window's frame */
static int
frame_overlaps (rp_frame *frame)
{
  rp_screen *s;
  rp_frame *cur;

  s = frames_screen (frame);

  list_for_each_entry (cur, &s->frames, node)
    {
      if (cur != frame && frames_overlap (cur, frame))
        {
          return 1;
        }
    }
  return 0;
}

void
remove_frame (rp_frame *frame)
{
  rp_screen *s;
  int area;
  rp_frame *cur;
  rp_window *win;

  if (frame == NULL) return;

  s = frames_screen (frame);

  area = total_frame_area(s);
  PRINT_DEBUG (("Total Area: %d\n", area));

  list_del (&frame->node);
  win = find_window_number (frame->win_number);
  hide_window (win);
  hide_others (win);

  list_for_each_entry (cur, &s->frames, node)
    {
      rp_frame tmp_frame;
      int fits = 0;

/*       if (cur->win_number != EMPTY) */
/*      { */
/*        PRINT_DEBUG (("Trying frame containing window '%s'\n", window_name (cur->win))); */
/*      } */
/*       else */
/*      { */
/*        PRINT_DEBUG (("Trying some empty frame\n")); */
/*      } */

      /* Backup the frame */
      memcpy (&tmp_frame, cur, sizeof (rp_frame));

      if (frame_is_below (frame, cur)
          || frame_is_above (frame, cur))
        {
          if (frame_is_below (frame, cur))
            cur->y = frame->y;
          cur->height += frame->height;
        }

      PRINT_DEBUG (("Attempting vertical Frame y=%d height=%d\n", cur->y, cur->height));
      PRINT_DEBUG (("New Total Area: %d\n", total_frame_area(s)));

      /* If the area is bigger than before, the frame takes up too
         much space. If the current frame and the deleted frame DON'T
         overlap then the current window took up just the right amount
         of space but didn't take up the space left behind by the
         deleted window. If any active frames overlap, it could have
         taken up the right amount of space, overlaps with the deleted
         frame but obviously didn't fit. */
      if (total_frame_area(s) > area || !frames_overlap (cur, frame) || frame_overlaps (cur))
        {
          PRINT_DEBUG (("Didn't fit vertically\n"));

          /* Restore the current window's frame */
          memcpy (cur, &tmp_frame, sizeof (rp_frame));
        }
      else
        {
          PRINT_DEBUG (("It fit vertically!!\n"));

          /* update the frame backup */
          memcpy (&tmp_frame, cur, sizeof (rp_frame));
          fits = 1;
        }

      if (frame_is_left (frame, cur)
          || frame_is_right (frame, cur))
        {
          if (frame_is_right (frame, cur))
            cur->x = frame->x;
          cur->width += frame->width;
        }

      PRINT_DEBUG (("Attempting horizontal Frame x=%d width=%d\n", cur->x, cur->width));
      PRINT_DEBUG (("New Total Area: %d\n", total_frame_area(s)));

      /* Same test as the vertical test, above. */
      if (total_frame_area(s) > area || !frames_overlap (cur, frame) || frame_overlaps (cur))
        {
          PRINT_DEBUG (("Didn't fit horizontally\n"));

          /* Restore the current window's frame */
          memcpy (cur, &tmp_frame, sizeof (rp_frame));
        }
      else
        {
          PRINT_DEBUG (("It fit horizontally!!\n"));
          fits = 1;
        }

      if (fits)
        {
          /* The current frame fits into the new space so keep its
             new frame parameters and maximize the window to fit
             the new frame size. */
          if (cur->win_number != EMPTY)
            {
              rp_window *new = find_window_number (cur->win_number);
              maximize_all_windows_in_frame (cur);
              XRaiseWindow (dpy, new->w);
            }
        }
      else
        {
          memcpy (cur, &tmp_frame, sizeof (rp_frame));
        }
    }

  frame_free (s, frame);
}

/* Switch the input focus to another frame, and therefore a different
   window. */
void
set_active_frame (rp_frame *frame, int force_indicator)
{
  rp_screen *old_s = rp_current_screen;
  rp_screen *s = frames_screen (frame);
  int old = rp_current_screen->current_frame;
  rp_window *win, *old_win;
  rp_frame *old_frame;

  win = find_window_number (frame->win_number);
  old_frame = current_frame();
  if (old_frame)
    {
      old_win = find_window_number (old_frame->win_number);
    }
  else
    {
      old_win = NULL;
    }

  /* Make the switch */
  give_window_focus (win, old_win);
  update_last_access (frame);
  s->current_frame = frame->number;

  /* If frame->win == NULL, then rp_current_screen is not updated. */
  rp_current_screen = s;

  update_bar (s);

  /* Possibly show the frame indicator. */
  if ((old != s->current_frame && num_frames(s) > 1)
      || s != old_s)
    {
      if (s != old_s)
        force_indicator = 1;

      show_frame_indicator(force_indicator);

      /* run the frame switch hook. We call it in here because this is
         when a frame switch ACTUALLY (for sure) happens. */
      hook_run (&rp_switch_frame_hook);
    }

  /* If the frame has no window to give focus to, give the key window
     focus. */
  if(frame->win_number == EMPTY)
    {
      set_window_focus (s->key_window);
    }

  /* Call the switchscreen hook, when appropriate. */
  if (s != old_s)
    hook_run (&rp_switch_screen_hook);
}

void
exchange_with_frame (rp_frame *cur, rp_frame *frame)
{
  rp_window *win,*last_win;

  if (frame == NULL || frame == cur) return;

  /* Exchange the windows in the frames */
  win = find_window_number (cur->win_number);
  last_win = set_frames_window (frame, win);
  set_frames_window (cur, last_win);

  /* Make sure the windows comes up full screen */
  if (last_win)
    maximize (last_win);
  if (win)
    {
    maximize (win);
    /* Make sure the program bar is always on the top */
    update_window_names (win->scr, defaults.window_fmt);
  }

  /* Make the switch */
  update_last_access (frame);

  set_active_frame(frame, 0);
}


void
blank_frame (rp_frame *frame)
{
  rp_screen *s;
  rp_window *win;

  if (frame->win_number == EMPTY) return;

  s = frames_screen (frame);

  win = find_window_number (frame->win_number);
  hide_window (win);
  hide_others (win);

  set_frames_window (frame, NULL);

  update_bar (s);

  /* Give the key window focus. */
  set_window_focus (frames_screen(frame)->key_window);
}

void
hide_frame_indicator (void)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
    XUnmapWindow (dpy, cur->frame_window);
    }
}

void
show_frame_indicator (int force)
{
  if (num_frames (rp_current_screen) > 1 || force)
    {
      hide_frame_indicator ();
      if (defaults.frame_indicator_timeout != -1)
        {
          show_frame_message (defaults.frame_fmt);
          alarm (defaults.frame_indicator_timeout);
        }
    }
}

void
show_frame_message (char *msg)
{
  rp_screen *s = rp_current_screen;
  int width, height;
  rp_frame *frame;
  rp_window *win;
  rp_window_elem *elem = NULL;
  struct sbuf *msgbuf;

  frame = current_frame();
  win = current_window ();
  if (win)
    {
      rp_group *g;

      g = groups_find_group_by_window (win);
      elem = group_find_window (&g->mapped_windows, win);
    }

  /* A frame doesn't always contain a window. */
  msgbuf = sbuf_new (0);
  if (elem)
    format_string (msg, elem, msgbuf);
  else
    {
      sbuf_concat (msgbuf, EMPTY_FRAME_MESSAGE);
    }

  width = defaults.bar_x_padding * 2
    + rp_text_width (s, msgbuf->data, msgbuf->len);
  height = (FONT_HEIGHT (s) + defaults.bar_y_padding * 2);

  /* We don't want another frame indicator to be displayed on another
   * screen at the same time, so we hide it before bringing it back again.
   */
  hide_frame_indicator ();

  XMoveResizeWindow (dpy, s->frame_window,
                     s->left + frame->x + frame->width / 2 - width / 2,
                     s->top + frame->y + frame->height / 2 - height / 2,
                     width, height);

  XMapRaised (dpy, s->frame_window);
  XClearWindow (dpy, s->frame_window);
  XSync (dpy, False);

  rp_draw_string (s, s->frame_window, STYLE_NORMAL,
                  defaults.bar_x_padding,
                  defaults.bar_y_padding + FONT_ASCENT(s),
                  msgbuf->data, msgbuf->len);

  sbuf_free (msgbuf);
}

static int
frames_overlap_horizontal (rp_frame *f1, rp_frame *f2)
{
  int f1_right = frame_right_abs (f1);
  int f2_right = frame_right_abs (f2);
  int f1_left = frame_left_abs (f1);
  int f2_left = frame_left_abs (f2);

  return f1_left < f2_right && f2_left < f1_right;
}

static int
frames_overlap_vertical (rp_frame *f1, rp_frame *f2)
{
  int f1_bottom = frame_bottom_abs (f1);
  int f2_bottom = frame_bottom_abs (f2);
  int f1_top = frame_top_abs (f1);
  int f2_top = frame_top_abs (f2);

  return f1_top < f2_bottom && f2_top < f1_bottom;
}

rp_frame *
find_frame_up (rp_frame *frame)
{
  rp_screen *s;
  rp_frame *cur;

  list_for_each_entry (s, &rp_screens, node)
    {
      list_for_each_entry (cur, &s->frames, node)
        {
          if (frame_top_abs (frame) == frame_bottom_abs (cur))
            if (frames_overlap_horizontal (frame, cur))
              return cur;
        }
    }

  return NULL;
}

rp_frame *
find_frame_down (rp_frame *frame)
{
  rp_screen *s;
  rp_frame *cur;

  list_for_each_entry (s, &rp_screens, node)
    {
      list_for_each_entry (cur, &s->frames, node)
        {
          if (frame_bottom_abs (frame) == frame_top_abs (cur))
            if (frames_overlap_horizontal (frame, cur))
              return cur;
        }
    }

  return NULL;
}

rp_frame *
find_frame_left (rp_frame *frame)
{
  rp_screen *s;
  rp_frame *cur;

  list_for_each_entry (s, &rp_screens, node)
    {
      list_for_each_entry (cur, &s->frames, node)
        {
          if (frame_left_abs (frame) == frame_right_abs (cur))
            if (frames_overlap_vertical (frame, cur))
              return cur;
        }
    }

  return NULL;
}

rp_frame *
find_frame_right (rp_frame *frame)
{
  rp_screen *s;
  rp_frame *cur;

  list_for_each_entry (s, &rp_screens, node)
    {
      list_for_each_entry (cur, &s->frames, node)
        {
          if (frame_right_abs (frame) == frame_left_abs (cur))
            if (frames_overlap_vertical (frame, cur))
              return cur;
        }
    }

  return NULL;
}

rp_frame *
find_frame_number (int num)
{
  rp_frame *cur_frame;
  rp_screen *cur_screen;

  list_for_each_entry (cur_screen, &rp_screens, node)
    {
      list_for_each_entry (cur_frame, &cur_screen->frames, node)
        {
          if (cur_frame->number == num)
            return cur_frame;
        }
    }

  return NULL;
}



================================================
FILE: src/split.h
================================================
/* Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 *
 */

#ifndef SPLIT_H
#define SPLIT_H

rp_window *set_frames_window (rp_frame *frame, rp_window *win);
void cleanup_frame (rp_frame *frame);
void maximize_all_windows_in_frame (rp_frame *frame);
void h_split_frame (rp_frame *frame, int pixels);
void v_split_frame (rp_frame *frame, int pixels);
void remove_all_splits (void);
void resize_shrink_to_window (rp_frame *frame);
void resize_frame_horizontally (rp_frame *frame, int diff);
void resize_frame_vertically (rp_frame *frame, int diff);
void remove_frame (rp_frame *frame);
rp_window *find_window_for_frame (rp_frame *frame);
rp_frame *find_windows_frame (rp_window *win);
int num_frames (rp_screen *s);
rp_frame *find_frame_next (rp_frame *frame);
rp_frame *find_frame_prev (rp_frame *frame);
rp_window *current_window (void);
void init_frame_lists (void);
void init_frame_list (rp_screen *screen);
void set_active_frame (rp_frame *frame, int force_indicator);
void exchange_with_frame (rp_frame *cur, rp_frame *frame);
void blank_frame (rp_frame *frame);
void show_frame_indicator (int force);
void hide_frame_indicator (void);

void show_frame_message (char *msg);

rp_frame *find_frame_right (rp_frame *frame);
rp_frame *find_frame_left (rp_frame *frame);
rp_frame *find_frame_down (rp_frame *frame);
rp_frame *find_frame_up (rp_frame *frame);
rp_frame *find_last_frame (void);
rp_frame * find_frame_number (int num);

rp_frame *current_frame (void);

#endif



================================================
FILE: src/test-sbuf-utf8-nconcat.c
================================================
/*
 * Copyright (C) 2017 Will Storey <will@summercat.com>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "ratpoison.h"

#include <assert.h>
#include <locale.h>

void test_sbuf_utf8_nconcat(void);

int main(void)
{
  utf8_locale = 1;

  test_sbuf_utf8_nconcat();
  return 0;
}

void
test_sbuf_utf8_nconcat(void)
{
  struct sbuf *buf = NULL;

  /* Zero length string, no limit. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "", -1);
  assert(strcmp(sbuf_get(buf), "") == 0);
  sbuf_free(buf);

  /* Zero length string, non-zero limit. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "", 5);
  assert(strcmp(sbuf_get(buf), "") == 0);
  sbuf_free(buf);

  /* ASCII string, no limit. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "hi there", -1);
  assert(strcmp(sbuf_get(buf), "hi there") == 0);
  sbuf_utf8_nconcat(buf, " you", -1);
  assert(strcmp(sbuf_get(buf), "hi there you") == 0);
  sbuf_free(buf);

  /* ASCII string, non-zero limit, truncated. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "hi there", 4);
  assert(strcmp(sbuf_get(buf), "hi t") == 0);
  sbuf_free(buf);

  /* ASCII string, non-zero limit, not truncated. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "hi", 4);
  assert(strcmp(sbuf_get(buf), "hi") == 0);
  sbuf_free(buf);

  /* UTF-8 string, no limit. */

  buf = sbuf_new(0);
  /* 0xe2 0x84 0xa2 is U+2122, the trademark symbol. */
  sbuf_utf8_nconcat(buf, "hi \xe2\x84\xa2 there", -1);
  assert(strcmp(sbuf_get(buf), "hi \xe2\x84\xa2 there") == 0);
  sbuf_free(buf);

  /* UTF-8 string, non-zero limit, truncated at an okay spot counting either
     by bytes or by characters. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "hi \xe2\x84\xa2 there you", 11);
  assert(strcmp(sbuf_get(buf), "hi \xe2\x84\xa2 there ") == 0);
  sbuf_free(buf);

  /* UTF-8 string, non-zero limit, truncated such that if the limit were in
     bytes that we would cut in the middle of a character. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "hi \xe2\x84\xa2 there you", 5);
  assert(strcmp(sbuf_get(buf), "hi \xe2\x84\xa2 ") == 0);
  sbuf_free(buf);

  /* UTF-8 string, non-zero limit, not truncated. */

  buf = sbuf_new(0);
  sbuf_utf8_nconcat(buf, "hi \xe2\x84\xa2 there you", 20);
  assert(strcmp(sbuf_get(buf), "hi \xe2\x84\xa2 there you") == 0);
  sbuf_free(buf);

  /* Invalid character. */

  buf = sbuf_new(0);
  /* This is an invalid UTF-8 sequence. It's missing 0xa2. */
  sbuf_utf8_nconcat(buf, "hi \xe2\x84 there you", 20);
  assert(strcmp(sbuf_get(buf), "hi \xe2\x84 there you") == 0);
  sbuf_free(buf);
}



================================================
FILE: src/utf8.c
================================================
/*
 * Copyright (C) 2017  Jeremie Courreges-Anglas <jca@wxcvcbn.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

#include "ratpoison.h"

#ifdef HAVE_LANGINFO_CODESET
# include <langinfo.h>
#endif

int utf8_locale;

int
utf8_check_locale(void)
{
#ifdef HAVE_LANGINFO_CODESET
  utf8_locale = !strcmp (nl_langinfo (CODESET), "UTF-8");
#endif
  return utf8_locale;
}

int
isu8char(char c)
{
  return utf8_locale && (c) & 0xC0;
}

int
isu8start(char c)
{
  return utf8_locale && ((c) & 0xC0) == 0xC0;
}

int
isu8cont(char c)
{
  return utf8_locale && ((c) & 0xC0) == 0x80;
}



================================================
FILE: src/utf8.h
================================================
#ifndef UTF8_H
#define UTF8_H

extern int isu8char(char c);
extern int isu8start(char c);
extern int isu8cont(char c);

extern int utf8_locale;

int utf8_check_locale(void);

#endif



================================================
FILE: src/util.c
================================================
/* Ratpoison.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "ratpoison.h"

#include <ctype.h>

void
fatal (const char *msg)
{
  fprintf (stderr, "ratpoison: %s", msg);
  abort ();
}

void *
xmalloc (size_t size)
{
  void *value;

  value = malloc (size);
  if (value == NULL)
    fatal ("Virtual memory exhausted");
  return value;
}

void *
xrealloc (void *ptr, size_t size)
{
  void *value;

  value = realloc (ptr, size);
  if (value == NULL)
    fatal ("Virtual memory exhausted");
  return value;
}

char *
xstrdup (const char *s)
{
  char *value;
  value = strdup (s);
  if (value == NULL)
    fatal ("Virtual memory exhausted");
  return value;
}

/* Return a new string based on fmt. */
char *
xvsprintf (char *fmt, va_list ap)
{
  int size, nchars;
  char *buffer;
  va_list ap_copy;

  /* A reasonable starting value. */
  size = strlen (fmt) + 1;
  buffer = xmalloc (size);

  while (1)
    {
#if defined(va_copy)
      va_copy (ap_copy, ap);
#elif defined(__va_copy)
      __va_copy (ap_copy, ap);
#else
      /* If there is no copy macro then this MAY work. On some systems
         this could fail because va_list is a pointer so assigning one
         to the other as below wouldn't make a copy of the data, but
         just the pointer to the data. */
      ap_copy = ap;
#endif
      nchars = vsnprintf (buffer, size, fmt, ap_copy);
#if defined(va_copy) || defined(__va_copy)
      va_end (ap_copy);
#endif

      if (nchars > -1 && nchars < size)
        return buffer;
      else if (nchars > -1)
        size = nchars + 1;
      /* c99 says -1 is an error other than truncation,
       * which thus will not go away with a larger buffer.
       * To support older system but not making errors fatal
       * (ratpoison will abort when trying to get too much memory otherwise),
       * try to increase a bit but not too much: */
      else if (size < MAX_LEGACY_SNPRINTF_SIZE)
        size *= 2;
      else
	{
	  free(buffer);
	  break;
	}

      /* Resize the buffer and try again. */
      buffer = xrealloc (buffer, size);
    }

  return xstrdup("<FAILURE>");
}

/* Return a new string based on fmt. */
char *
xsprintf (char *fmt, ...)
{
  char *buffer;
  va_list ap;

  va_start (ap, fmt);
  buffer = xvsprintf (fmt, ap);
  va_end (ap);

  return buffer;
}

/* strtok but do it for whitespace and be locale compliant. */
char *
strtok_ws (char *s)
{
  char *nonws;
  static char *last = NULL;

  if (s != NULL)
    last = s;
  else if (last == NULL)
    {
      PRINT_ERROR (("strtok_ws() called but not initalized, this is a *BUG*\n"));
      abort();
    }

  /* skip to first non-whitespace char. */
  while (*last && isspace ((unsigned char)*last))
    last++;

  /* If we reached the end of the string here then there is no more
     data. */
  if (*last == '\0')
    return NULL;

  /* Now skip to the end of the data. */
  nonws = last;
  while (*last && !isspace ((unsigned char)*last))
    last++;
  if (*last)
    {
      *last = '\0';
      last++;
    }
  return nonws;
}



================================================
FILE: src/util.h
================================================
#ifndef UTIL_H
#define UTIL_H

void fatal (const char *msg);
void *xmalloc (size_t size);
void *xrealloc (void *ptr, size_t size);
char *xstrdup (const char *s);
char *xvsprintf (char *fmt, va_list ap);
char *xsprintf (char *fmt, ...);
char *strtok_ws (char *s);
int str_comp (char *s1, char *s2, size_t len);

#endif



================================================
FILE: src/window.c
================================================
/* functions for handling the window list
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ratpoison.h"

LIST_HEAD(rp_unmapped_window);
LIST_HEAD(rp_mapped_window);

struct numset *rp_window_numset;

static void set_active_window_body (rp_window *win, int force);

/* Get the mouse position relative to the the specified window */
static void
get_mouse_position (rp_window *win, int *mouse_x, int *mouse_y)
{
  Window root_win, child_win;
  int root_x, root_y;
  unsigned int mask;

  XQueryPointer (dpy, win->scr->root, &root_win, &child_win, mouse_x, mouse_y, &root_x, &root_y, &mask);
}

void
free_window (rp_window *w)
{
  if (w == NULL) return;

  free (w->user_name);
  free (w->res_name);
  free (w->res_class);
  free (w->wm_name);

  XFree (w->hints);

  free (w);
}

void
update_window_gravity (rp_window *win)
{
/*   if (win->hints->win_gravity == ForgetGravity) */
/*     { */
      if (win->transient)
        win->gravity = defaults.trans_gravity;
      else if (win->hints->flags & PMaxSize || win->hints->flags & PAspect)
        win->gravity = defaults.maxsize_gravity;
      else
        win->gravity = defaults.win_gravity;
/*     } */
/*   else */
/*     { */
/*       win->gravity = win->hints->win_gravity; */
/*     } */
}

char *
window_name (rp_window *win)
{
  if (win == NULL) return NULL;

  if (win->named)
    return win->user_name;

  switch (defaults.win_name)
    {
    case WIN_NAME_RES_NAME:
      if (win->res_name)
        return win->res_name;
      else return win->user_name;

    case WIN_NAME_RES_CLASS:
      if (win->res_class)
        return win->res_class;
      else return win->user_name;

      /* if we're not looking for the res name or res class, then
         we're looking for the window title. */
    default:
      if (win->wm_name)
        return win->wm_name;
      else return win->user_name;
    }

  return NULL;
}

/* FIXME: we need to verify that the window is running on the same
   host as something. otherwise there could be overlapping PIDs. */
struct rp_child_info *
get_child_info (Window w)
{
  rp_child_info *cur;
  int status;
  int pid;
  Atom type_ret;
  int format_ret;
  unsigned long nitems;
  unsigned long bytes_after;
  unsigned char *req;

  status = XGetWindowProperty (dpy, w, _net_wm_pid,
                               0, 0, False, XA_CARDINAL,
                               &type_ret, &format_ret, &nitems, &bytes_after, &req);

  if (status != Success || req == NULL)
    {
      PRINT_DEBUG (("Couldn't get _NET_WM_PID Property\n"));
      return NULL;
    }

  /* XGetWindowProperty always allocates one extra byte even if
     the property is zero length. */
  XFree (req);

  status = XGetWindowProperty (dpy, w, _net_wm_pid,
                               0, (bytes_after / 4) + (bytes_after % 4 ? 1 : 0),
                               False, XA_CARDINAL, &type_ret, &format_ret, &nitems,
                               &bytes_after, &req);

  if (status != Success || req == NULL)
    {
      PRINT_DEBUG (("Couldn't get _NET_WM_PID Property\n"));
      return NULL;
    }

  pid = *((int *)req);
  XFree(req);

  PRINT_DEBUG(("pid: %d\n", pid));

  list_for_each_entry (cur, &rp_children, node)
    if (pid == cur->pid)
      return cur;

  return NULL;
}

/* Allocate a new window and add it to the list of managed windows */
rp_window *
add_to_window_list (rp_screen *s, Window w)
{
  struct rp_child_info *child_info;
  rp_window *new_window;
  rp_group *group = NULL;
  int frame_num = -1;

  new_window = xmalloc (sizeof (rp_window));

  new_window->w = w;
  new_window->scr = s;
  new_window->last_access = 0;
  new_window->state = WithdrawnState;
  new_window->number = -1;
  new_window->frame_number = EMPTY;
  new_window->intended_frame_number = -1;
  new_window->named = 0;
  new_window->hints = XAllocSizeHints ();
  new_window->colormap = DefaultColormap (dpy, s->screen_num);
  new_window->transient = XGetTransientForHint (dpy, new_window->w, &new_window->transient_for);
  PRINT_DEBUG (("transient %d\n", new_window->transient));

  update_window_gravity (new_window);

  get_mouse_position (new_window, &new_window->mouse_x, &new_window->mouse_y);

  XSelectInput (dpy, new_window->w, WIN_EVENTS);

  new_window->user_name = xstrdup ("Unnamed");

  new_window->wm_name = NULL;
  new_window->res_name = NULL;
  new_window->res_class = NULL;

  /* Add the window to the end of the unmapped list. */
  list_add_tail (&new_window->node, &rp_unmapped_window);

  child_info = get_child_info (w);

  if (child_info && !child_info->window_mapped) {
    rp_frame *frame = screen_find_frame_by_frame (child_info->screen, child_info->frame);

    PRINT_DEBUG(("frame=%p\n", frame));
    group = groups_find_group_by_group (child_info->group);
    if (frame)
      frame_num = frame->number;
    /* Only map the first window in the launch frame. */
    child_info->window_mapped = 1;
  }

  /* Add the window to the group it's pid was launched in or the
     current one. */
  if (group)
    group_add_window (group, new_window);
  else
    group_add_window (rp_current_group, new_window);

  PRINT_DEBUG(("frame_num: %d\n", frame_num));
  if (frame_num >= 0)
    new_window->intended_frame_number = frame_num;

  return new_window;
}

/* Check to see if the window is in the list of windows. */
rp_window *
find_window_in_list (Window w, struct list_head *list)
{
  rp_window *cur;

  list_for_each_entry (cur, list, node)
    {
      if (cur->w == w) return cur;
    }

  return NULL;
}

/* Check to see if the window is in any of the lists of windows. */
rp_window *
find_window (Window w)
{
  rp_window *win = NULL;


  win = find_window_in_list (w, &rp_mapped_window);

  if (!win)
    {
      win = find_window_in_list (w, &rp_unmapped_window);
      if (win)
        PRINT_DEBUG (("Window found in unmapped window list\n"));
      else
        PRINT_DEBUG (("Window not found.\n"));
    }
  else
    {
      PRINT_DEBUG (("Window found in mapped window list.\n"));
    }

  return win;
}

rp_window *
find_window_number (int n)
{
  rp_window *cur;

  list_for_each_entry (cur,&rp_mapped_window,node)
    {
/*       if (cur->state == STATE_UNMAPPED) continue; */

      if (n == cur->number) return cur;
    }

  return NULL;
}

rp_window *
find_window_name (char *name, int exact_match)
{
  rp_window_elem *cur;

  if (!exact_match)
    {
      list_for_each_entry (cur, &rp_current_group->mapped_windows, node)
        {
          if (str_comp (name, window_name (cur->win), strlen (name)))
            return cur->win;
        }
    }
  else
    {
      list_for_each_entry (cur, &rp_current_group->mapped_windows, node)
        {
          if (!strcmp (name, window_name (cur->win)))
            return cur->win;
        }
    }

  /* didn't find it */
  return NULL;
}

rp_window *
find_window_other (rp_screen *screen)
{
  return group_last_window (rp_current_group, screen);
}

/* Assumes the list is sorted by increasing number. Inserts win into
   to Right place to keep the list sorted. */
void
insert_into_list (rp_window *win, struct list_head *list)
{
  rp_window *cur;

  list_for_each_entry (cur, list, node)
    {
      if (cur->number > win->number)
        {
          list_add_tail (&win->node, &cur->node);
          return;
        }
    }

  list_add_tail(&win->node, list);
}

static void
save_mouse_position (rp_window *win)
{
  Window root_win, child_win;
  int root_x, root_y;
  unsigned int mask;

  /* In the case the XQueryPointer raises a BadWindow error, the
     window is not mapped or has been destroyed so it doesn't matter
     what we store in mouse_x and mouse_y since they will never be
     used again. */

  ignore_badwindow++;

  XQueryPointer (dpy, win->w, &root_win, &child_win,
                 &root_x, &root_y, &win->mouse_x, &win->mouse_y, &mask);

  ignore_badwindow--;
}

/* Takes focus away from last_win and gives focus to win */
void
give_window_focus (rp_window *win, rp_window *last_win)
{
  /* counter increments every time this function is called. This way
     we can track which window was last accessed. */
  static int counter = 1;

  /* Warp the cursor to the window's saved position if last_win and
     win are different windows. */
  if (last_win != NULL && win != last_win)
    {
      save_mouse_position (last_win);
      XSetWindowBorder (dpy, last_win->w, rp_glob_screen.bw_color);
    }

  if (win == NULL) return;

  counter++;
  win->last_access = counter;
  unhide_window (win);

  if (defaults.warp)
    {
      PRINT_DEBUG (("Warp pointer\n"));
      XWarpPointer (dpy, None, win->w,
                    0, 0, 0, 0, win->mouse_x, win->mouse_y);
    }

  /* Swap colormaps */
  if (last_win != NULL) XUninstallColormap (dpy, last_win->colormap);
  XInstallColormap (dpy, win->colormap);

  XSetWindowBorder (dpy, win->w, rp_glob_screen.fw_color);

  /* Finally, give the window focus */
  rp_current_screen = win->scr;
  set_rp_window_focus (win);

  XSync (dpy, False);
}

/* In the current frame, set the active window to win. win will have focus. */
void set_active_window (rp_window *win)
{
  set_active_window_body(win, 0);
}

void set_active_window_force (rp_window *win)
{
  set_active_window_body(win, 1);
}

static rp_frame *
find_frame_non_dedicated(rp_screen *current_screen)
{
  rp_frame *cur;
  rp_screen *screen;

  list_for_each_entry (screen, &rp_screens, node)
    {
      if (current_screen == screen)
        continue;

      list_for_each_entry (cur, &screen->frames, node)
        {
          if (!cur->dedicated)
            return cur;
        }
    }

  return NULL;
}

static void
set_active_window_body (rp_window *win, int force)
{
  rp_window *last_win;
  rp_frame *frame = NULL, *last_frame = NULL;

  if (win == NULL)
    return;

  PRINT_DEBUG (("intended_frame_number: %d\n", win->intended_frame_number));

  /* use the intended frame if we can. */
  if (win->intended_frame_number >= 0)
    {
      frame = screen_get_frame (rp_current_screen, win->intended_frame_number);
      win->intended_frame_number = -1;
      if (frame != current_frame ())
        last_frame = current_frame ();
    }

  if (frame == NULL)
    frame = screen_get_frame (rp_current_screen, rp_current_screen->current_frame);

  if (frame->dedicated && !force)
    {
      /* Try to find a non-dedicated frame. */
      rp_frame *non_dedicated;

      non_dedicated = find_frame_non_dedicated (rp_current_screen);
      if (non_dedicated != NULL)
        {
          last_frame = frame;
          frame = non_dedicated;
          set_active_frame (frame, 0);
        }
    }

  last_win = set_frames_window (frame, win);

  if (last_win != NULL)
    PRINT_DEBUG (("last window: %s\n", window_name (last_win)));
  PRINT_DEBUG (("new window: %s\n", window_name (win)));

  /* Make sure the window comes up full screen */
  maximize (win);

  /* Focus the window. */
  give_window_focus (win, last_win);

  /* The other windows in the frame will be hidden if this window
     doesn't qualify as a transient window (ie dialog box. */
  if (!window_is_transient (win))
    hide_others(win);

  /* Make sure the program bar is always on the top */
  update_window_names (win->scr, defaults.window_fmt);

  XSync (dpy, False);

  /* If we switched frame, go back to the old one. */
  if (last_frame != NULL)
    set_active_frame (last_frame, 0);

  /* Call the switch window hook */
  hook_run (&rp_switch_win_hook);
}

/* Go to the window, switching frames if the window is already in a
   frame. */
void
goto_window (rp_window *win)
{
  rp_frame *frame;

  /* There is nothing to do if it is already the current window. */
  if (current_window() == win)
    return;

  frame = find_windows_frame (win);
  if (frame)
    {
      set_active_frame (frame, 0);
    }
  else
    {
      set_active_window (win);
    }
}

/* get the window list and store it in buffer delimiting each window
   with delim. mark_start and mark_end will be filled with the text
   positions for the start and end of the current window. */
void
get_window_list (char *fmt, char *delim, struct sbuf *buffer,
                 int *mark_start, int *mark_end)
{
  rp_window_elem *we;

  if (buffer == NULL) return;

  sbuf_clear (buffer);
  find_window_other (rp_current_screen);

  /* We only loop through the current group to look for windows. */
  list_for_each_entry (we,&rp_current_group->mapped_windows,node)
    {
      PRINT_DEBUG (("%d-%s\n", we->number, window_name (we->win)));

      if (we->win == current_window())
        *mark_start = strlen (sbuf_get (buffer));

      /* A hack, pad the window with a space at the beginning and end
         if there is no delimiter. */
      if (!delim)
        sbuf_concat (buffer, " ");

      format_string (fmt, we, buffer);

      /* A hack, pad the window with a space at the beginning and end
         if there is no delimiter. */
      if (!delim)
        sbuf_concat (buffer, " ");

      /* Only put the delimiter between the windows, and not after the the last
         window. */
      if (delim && we->node.next != &rp_current_group->mapped_windows)
        sbuf_concat (buffer, delim);

      if (we->win == current_window())
        {
          *mark_end = strlen (sbuf_get (buffer));
        }
    }

  if (!strcmp (sbuf_get (buffer), ""))
    {
      sbuf_copy (buffer, MESSAGE_NO_MANAGED_WINDOWS);
    }
}

void
init_window_stuff (void)
{
  rp_window_numset = numset_new ();
}

void
free_window_stuff (void)
{
  rp_window *cur;
  struct list_head *tmp, *iter;

  list_for_each_safe_entry (cur, iter, tmp, &rp_unmapped_window, node)
    {
      list_del (&cur->node);
      groups_del_window (cur);
      free_window (cur);
    }

  list_for_each_safe_entry (cur, iter, tmp, &rp_mapped_window, node)
    {
      list_del (&cur->node);
      groups_unmap_window (cur);
      groups_del_window (cur);
      free_window (cur);
    }

  numset_free (rp_window_numset);
}

rp_frame *
win_get_frame (rp_window *win)
{
  if (win->frame_number != EMPTY)
    return screen_get_frame (win->scr, win->frame_number);
  else
    return NULL;
}

void
change_windows_screen (rp_screen *old_screen, rp_screen *new_screen)
{
  rp_window *win;

  list_for_each_entry (win, &rp_mapped_window, node)
    {
      if (win->scr == old_screen)
        win->scr = new_screen;
    }
}



================================================
FILE: src/window.h
================================================
/* functions for managing the window list
 * Copyright (C) 2000, 2001, 2002, 2003, 2004 Shawn Betts <sabetts@vcn.bc.ca>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef _RATPOISON_LIST_H
#define _RATPOISON_LIST_H 1

#include "sbuf.h"

void free_window (rp_window *w);
rp_window *add_to_window_list (rp_screen *s, Window w);
void last_window (void);
rp_window *find_window_in_list (Window w, struct list_head *list);
rp_window *find_window (Window w);
void maximize_current_window (void);
void give_window_focus (rp_window *win, rp_window *last_win);
void set_active_window (rp_window *win);
void set_active_window_force (rp_window *win);
void goto_window (rp_window *win);
void update_window_gravity (rp_window *win);
char *window_name (rp_window *win);

/* int goto_window_name (char *name); */
rp_window *find_window_other (rp_screen *screen);
rp_window *find_window_by_number (int n);
rp_window *find_window_name (char *name, int exact_match);
rp_window *find_window_number (int n);

void insert_into_list (rp_window *win, struct list_head *list);

void get_window_list (char *fmt, char *delim, struct sbuf *buffer,
                      int *mark_start, int *mark_end);
void init_window_stuff (void);
void free_window_stuff (void);

rp_frame *win_get_frame (rp_window *win);

struct rp_child_info *get_child_info (Window w);
void change_windows_screen (rp_screen *s, rp_screen *new_screen);

#endif /* ! _RATPOISON_LIST_H */



================================================
FILE: src/xrandr.c
================================================
/* functions for grabbing information about xrandr screens
 * Copyright (C) 2016 Mathieu OTHACEHE <m.othacehe@gmail.com>
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or moify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#include "ratpoison.h"

#ifdef HAVE_XRANDR

#include <X11/extensions/Xrandr.h>

static int xrandr_evbase;

#define XRANDR_MAJOR 1
#define XRANDR_MINOR 3

void
init_xrandr (void)
{
  int errbase, major, minor;

  if (!XRRQueryExtension (dpy, &xrandr_evbase, &errbase)) {
    return;
  }

  if (XRRQueryVersion (dpy, &major, &minor) == 0) {
    return;
  }

  if (major != XRANDR_MAJOR ||
      (major == XRANDR_MAJOR && minor < XRANDR_MINOR)) {
    PRINT_ERROR (("Xrandr version %d.%d is not supported\n", major, minor));
    return;
  }

  XRRSelectInput (dpy, RootWindow (dpy, DefaultScreen(dpy)),
                  RRCrtcChangeNotifyMask | RROutputChangeNotifyMask);

  rp_have_xrandr = 1;
}

int
xrandr_query_screen (int **outputs)
{
  XRRScreenResources *res;
  XRROutputInfo *outinfo;
  int *output_array;
  int count = 0;
  int i;

  res = XRRGetScreenResources (dpy, RootWindow (dpy, DefaultScreen (dpy)));
  output_array = xmalloc (res->noutput * sizeof(int));

  for (i = 0; i < res->noutput; i++) {
    outinfo = XRRGetOutputInfo (dpy, res, res->outputs[i]);
    if (!outinfo->crtc)
      continue;

    output_array[count++] = res->outputs[i];

    XRRFreeOutputInfo (outinfo);
  }

  XRRFreeScreenResources (res);

  *outputs = output_array;
  return count;
}

static rp_screen *
xrandr_screen_output (int rr_output)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (cur->xrandr.output == rr_output)
        return cur;
    }

  return NULL;
}

static rp_screen *
xrandr_screen_crtc (int rr_crtc)
{
  rp_screen *cur;

  list_for_each_entry (cur, &rp_screens, node)
    {
      if (cur->xrandr.crtc == rr_crtc)
        return cur;
    }

  return NULL;
}

int
xrandr_is_primary (rp_screen *screen)
{
  return screen->xrandr.primary;
}

void
xrandr_fill_screen (int rr_output, rp_screen *screen)
{
  XRRScreenResources *res;
  XRROutputInfo *outinfo;
  XRRCrtcInfo *crtinfo;
  RROutput primary;

  res = XRRGetScreenResourcesCurrent (dpy, RootWindow (dpy, DefaultScreen (dpy)));
  outinfo = XRRGetOutputInfo (dpy, res, rr_output);
  if (!outinfo->crtc)
    goto free_res;

  crtinfo = XRRGetCrtcInfo (dpy, res, outinfo->crtc);
  if (!crtinfo)
    goto free_out;

  primary = XRRGetOutputPrimary (dpy, RootWindow (dpy, DefaultScreen (dpy)));
  if (rr_output == primary)
    screen->xrandr.primary = 1;
  else
    screen->xrandr.primary = 0;

  screen->xrandr.name = xstrdup (outinfo->name);
  screen->xrandr.output  = rr_output;
  screen->xrandr.crtc    = outinfo->crtc;

  screen->left   = crtinfo->x;
  screen->top    = crtinfo->y;
  screen->width  = crtinfo->width;
  screen->height = crtinfo->height;

  XRRFreeCrtcInfo (crtinfo);
 free_out:
  XRRFreeOutputInfo (outinfo);
 free_res:
  XRRFreeScreenResources (res);
}

static void
xrandr_output_change (XRROutputChangeNotifyEvent *ev)
{
  XRRScreenResources *res;
  XRROutputInfo *outinfo;
  rp_screen *screen;

  res = XRRGetScreenResourcesCurrent (dpy, RootWindow (dpy, DefaultScreen (dpy)));
  outinfo = XRRGetOutputInfo (dpy, res, ev->output);

  screen = xrandr_screen_output (ev->output);

  if (!screen && outinfo->crtc) {
    screen = screen_add (ev->output);
    screen_sort ();
    PRINT_DEBUG (("%s: Added screen %s with crtc %lu\n", __func__,
                  screen->xrandr.name,
                  (unsigned long)outinfo->crtc));
  } else if (screen && !outinfo->crtc) {
    PRINT_DEBUG (("%s: Removing screen %s\n", __func__,
                  screen->xrandr.name));
    screen_del (screen);
  }

  XRRFreeOutputInfo (outinfo);
  XRRFreeScreenResources (res);
}

#ifdef DEBUG
static const char *
xrandr_rotation_string (Rotation r)
{
  static char buf[64];

#define CASE(c) case c : return #c
  switch (r)
    {
      CASE(RR_Rotate_0);
      CASE(RR_Rotate_90);
      CASE(RR_Rotate_180);
      CASE(RR_Rotate_270);
#undef CASE
    default:
      snprintf(buf, sizeof buf, "Unknown rotation %hu", (unsigned short)r);
      return buf;
  }
}
#endif

static void
xrandr_crtc_change (XRRCrtcChangeNotifyEvent *ev)
{
  rp_screen *screen;

  if (!ev->crtc || !ev->width || !ev->height)
    return;

  screen = xrandr_screen_crtc (ev->crtc);

  PRINT_DEBUG (("%s: crtc %s, rotation %s "
                "ev->x %d, ev->y %d, ev->width %d, ev->height %d\n",
                __func__, screen ? "found" : "not found",
                xrandr_rotation_string (ev->rotation),
                ev->x, ev->y, ev->width, ev->height));

  if (!screen)
    return;

  if (ev->rotation == RR_Rotate_90 || ev->rotation == RR_Rotate_270)
    screen_update (screen, ev->x, ev->y, ev->height, ev->width);
  else
    screen_update (screen, ev->x, ev->y, ev->width, ev->height);
}

void
xrandr_notify (XEvent *ev)
{
  XRRNotifyEvent *n_event;
  XRROutputChangeNotifyEvent *o_event;
  XRRCrtcChangeNotifyEvent *c_event;

  if (ev->type != xrandr_evbase + RRNotify)
    return;

  PRINT_DEBUG (("--- Handling RRNotify ---\n"));

  n_event = (XRRNotifyEvent *)ev;
  switch (n_event->subtype) {
  case RRNotify_OutputChange:
    PRINT_DEBUG (("---          XRROutputChangeNotifyEvent ---\n"));
    o_event = (XRROutputChangeNotifyEvent *)ev;
    xrandr_output_change (o_event);
    break;
  case RRNotify_CrtcChange:
    PRINT_DEBUG (("---          XRRCrtcChangeNotifyEvent ---\n"));
    c_event = (XRRCrtcChangeNotifyEvent *)ev;
    xrandr_crtc_change (c_event);
    break;
  case RRNotify_OutputProperty:
    PRINT_DEBUG (("---          RRNotify_OutputProperty ---\n"));
    break;
  default:
    PRINT_DEBUG (("---          Unknown subtype %d ---\n", n_event->subtype));
    break;
  }
}

#else /* HAVE_XRANDR */

void
init_xrandr(void)
{
  /* Nothing */
}

int
xrandr_query_screen (int **outputs)
{
  (void)outputs;
  fatal("xrandr_query_screen shouldn't be called.  This is a BUG.");
  return 0;
}

int
xrandr_is_primary (rp_screen *screen)
{
  (void)screen;
  fatal("xrandr_is_primary shouldn't be called.  This is a BUG.");
  return 0;
}

void
xrandr_fill_screen (int rr_output, rp_screen *screen)
{
  (void)rr_output;
  memset(&screen->xrandr, 0, sizeof(screen->xrandr));
  screen->xrandr.primary = (rr_output == 0);
  screen->xrandr.output  = rr_output;
  screen->xrandr.name = xstrdup ("N/A");
}

void
xrandr_notify (XEvent *ev)
{
  (void)ev;
  fatal("xrandr_notify shouldn't be called.  This is a BUG.");
}

#endif /* HAVE_XRANDR */



================================================
FILE: src/xrandr.h
================================================
/*
 * Copyright (C) 2016 Mathieu OTHACEHE
 *
 * This file is part of ratpoison.
 *
 * ratpoison is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * ratpoison is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 */

#ifndef XRANDR_H
#define XRANDR_H

#include "ratpoison.h"

void init_xrandr(void);
int xrandr_query_screen(int **outputs);
int xrandr_is_primary (rp_screen *screen);
void xrandr_fill_screen(int rr_output, rp_screen *screen);
void xrandr_notify(XEvent *ev);

#endif


